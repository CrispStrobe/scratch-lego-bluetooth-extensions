var en = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Build with SPIKE Prime or Robot Inventor (legacy v. 2 firmware with bluetooth classic). Supports motors, sensors, lights, and displays.",
	"gui.extension.spikeprime.connectingMessage": "Connecting to SPIKE Prime..."
};
var de = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Baue mit SPIKE Prime or Robot Inventor (alte Firmware Version 2.x). Unterstützt Motoren, Sensoren, Lichter und Displays.",
	"gui.extension.spikeprime.connectingMessage": "Verbinde mit SPIKE Prime..."
};
var fr = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Construisez avec SPIKE Prime ou Robot Inventor (v. 2 firmware). Prend en charge les moteurs, capteurs, lumières et écrans.",
	"gui.extension.spikeprime.connectingMessage": "Connexion à SPIKE Prime..."
};
var translations = {
	en: en,
	de: de,
	fr: fr
};

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAF0CAYAAAD/4EcMAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAACWKADAAQAAAABAAABdAAAAAAO8RAJAAAU8ElEQVR4Ae3YQW5cOQxFUVfDq/H+t2JvpxrIMBN9wY8BJZ6epaEw+ocaXNTr/f3x/vAfAQIECBAgQIBATOC/2CSDCBAgQIAAAQIE/ggILA+BAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECnwgIEPgHAl/vf/CPBP+Jn1dw2IBR9jtgyT6RwJ6AX7D2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBR4vb8/3stTDhAgQIAAAQIECDwW8AvWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBD6fHXOKQFjg6x0eWDzu5/W7f8D3/s6v+m/b757wtPe8p+M0gT8CfsHyEAgQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFjg9f7+eIdnGkeAAAECBAgQGC3gF6zR6/fxBAgQIECAQIWAwKpQNZMAAQIECBAYLSCwRq/fxxMgQIAAAQIVAgKrQtVMAgQIECBAYLSAwBq9fh9PgAABAgQIVAgIrApVMwkQIECAAIHRAgJr9Pp9PAECBAgQIFAhILAqVM0kQIAAAQIERgsIrNHr9/EECBAgQIBAhYDAqlA1kwABAgQIEBgtILBGr9/HEyBAgAABAhUCAqtC1UwCBAgQIEBgtIDAGr1+H0+AAAECBAhUCAisClUzCRAgQIAAgdECAmv0+n08AQIECBAgUCHwWTHUTAJLga/38kirAz+v313H9/7Or/pv2++e8LT3vKfjNIE/An7B8hAIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBY4PX+/niHZxpHgAABAgQIEBgt4Bes0ev38QQIECBAgECFgMCqUDWTAAECBAgQGC0gsEav38cTIECAAAECFQICq0LVTAIECBAgQGC0gMAavX4fT4AAAQIECFQICKwKVTMJECBAgACB0QICa/T6fTwBAgQIECBQISCwKlTNJECAAAECBEYLCKzR6/fxBAgQIECAQIWAwKpQNZMAAQIECBAYLSCwRq/fxxMgQIAAAQIVAgKrQtVMAgQIECBAYLSAwBq9fh9PgAABAgQIVAgIrApVMwkQIECAAIHRAgJr9Pp9PAECBAgQIFAh8Fkx1EwCBP4S+Hr/9T+a//Hn9bsL+t7f+VX/7d/ut/p+5hO4QMAvWBcs0ScQIECAAAECvQQEVq99uA0BAgQIECBwgYDAumCJPoEAAQIECBDoJSCweu3DbQgQIECAAIELBATWBUv0CQQIECBAgEAvAYHVax9uQ4AAAQIECFwgILAuWKJPIECAAAECBHoJCKxe+3AbAgQIECBA4AIBgXXBEn0CAQIECBAg0EtAYPXah9sQIECAAAECFwgIrAuW6BMIECBAgACBXgICq9c+3IYAAQIECBC4QEBgXbBEn0CAAAECBAj0EhBYvfbhNgQIECBAgMAFAgLrgiX6BAIECBAgQKCXgMDqtQ+3IUCAAAECBC4QEFgXLNEnECBAgAABAr0EBFavfbgNAQIECBAgcIGAwLpgiT6BAAECBAgQ6CUgsHrtw20IECBAgACBCwQE1gVL9AkECBAgQIBALwGB1WsfbkOAAAECBAhcICCwLliiTyBAgAABAgR6CQisXvtwGwIECBAgQOACAYF1wRJ9AgECBAgQINBLQGD12ofbECBAgAABAhcICKwLlugTCBAgQIAAgV4CAqvXPtyGAAECBAgQuEBAYF2wRJ9AgAABAgQI9BIQWL324TYECBAgQIDABQIC64Il+gQCBAgQIECgl4DA6rUPtyFAgAABAgQuEBBYFyzRJxAgQIAAAQK9BARWr324DQECBAgQIHCBgMC6YIk+gQABAgQIEOglILB67cNtCBAgQIAAgQsEBNYFS/QJBAgQIECAQC8BgdVrH25DgAABAgQIXCAgsC5Yok8gQIAAAQIEegkIrF77cBsCBAgQIEDgAgGBdcESfQIBAgQIECDQS0Bg9dqH2xAgQIAAAQIXCAisC5boEwgQIECAAIFeAq/398e715XchgABAgQIECBwtoBfsM7en9sTIECAAAECDQUEVsOluBIBAgQIECBwtoDAOnt/bk+AAAECBAg0FBBYDZfiSgQIECBAgMDZAgLr7P25PQECBAgQINBQQGA1XIorESBAgAABAmcLCKyz9+f2BAgQIECAQEMBgdVwKa5EgAABAgQInC0gsM7en9sTIECAAAECDQUEVsOluBIBAgQIECBwtoDAOnt/bk+AAAECBAg0FBBYDZfiSgQIECBAgMDZAgLr7P25PQECBAgQINBQQGA1XIorESBAgAABAmcLCKyz9+f2BAgQIECAQEOBz4Z3ciUCBE4X+Hqf9QU/r7Pu67YECLQX8AtW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCn6dd2H0JEDhA4Od1wCVdkQABAnUCfsGqszWZAAECBAgQGCogsIYu3mcTIECAAAECdQICq87WZAIECBAgQGCogMAaunifTYAAAQIECNQJCKw6W5MJECBAgACBoQICa+jifTYBAgQIECBQJyCw6mxNJkCAAAECBIYKCKyhi/fZBAgQIECAQJ2AwKqzNZkAAQIECBAYKiCwhi7eZxMgQIAAAQJ1AgKrztZkAgQIECBAYKiAwBq6eJ9NgAABAgQI1AkIrDpbkwkQIECAAIGhAgJr6OJ9NgECBAgQIFAnILDqbE0mQIAAAQIEhgoIrKGL99kECBAgQIBAnYDAqrM1mQABAgQIEBgqILCGLt5nEyBAgAABAnUCAqvO1mQCBAgQIEBgqIDAGrp4n02AAAECBAjUCQisOluTCRAgQIAAgaECAmvo4n02AQIECBAgUCcgsOpsTSZAgAABAgSGCgisoYv32QQIECBAgECdgMCqszWZAAECBAgQGCogsIYu3mcTIECAAAECdQICq87WZAIECBAgQGCogMAaunifTYAAAQIECNQJCKw6W5MJECBAgACBoQICa+jifTYBAgQIECBQJyCw6mxNJkCAAAECBIYKCKyhi/fZBAgQIECAQJ2AwKqzNZkAAQIECBAYKiCwhi7eZxMgQIAAAQJ1AgKrztZkAgQIECBAYKiAwBq6eJ9NgAABAgQI1AkIrDpbkwkQIECAAIGhAgJr6OJ9NgECBAgQIFAnILDqbE0mQIAAAQIEhgoIrKGL99kECBAgQIBAnYDAqrM1mQABAgQIEBgqILCGLt5nEyBAgAABAnUCAqvO1mQCBAgQIEBgqMD/dCwx5rhX9OkAAAAASUVORK5CYII=";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='40px' height='40px' viewBox='0 0 40 40' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3espikeprime-small%3c/title%3e %3cg id='spikeprime-small' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3crect id='body' stroke='%237C87A5' fill='white' x='9.5' y='4.5' width='21' height='31' rx='1.5'%3e%3c/rect%3e %3cg id='matrix' transform='translate(13.000000%2c 12.000000)' fill='%23FFD500'%3e %3crect id='d' x='6' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy' x='9' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-3' x='6' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-2' x='9' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-11' x='0' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-10' x='3' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-9' x='0' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-8' x='3' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-15' x='12' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-14' x='3' y='9' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-13' x='12' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-12' x='6' y='12' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-16' x='3' y='0' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-17' x='9' y='0' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-5' x='6' y='9' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-4' x='9' y='9' width='2' height='2'%3e%3c/rect%3e %3c/g%3e %3ccircle id='Oval' stroke='%234C97FF' cx='26.5' cy='8.5' r='1.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy' stroke='%237C87A5' cx='20' cy='31' r='2.5'%3e%3c/circle%3e %3c/g%3e%3c/svg%3e";

var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='79px' height='123px' viewBox='0 0 79 123' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3espikeprime-illustration%3c/title%3e %3cg id='spikeprime-illustration' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cg id='Group' transform='translate(1.000000%2c 1.000000)'%3e %3crect id='Rectangle' stroke='%237C87A5' fill='white' x='0' y='0' width='77' height='121' rx='5.5'%3e%3c/rect%3e %3ccircle id='Oval' stroke='%237C87A5' stroke-width='0.5' cx='5.5' cy='5.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy-3' stroke='%237C87A5' stroke-width='0.5' cx='71.5' cy='5.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy' stroke='%237C87A5' stroke-width='0.5' cx='5.5' cy='115.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy-5' stroke='%237C87A5' stroke-width='0.5' cx='71.5' cy='115.5' r='3.5'%3e%3c/circle%3e %3cpath d='M16.5%2c99 C13.4624339%2c99 11%2c101.462434 11%2c104.5 C11%2c107.537566 13.4624339%2c110 16.5%2c110 C38.5%2c110 38.5%2c110 60.5%2c110 C63.5375661%2c110 66%2c107.537566 66%2c104.5 C66%2c101.462434 63.5375661%2c99 60.5%2c99 C38.5%2c99 38.5%2c99 16.5%2c99 Z' id='Path' stroke='%237C87A5' stroke-width='0.5'%3e%3c/path%3e %3ccircle id='Center-Button' stroke='%237C87A5' stroke-width='1.5' fill='white' cx='38.5' cy='104.5' r='10.5'%3e%3c/circle%3e %3ccircle id='Bluetooth' stroke='%234C97FF' stroke-width='1.5' cx='60.5' cy='16.5' r='6.5'%3e%3c/circle%3e %3cg id='matrix' transform='translate(12.000000%2c 34.000000)' fill='%23FFD500'%3e %3crect id='Rectangle-Copy-24' x='0' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-26' x='11' y='0' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-25' x='11' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-29' x='22' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-28' x='33' y='0' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-27' x='33' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-31' x='44' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-42' x='0' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-40' x='11' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-39' x='11' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-38' x='22' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-37' x='22' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-36' x='33' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-35' x='33' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-34' x='44' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-45' x='22' y='44' width='9' height='9'%3e%3c/rect%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

/**
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.name',
      default: 'LEGO Education SPIKE Prime',
      description: 'Name for the SPIKE Prime extension'
    });
  },
  extensionId: 'spikeprime',
  collaborator: 'CrispStrobe',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.description',
      default: 'Build with SPIKE Prime or Robot Inventor (v. 3 firmware with BLE). Supports motors, sensors, lights, and displays.',
      description: 'Description for the SPIKE Prime extension'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: true,
  internetConnectionRequired: false,
  launchPeripheralConnectionFlow: true,
  useAutoScan: true,
  connectionIconURL: img,
  connectionSmallIconURL: img$1,
  get connectingMessage() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.connectingMessage',
      default: 'Connecting to SPIKE Prime (over BLE)...',
      description: 'Message shown when connecting to SPIKE Prime'
    });
  },
  helpLink: 'https://education.lego.com/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
  return t;
}

function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

var _spikeprimeble = {exports: {}};

/**
 * Block argument types
 * @enum {string}
 */
var argumentType;
var hasRequiredArgumentType;
function requireArgumentType() {
  if (hasRequiredArgumentType) return argumentType;
  hasRequiredArgumentType = 1;
  var ArgumentType = {
    /**
     * Numeric value with angle picker
     */
    ANGLE: 'angle',
    /**
     * Boolean value with hexagonal placeholder
     */
    BOOLEAN: 'Boolean',
    /**
     * Numeric value with color picker
     */
    COLOR: 'color',
    /**
     * Numeric value with text field
     */
    NUMBER: 'number',
    /**
     * String value with text field
     */
    STRING: 'string',
    /**
     * String value with matrix field
     */
    MATRIX: 'matrix',
    /**
     * MIDI note number with note picker (piano) field
     */
    NOTE: 'note',
    /**
     * Inline image on block (as part of the label)
     */
    IMAGE: 'image'
  };
  argumentType = ArgumentType;
  return argumentType;
}

/**
 * Types of block
 * @enum {string}
 */
var blockType;
var hasRequiredBlockType;
function requireBlockType() {
  if (hasRequiredBlockType) return blockType;
  hasRequiredBlockType = 1;
  var BlockType = {
    /**
     * Boolean reporter with hexagonal shape
     */
    BOOLEAN: 'Boolean',
    /**
     * A button (not an actual block) for some special action, like making a variable
     */
    BUTTON: 'button',
    /**
     * Command block
     */
    COMMAND: 'command',
    /**
     * Specialized command block which may or may not run a child branch
     * The thread continues with the next block whether or not a child branch ran.
     */
    CONDITIONAL: 'conditional',
    /**
     * Specialized hat block with no implementation function
     * This stack only runs if the corresponding event is emitted by other code.
     */
    EVENT: 'event',
    /**
     * Hat block which conditionally starts a block stack
     */
    HAT: 'hat',
    /**
     * Specialized command block which may or may not run a child branch
     * If a child branch runs, the thread evaluates the loop block again.
     */
    LOOP: 'loop',
    /**
     * General reporter with numeric or string value
     */
    REPORTER: 'reporter'
  };
  blockType = BlockType;
  return blockType;
}

var color$1;
var hasRequiredColor$1;
function requireColor$1() {
  if (hasRequiredColor$1) return color$1;
  hasRequiredColor$1 = 1;
  var Color = /*#__PURE__*/function () {
    function Color() {
      _classCallCheck(this, Color);
    }
    return _createClass(Color, null, [{
      key: "RGB_BLACK",
      get:
      /**
       * @typedef {object} RGBObject - An object representing a color in RGB format.
       * @property {number} r - the red component, in the range [0, 255].
       * @property {number} g - the green component, in the range [0, 255].
       * @property {number} b - the blue component, in the range [0, 255].
       */

      /**
       * @typedef {object} HSVObject - An object representing a color in HSV format.
       * @property {number} h - hue, in the range [0-359).
       * @property {number} s - saturation, in the range [0,1].
       * @property {number} v - value, in the range [0,1].
       */

      /** @type {RGBObject} */
      function get() {
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }

      /** @type {RGBObject} */
    }, {
      key: "RGB_WHITE",
      get: function get() {
        return {
          r: 255,
          g: 255,
          b: 255
        };
      }

      /**
       * Convert a Scratch decimal color to a hex string, #RRGGBB.
       * @param {number} decimal RGB color as a decimal.
       * @return {string} RGB color as #RRGGBB hex string.
       */
    }, {
      key: "decimalToHex",
      value: function decimalToHex(decimal) {
        if (decimal < 0) {
          decimal += 0xFFFFFF + 1;
        }
        var hex = Number(decimal).toString(16);
        hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
        return hex;
      }

      /**
       * Convert a Scratch decimal color to an RGB color object.
       * @param {number} decimal RGB color as decimal.
       * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "decimalToRgb",
      value: function decimalToRgb(decimal) {
        var a = decimal >> 24 & 0xFF;
        var r = decimal >> 16 & 0xFF;
        var g = decimal >> 8 & 0xFF;
        var b = decimal & 0xFF;
        return {
          r: r,
          g: g,
          b: b,
          a: a > 0 ? a : 255
        };
      }

      /**
       * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
       * CC-BY-SA Tim Down:
       * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
       * @param {!string} hex Hex representation of the color.
       * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "hexToRgb",
      value: function hexToRgb(hex) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      /**
       * Convert an RGB color object to a hex color.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {!string} Hex representation of the color.
       */
    }, {
      key: "rgbToHex",
      value: function rgbToHex(rgb) {
        return Color.decimalToHex(Color.rgbToDecimal(rgb));
      }

      /**
       * Convert an RGB color object to a Scratch decimal color.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {!number} Number representing the color.
       */
    }, {
      key: "rgbToDecimal",
      value: function rgbToDecimal(rgb) {
        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
      }

      /**
      * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
      * @param {!string} hex Hex representation of the color.
      * @return {!number} Number representing the color.
      */
    }, {
      key: "hexToDecimal",
      value: function hexToDecimal(hex) {
        return Color.rgbToDecimal(Color.hexToRgb(hex));
      }

      /**
       * Convert an HSV color to RGB format.
       * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
       * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "hsvToRgb",
      value: function hsvToRgb(hsv) {
        var h = hsv.h % 360;
        if (h < 0) h += 360;
        var s = Math.max(0, Math.min(hsv.s, 1));
        var v = Math.max(0, Math.min(hsv.v, 1));
        var i = Math.floor(h / 60);
        var f = h / 60 - i;
        var p = v * (1 - s);
        var q = v * (1 - s * f);
        var t = v * (1 - s * (1 - f));
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }
        return {
          r: Math.floor(r * 255),
          g: Math.floor(g * 255),
          b: Math.floor(b * 255)
        };
      }

      /**
       * Convert an RGB color to HSV format.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
       */
    }, {
      key: "rgbToHsv",
      value: function rgbToHsv(rgb) {
        var r = rgb.r / 255;
        var g = rgb.g / 255;
        var b = rgb.b / 255;
        var x = Math.min(Math.min(r, g), b);
        var v = Math.max(Math.max(r, g), b);

        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
        var h = 0;
        var s = 0;
        if (x !== v) {
          var f = r === x ? g - b : g === x ? b - r : r - g;
          var i = r === x ? 3 : g === x ? 5 : 1;
          h = (i - f / (v - x)) * 60 % 360;
          s = (v - x) / v;
        }
        return {
          h: h,
          s: s,
          v: v
        };
      }

      /**
       * Linear interpolation between rgb0 and rgb1.
       * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
       * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
       * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
       * @return {RGBObject} the interpolated color.
       */
    }, {
      key: "mixRgb",
      value: function mixRgb(rgb0, rgb1, fraction1) {
        if (fraction1 <= 0) return rgb0;
        if (fraction1 >= 1) return rgb1;
        var fraction0 = 1 - fraction1;
        return {
          r: fraction0 * rgb0.r + fraction1 * rgb1.r,
          g: fraction0 * rgb0.g + fraction1 * rgb1.g,
          b: fraction0 * rgb0.b + fraction1 * rgb1.b
        };
      }
    }]);
  }();
  color$1 = Color;
  return color$1;
}

var cast;
var hasRequiredCast;
function requireCast() {
  if (hasRequiredCast) return cast;
  hasRequiredCast = 1;
  var Color = requireColor$1();

  /**
   * @fileoverview
   * Utilities for casting and comparing Scratch data-types.
   * Scratch behaves slightly differently from JavaScript in many respects,
   * and these differences should be encapsulated below.
   * For example, in Scratch, add(1, join("hello", world")) -> 1.
   * This is because "hello world" is cast to 0.
   * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
   * Use when coercing a value before computation.
   */
  var Cast = /*#__PURE__*/function () {
    function Cast() {
      _classCallCheck(this, Cast);
    }
    return _createClass(Cast, null, [{
      key: "toNumber",
      value:
      /**
       * Scratch cast to number.
       * Treats NaN as 0.
       * In Scratch 2.0, this is captured by `interp.numArg.`
       * @param {*} value Value to cast to number.
       * @return {number} The Scratch-casted number value.
       */
      function toNumber(value) {
        // If value is already a number we don't need to coerce it with
        // Number().
        if (typeof value === 'number') {
          // Scratch treats NaN as 0, when needed as a number.
          // E.g., 0 + NaN -> 0.
          if (Number.isNaN(value)) {
            return 0;
          }
          return value;
        }
        var n = Number(value);
        if (Number.isNaN(n)) {
          // Scratch treats NaN as 0, when needed as a number.
          // E.g., 0 + NaN -> 0.
          return 0;
        }
        return n;
      }

      /**
       * Scratch cast to boolean.
       * In Scratch 2.0, this is captured by `interp.boolArg.`
       * Treats some string values differently from JavaScript.
       * @param {*} value Value to cast to boolean.
       * @return {boolean} The Scratch-casted boolean value.
       */
    }, {
      key: "toBoolean",
      value: function toBoolean(value) {
        // Already a boolean?
        if (typeof value === 'boolean') {
          return value;
        }
        if (typeof value === 'string') {
          // These specific strings are treated as false in Scratch.
          if (value === '' || value === '0' || value.toLowerCase() === 'false') {
            return false;
          }
          // All other strings treated as true.
          return true;
        }
        // Coerce other values and numbers.
        return Boolean(value);
      }

      /**
       * Scratch cast to string.
       * @param {*} value Value to cast to string.
       * @return {string} The Scratch-casted string value.
       */
    }, {
      key: "toString",
      value: function toString(value) {
        return String(value);
      }

      /**
       * Cast any Scratch argument to an RGB color array to be used for the renderer.
       * @param {*} value Value to convert to RGB color array.
       * @return {Array.<number>} [r,g,b], values between 0-255.
       */
    }, {
      key: "toRgbColorList",
      value: function toRgbColorList(value) {
        var color = Cast.toRgbColorObject(value);
        return [color.r, color.g, color.b];
      }

      /**
       * Cast any Scratch argument to an RGB color object to be used for the renderer.
       * @param {*} value Value to convert to RGB color object.
       * @return {RGBOject} [r,g,b], values between 0-255.
       */
    }, {
      key: "toRgbColorObject",
      value: function toRgbColorObject(value) {
        var color;
        if (typeof value === 'string' && value.substring(0, 1) === '#') {
          color = Color.hexToRgb(value);

          // If the color wasn't *actually* a hex color, cast to black
          if (!color) color = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
          };
        } else {
          color = Color.decimalToRgb(Cast.toNumber(value));
        }
        return color;
      }

      /**
       * Determine if a Scratch argument is a white space string (or null / empty).
       * @param {*} val value to check.
       * @return {boolean} True if the argument is all white spaces or null / empty.
       */
    }, {
      key: "isWhiteSpace",
      value: function isWhiteSpace(val) {
        return val === null || typeof val === 'string' && val.trim().length === 0;
      }

      /**
       * Compare two values, using Scratch cast, case-insensitive string compare, etc.
       * In Scratch 2.0, this is captured by `interp.compare.`
       * @param {*} v1 First value to compare.
       * @param {*} v2 Second value to compare.
       * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
       */
    }, {
      key: "compare",
      value: function compare(v1, v2) {
        var n1 = Number(v1);
        var n2 = Number(v2);
        if (n1 === 0 && Cast.isWhiteSpace(v1)) {
          n1 = NaN;
        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
          n2 = NaN;
        }
        if (isNaN(n1) || isNaN(n2)) {
          // At least one argument can't be converted to a number.
          // Scratch compares strings as case insensitive.
          var s1 = String(v1).toLowerCase();
          var s2 = String(v2).toLowerCase();
          if (s1 < s2) {
            return -1;
          } else if (s1 > s2) {
            return 1;
          }
          return 0;
        }
        // Handle the special case of Infinity
        if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
          return 0;
        }
        // Compare as numbers.
        return n1 - n2;
      }

      /**
       * Determine if a Scratch argument number represents a round integer.
       * @param {*} val Value to check.
       * @return {boolean} True if number looks like an integer.
       */
    }, {
      key: "isInt",
      value: function isInt(val) {
        // Values that are already numbers.
        if (typeof val === 'number') {
          if (isNaN(val)) {
            // NaN is considered an integer.
            return true;
          }
          // True if it's "round" (e.g., 2.0 and 2).
          return val === parseInt(val, 10);
        } else if (typeof val === 'boolean') {
          // `True` and `false` always represent integer after Scratch cast.
          return true;
        } else if (typeof val === 'string') {
          // If it contains a decimal point, don't consider it an int.
          return val.indexOf('.') < 0;
        }
        return false;
      }
    }, {
      key: "LIST_INVALID",
      get: function get() {
        return 'INVALID';
      }
    }, {
      key: "LIST_ALL",
      get: function get() {
        return 'ALL';
      }

      /**
       * Compute a 1-based index into a list, based on a Scratch argument.
       * Two special cases may be returned:
       * LIST_ALL: if the block is referring to all of the items in the list.
       * LIST_INVALID: if the index was invalid in any way.
       * @param {*} index Scratch arg, including 1-based numbers or special cases.
       * @param {number} length Length of the list.
       * @param {boolean} acceptAll Whether it should accept "all" or not.
       * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
       */
    }, {
      key: "toListIndex",
      value: function toListIndex(index, length, acceptAll) {
        if (typeof index !== 'number') {
          if (index === 'all') {
            return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
          }
          if (index === 'last') {
            if (length > 0) {
              return length;
            }
            return Cast.LIST_INVALID;
          } else if (index === 'random' || index === 'any') {
            if (length > 0) {
              return 1 + Math.floor(Math.random() * length);
            }
            return Cast.LIST_INVALID;
          }
        }
        index = Math.floor(Cast.toNumber(index));
        if (index < 1 || index > length) {
          return Cast.LIST_INVALID;
        }
        return index;
      }
    }]);
  }();
  cast = Cast;
  return cast;
}

var color;
var hasRequiredColor;
function requireColor() {
  if (hasRequiredColor) return color;
  hasRequiredColor = 1;
  var Color = {
    BLACK: 0,
    PINK: 1,
    PURPLE: 2,
    BLUE: 3,
    LIGHT_BLUE: 4,
    LIGHT_GREEN: 5,
    GREEN: 6,
    YELLOW: 7,
    ORANGE: 8,
    RED: 9,
    WHITE: 10,
    NONE: -1
  };
  color = Color;
  return color;
}

var setupTranslations_1;
var hasRequiredSetupTranslations;
function requireSetupTranslations() {
  if (hasRequiredSetupTranslations) return setupTranslations_1;
  hasRequiredSetupTranslations = 1;
  var setupTranslations = function setupTranslations(formatMessage) {
    var extTranslations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var localeSetup = formatMessage.setup();
    var translations = {
      'en': {
        'legobluetooth.motorPWM': '[PORT] start motor at [POWER] % power',
        'legobluetooth.motorStop': '[PORT] stop motor',
        'legobluetooth.motorRunFor': '[PORT] run [DIRECTION] for [VALUE] [UNIT]',
        'legobluetooth.motorGoDirectionToPosition': '[PORT] go [DIRECTION] to position [POSITION]',
        'legobluetooth.motorStart': '[PORT] start motor [DIRECTION]',
        'legobluetooth.motorSetSpeed': '[PORT] set speed to [SPEED] %',
        'legobluetooth.getRelativePosition': '[PORT] relative position',
        'legobluetooth.getPosition': '[PORT] position',
        'legobluetooth.motorResetRelativePosition': '[PORT] reset relative position to [RELATIVE_POSITION]',
        'legobluetooth.displayImageFor': 'turn on [MATRIX] for [DURATION] seconds',
        'legobluetooth.displayImage': 'turn on [MATRIX]',
        'legobluetooth.displayText': 'write [TEXT]',
        'legobluetooth.displayClear': 'turn off pixels',
        'legobluetooth.displaySetBrightness': 'set pixel brightness to [BRIGHTNESS] %',
        'legobluetooth.displaySetPixel': 'set pixel at [X] , [Y] to [BRIGHTNESS] %',
        'legobluetooth.centerButtonLights': 'set center button light to [COLOR]',
        'legobluetooth.ultrasonicLightUp': '[PORT] light up [LIGHT0] [LIGHT1] [LIGHT2] [LIGHT3]',
        'legobluetooth.getColor': '[PORT] color',
        'legobluetooth.getDistance': '[PORT] distance',
        'legobluetooth.getForce': '[PORT] force',
        'legobluetooth.getTilt': '[PORT] tilt [XY]',
        'legobluetooth.setHubLEDColor': 'set hub LED color to [COLOR]',
        'legobluetooth.getHubTilt': 'hub tilt [XYZ]',
        'legobluetooth.getAngle': '[AXIS] angle',
        'legobluetooth.getName': 'name',
        'legobluetooth.getFirmwareVersion': 'firmware version',
        'legobluetooth.getBatteryLevel': 'battery level',
        'legobluetooth.rotations': 'rotations',
        'legobluetooth.degrees': 'degrees',
        'legobluetooth.seconds': 'seconds',
        'legobluetooth.shortestPath': 'shortest',
        'legobluetooth.clockwise': 'clockwise',
        'legobluetooth.counterclockwise': 'counterclockwise',
        'legobluetooth.black': '(0) Black',
        'legobluetooth.pink': '(1) Pink',
        'legobluetooth.purple': '(2) Purple',
        'legobluetooth.blue': '(3) Blue',
        'legobluetooth.lightBlue': '(4) Light blue',
        'legobluetooth.lightGreen': '(5) Light green',
        'legobluetooth.green': '(6) Green',
        'legobluetooth.yellow': '(7) Yellow',
        'legobluetooth.orange': '(8) Orange',
        'legobluetooth.red': '(9) Red',
        'legobluetooth.white': '(10) White',
        'legobluetooth.noColor': '(-1) No color',
        'legobluetooth.pitch': 'pitch',
        'legobluetooth.roll': 'roll',
        'legobluetooth.yaw': 'yaw'
      },
      'it': {},
      'ja': {
        'legobluetooth.motorPWM': '[PORT] モーターを [POWER] %のパワーで回す',
        'legobluetooth.motorStop': '[PORT] モーターを止める',
        'legobluetooth.motorRunFor': '[PORT] モーターを [DIRECTION] 方向に [VALUE] [UNIT] 回す',
        'legobluetooth.motorGoDirectionToPosition': '[PORT] モーターを [DIRECTION] で位置 [POSITION] まで回す',
        'legobluetooth.motorStart': '[PORT] モーターを [DIRECTION] 方向に回す',
        'legobluetooth.motorSetSpeed': '[PORT] スピードを [SPEED] %にする',
        'legobluetooth.getRelativePosition': '[PORT] 相対位置',
        'legobluetooth.getPosition': '[PORT] 位置',
        'legobluetooth.motorResetRelativePosition': '[PORT] 相対位置を [RELATIVE_POSITION] にリセットする',
        'legobluetooth.displayImageFor': '[MATRIX] を [DURATION] 秒間オンにする',
        'legobluetooth.displayImage': '[MATRIX] をオンにする',
        'legobluetooth.displayText': '[TEXT] を表示する',
        'legobluetooth.displayClear': 'すべてのピクセルをオフにする',
        'legobluetooth.displaySetBrightness': 'ピクセルの明るさを [BRIGHTNESS] %にする',
        'legobluetooth.displaySetPixel': '[X] , [Y] のピクセルの明るさを [BRIGHTNESS] %にする',
        'legobluetooth.centerButtonLights': 'センターボタンのライトを [COLOR] にする',
        'legobluetooth.ultrasonicLightUp': '[PORT] を [LIGHT0] [LIGHT1] [LIGHT2] [LIGHT3] でライトアップする',
        'legobluetooth.getColor': '[PORT] 色',
        'legobluetooth.getDistance': '[PORT] 距離',
        'legobluetooth.getForce': '[PORT] 圧力',
        'legobluetooth.getTilt': '[PORT] 傾き [XY]',
        'legobluetooth.setHubLEDColor': 'ハブのLEDを [COLOR] にする',
        'legobluetooth.getHubTilt': 'ハブの傾き [XYZ]',
        'legobluetooth.getAngle': '[AXIS] 角',
        'legobluetooth.getName': '名前',
        'legobluetooth.getFirmwareVersion': 'ファームウェアバージョン',
        'legobluetooth.getBatteryLevel': '電池残量',
        'legobluetooth.rotations': '回転',
        'legobluetooth.degrees': '度',
        'legobluetooth.seconds': '秒',
        'legobluetooth.shortestPath': '最短経路',
        'legobluetooth.clockwise': '時計回り',
        'legobluetooth.counterclockwise': '反時計回り',
        'legobluetooth.black': '(0) 黒',
        'legobluetooth.pink': '(1) ピンク',
        'legobluetooth.purple': '(2) 紫',
        'legobluetooth.blue': '(3) 青',
        'legobluetooth.lightBlue': '(4) 水色',
        'legobluetooth.lightGreen': '(5) 明るい緑',
        'legobluetooth.green': '(6) 緑',
        'legobluetooth.yellow': '(7) 黄色',
        'legobluetooth.orange': '(8) オレンジ',
        'legobluetooth.red': '(9) 赤',
        'legobluetooth.white': '(10) 白',
        'legobluetooth.noColor': '(-1) 色なし',
        'legobluetooth.pitch': 'ピッチ',
        'legobluetooth.roll': 'ロール',
        'legobluetooth.yaw': 'ヨー'
      },
      'ja-Hira': {
        'legobluetooth.motorPWM': '[PORT] モーターを [POWER] %のパワーでまわす',
        'legobluetooth.motorStop': '[PORT] モーターをとめる',
        'legobluetooth.motorRunFor': '[PORT] モーターを [DIRECTION] ほうこうに [VALUE] [UNIT] まわす',
        'legobluetooth.motorGoDirectionToPosition': '[PORT] モーターを [DIRECTION] でいち [POSITION] までまわす',
        'legobluetooth.motorStart': '[PORT] モーターを [DIRECTION] ほうこうにまわす',
        'legobluetooth.motorSetSpeed': '[PORT] スピードを [SPEED] %にする',
        'legobluetooth.getRelativePosition': '[PORT] そうたいいち',
        'legobluetooth.getPosition': '[PORT] いち',
        'legobluetooth.motorResetRelativePosition': '[PORT] そうたいいちを [RELATIVE_POSITION] にリセットする',
        'legobluetooth.displayImageFor': '[MATRIX] を [DURATION] びょうかんオンにする',
        'legobluetooth.displayImage': '[MATRIX] をオンにする',
        'legobluetooth.displayText': '[TEXT] をひょうじする',
        'legobluetooth.displayClear': 'すべてのピクセルをオフにする',
        'legobluetooth.displaySetBrightness': 'ピクセルのあかるさを [BRIGHTNESS] %にする',
        'legobluetooth.displaySetPixel': '[X] , [Y] のピクセルのあかるさを [BRIGHTNESS] %にする',
        'legobluetooth.centerButtonLights': 'センターボタンのライトを [COLOR] にする',
        'legobluetooth.ultrasonicLightUp': '[PORT] を [LIGHT0] [LIGHT1] [LIGHT2] [LIGHT3] でライトアップする',
        'legobluetooth.getColor': '[PORT] いろ',
        'legobluetooth.getDistance': '[PORT] きょり',
        'legobluetooth.getForce': '[PORT] あつりょく',
        'legobluetooth.getTilt': '[PORT] かたむき [XY]',
        'legobluetooth.setHubLEDColor': 'ハブのLEDを [COLOR] にする',
        'legobluetooth.getHubTilt': 'ハブのかたむき [XYZ]',
        'legobluetooth.getAngle': '[AXIS] かく',
        'legobluetooth.getName': 'なまえ',
        'legobluetooth.getFirmwareVersion': 'ファームウェアバージョン',
        'legobluetooth.getBatteryLevel': 'でんちざんりょう',
        'legobluetooth.rotations': 'かいてん',
        'legobluetooth.degrees': 'ど',
        'legobluetooth.seconds': 'びょう',
        'legobluetooth.shortestPath': 'さいたんきょり',
        'legobluetooth.clockwise': 'とけいまわり',
        'legobluetooth.counterclockwise': 'はんとけいまわり',
        'legobluetooth.black': '(0) くろ',
        'legobluetooth.pink': '(1) ピンク',
        'legobluetooth.purple': '(2) むらさき',
        'legobluetooth.blue': '(3) あお',
        'legobluetooth.lightBlue': '(4) みずいろ',
        'legobluetooth.lightGreen': '(5) あかるいみどり',
        'legobluetooth.green': '(6) みどり',
        'legobluetooth.yellow': '(7) きいろ',
        'legobluetooth.orange': '(8) オレンジ',
        'legobluetooth.red': '(9) あか',
        'legobluetooth.white': '(10) しろ',
        'legobluetooth.noColor': '(-1) いろなし',
        'legobluetooth.pitch': 'ピッチ',
        'legobluetooth.roll': 'ロール',
        'legobluetooth.yaw': 'ヨー'
      }
    };
    for (var locale in translations) {
      if (extTranslations[locale]) {
        Object.assign(translations[locale], extTranslations[locale]);
      }
      if (!localeSetup.translations[locale]) {
        localeSetup.translations[locale] = {};
      }
      Object.assign(localeSetup.translations[locale], translations[locale]);
    }
  };
  setupTranslations_1 = setupTranslations;
  return setupTranslations_1;
}

var bleBaseBlocks;
var hasRequiredBleBaseBlocks;
function requireBleBaseBlocks() {
  if (hasRequiredBleBaseBlocks) return bleBaseBlocks;
  hasRequiredBleBaseBlocks = 1;
  var ArgumentType = requireArgumentType();
  var BlockType = requireBlockType();
  var Cast = requireCast();
  var Color = requireColor();
  var _setupTranslations = requireSetupTranslations();
  var BLESendInterval = 100;
  var waitPromise = function waitPromise() {
    return new Promise(function (resolve) {
      return window.setTimeout(resolve, BLESendInterval);
    });
  };
  var BleBaseBlocks = /*#__PURE__*/function () {
    function BleBaseBlocks(peripheral) {
      _classCallCheck(this, BleBaseBlocks);
      this._peripheral = peripheral;
    }
    return _createClass(BleBaseBlocks, [{
      key: "externalPorts",
      get: function get() {
        return ['A', 'B', 'C', 'D'];
      }
    }, {
      key: "multipleExternalPorts",
      get: function get() {
        return ['A', 'B', 'C', 'D', 'A+B', 'C+D', 'A+B+C+D'];
      }
    }, {
      key: "hasInternalTiltSensorBlocks",
      get: function get() {
        return true;
      }
    }, {
      key: "hasAdvancedBlocks",
      get: function get() {
        return false;
      }
    }, {
      key: "getBlocks",
      value: function getBlocks(formatMessage) {
        var blocks = [{
          opcode: 'motorPWM',
          text: formatMessage({
            id: 'legobluetooth.motorPWM',
            default: '[PORT] start motor at [POWER] % power'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            POWER: {
              type: ArgumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'motorStop',
          text: formatMessage({
            id: 'legobluetooth.motorStop',
            default: '[PORT] stop motor'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            }
          }
        }, '---', {
          opcode: 'motorRunFor',
          text: formatMessage({
            id: 'legobluetooth.motorRunFor',
            default: '[PORT] run [DIRECTION] for [VALUE] [UNIT]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            DIRECTION: {
              type: ArgumentType.NUMBER,
              menu: 'DIRECTION',
              defaultValue: 1
            },
            VALUE: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            UNIT: {
              type: ArgumentType.STRING,
              menu: 'MOTOR_UNIT',
              defaultValue: 'rotations'
            }
          }
        }, {
          opcode: 'motorStart',
          text: formatMessage({
            id: 'legobluetooth.motorStart',
            default: '[PORT] start motor [DIRECTION]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            DIRECTION: {
              type: ArgumentType.NUMBER,
              menu: 'DIRECTION',
              defaultValue: 1
            }
          }
        }, {
          opcode: 'motorSetSpeed',
          text: formatMessage({
            id: 'legobluetooth.motorSetSpeed',
            default: '[PORT] set speed to [SPEED] %'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            SPEED: {
              type: ArgumentType.NUMBER,
              defaultValue: 75
            }
          }
        }, {
          opcode: 'getRelativePosition',
          text: formatMessage({
            id: 'legobluetooth.getRelativePosition',
            default: '[PORT] relative position'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'motorResetRelativePosition',
          text: formatMessage({
            id: 'legobluetooth.motorResetRelativePosition',
            default: '[PORT] reset relative position to [RELATIVE_POSITION]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            RELATIVE_POSITION: {
              type: ArgumentType.NUMBER,
              defaultValue: 0
            }
          }
        }, '---', {
          opcode: 'getColor',
          text: formatMessage({
            id: 'legobluetooth.getColor',
            default: '[PORT] color'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getDistance',
          text: formatMessage({
            id: 'legobluetooth.getDistance',
            default: '[PORT] distance'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getForce',
          text: formatMessage({
            id: 'legobluetooth.getForce',
            default: '[PORT] force'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getTilt',
          text: formatMessage({
            id: 'legobluetooth.getTilt',
            default: '[PORT] tilt [XY]'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            XY: {
              type: ArgumentType.STRING,
              menu: 'XY',
              defaultValue: 'x'
            }
          }
        }, '---', {
          opcode: 'setHubLEDColor',
          text: formatMessage({
            id: 'legobluetooth.setHubLEDColor',
            default: 'set hub LED color to [COLOR]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            COLOR: {
              type: ArgumentType.NUMBER,
              menu: 'LED_COLOR',
              defaultValue: Color.BLUE
            }
          }
        }];
        if (this.hasInternalTiltSensorBlocks) {
          blocks.push({
            opcode: 'getHubTilt',
            text: formatMessage({
              id: 'legobluetooth.getHubTilt',
              default: 'hub tilt [XYZ]'
            }),
            blockType: BlockType.REPORTER,
            arguments: {
              XYZ: {
                type: ArgumentType.STRING,
                menu: 'XYZ',
                defaultValue: 'x'
              }
            }
          });
        }
        if (this.hasAdvancedBlocks) {
          blocks.push({
            opcode: 'getName',
            text: formatMessage({
              id: 'legobluetooth.getName',
              default: 'name'
            }),
            blockType: BlockType.REPORTER
          });
          blocks.push({
            opcode: 'getFirmwareVersion',
            text: formatMessage({
              id: 'legobluetooth.getFirmwareVersion',
              default: 'firmware version'
            }),
            blockType: BlockType.REPORTER
          });
          blocks.push({
            opcode: 'getBatteryLevel',
            text: formatMessage({
              id: 'legobluetooth.getBatteryLevel',
              default: 'battery level'
            }),
            blockType: BlockType.REPORTER
          });
        }
        return blocks;
      }
    }, {
      key: "getMenus",
      value: function getMenus(formatMessage) {
        return {
          PORT: {
            acceptReporters: true,
            items: this.externalPorts
          },
          MULTIPLE_PORT: {
            acceptReporters: true,
            items: this.multipleExternalPorts
          },
          MOTOR_UNIT: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'legobluetooth.rotations',
                default: 'rotations'
              }),
              value: 'rotations'
            }, {
              text: formatMessage({
                id: 'legobluetooth.degrees',
                default: 'degrees'
              }),
              value: 'degrees'
            }, {
              text: formatMessage({
                id: 'legobluetooth.seconds',
                default: 'seconds'
              }),
              value: 'seconds'
            }]
          },
          DIRECTION: {
            acceptReporters: false,
            items: [{
              text: '⬆︎',
              value: '1'
            }, {
              text: '⬇',
              value: '-1'
            }]
          },
          LED_COLOR: {
            acceptReporters: true,
            items: [{
              text: formatMessage({
                id: 'legobluetooth.black',
                default: '(0) Black'
              }),
              value: String(Color.BLACK)
            }, {
              text: formatMessage({
                id: 'legobluetooth.pink',
                default: '(1) Pink'
              }),
              value: String(Color.PINK)
            }, {
              text: formatMessage({
                id: 'legobluetooth.purple',
                default: '(2) Purple'
              }),
              value: String(Color.PURPLE)
            }, {
              text: formatMessage({
                id: 'legobluetooth.blue',
                default: '(3) Blue'
              }),
              value: String(Color.BLUE)
            }, {
              text: formatMessage({
                id: 'legobluetooth.lightBlue',
                default: '(4) Light blue'
              }),
              value: String(Color.LIGHT_BLUE)
            }, {
              text: formatMessage({
                id: 'legobluetooth.lightGreen',
                default: '(5) Light green'
              }),
              value: String(Color.LIGHT_GREEN)
            }, {
              text: formatMessage({
                id: 'legobluetooth.green',
                default: '(6) Green'
              }),
              value: String(Color.GREEN)
            }, {
              text: formatMessage({
                id: 'legobluetooth.yellow',
                default: '(7) Yellow'
              }),
              value: String(Color.YELLOW)
            }, {
              text: formatMessage({
                id: 'legobluetooth.orange',
                default: '(8) Orange'
              }),
              value: String(Color.ORANGE)
            }, {
              text: formatMessage({
                id: 'legobluetooth.red',
                default: '(9) Red'
              }),
              value: String(Color.RED)
            }, {
              text: formatMessage({
                id: 'legobluetooth.white',
                default: '(10) White'
              }),
              value: String(Color.WHITE)
            }]
          },
          XY: {
            acceptReporters: false,
            items: ['x', 'y']
          },
          XYZ: {
            acceptReporters: false,
            items: ['x', 'y', 'z']
          }
        };
      }
    }, {
      key: "_validatePorts",
      value: function _validatePorts(text) {
        return text.toUpperCase().replace(/[^ABCD]/g, '').split('').filter(function (x, i, self) {
          return self.indexOf(x) === i;
        }).sort();
      }
    }, {
      key: "motorPWM",
      value: function motorPWM(args) {
        var _this = this;
        var power = Cast.toNumber(args.POWER);
        var ports = this._validatePorts(Cast.toString(args.PORT));
        var promises = ports.map(function (port) {
          var portId = _this.externalPorts.indexOf(port);
          return _this._peripheral.motorPWM(portId, power);
        });
        return Promise.all(promises).then(waitPromise);
      }
    }, {
      key: "motorStop",
      value: function motorStop(args) {
        var _this2 = this;
        var ports = this._validatePorts(Cast.toString(args.PORT));
        var promises = ports.map(function (port) {
          var portId = _this2.externalPorts.indexOf(port);
          return _this2._peripheral.motorPWM(portId, 0);
        });
        return Promise.all(promises).then(waitPromise);
      }
    }, {
      key: "motorRunFor",
      value: function motorRunFor(args) {
        var direction = args.DIRECTION;
        var value = Cast.toNumber(args.VALUE);
        var unit = args.UNIT;
        var ports = this._validatePorts(Cast.toString(args.PORT));
        switch (unit) {
          case 'rotations':
            return this._motorRunForDegrees(ports, direction, value * 360);
          case 'degrees':
            return this._motorRunForDegrees(ports, direction, value);
          case 'seconds':
            return this._motorRunTimed(ports, direction, value);
          default:
            return Promise.resolve();
        }
      }
    }, {
      key: "_motorRunForDegrees",
      value: function _motorRunForDegrees(ports, direction, degrees) {
        var _this3 = this;
        var promises = ports.map(function (port) {
          var portId = _this3.externalPorts.indexOf(port);
          return _this3._peripheral.motorRunForDegrees(portId, direction, degrees);
        });
        return Promise.all(promises).then(function () {});
      }
    }, {
      key: "_motorRunTimed",
      value: function _motorRunTimed(ports, direction, seconds) {
        var _this4 = this;
        var promises = ports.map(function (port) {
          var portId = _this4.externalPorts.indexOf(port);
          return _this4._peripheral.motorRunTimed(portId, direction, seconds);
        });
        return Promise.all(promises).then(function () {});
      }
    }, {
      key: "motorStart",
      value: function motorStart(args) {
        var _this5 = this;
        var direction = args.DIRECTION;
        var ports = this._validatePorts(Cast.toString(args.PORT));
        var promises = ports.map(function (port) {
          var portId = _this5.externalPorts.indexOf(port);
          return _this5._peripheral.motorStart(portId, direction);
        });
        return Promise.all(promises).then(waitPromise);
      }
    }, {
      key: "motorSetSpeed",
      value: function motorSetSpeed(args) {
        var _this6 = this;
        var speed = Cast.toNumber(args.SPEED);
        var ports = this._validatePorts(Cast.toString(args.PORT));
        ports.forEach(function (port) {
          var portId = _this6.externalPorts.indexOf(port);
          _this6._peripheral.motorSetSpeed(portId, speed);
        });
        return Promise.resolve();
      }
    }, {
      key: "motorResetRelativePosition",
      value: function motorResetRelativePosition(args) {
        var _this7 = this;
        var relativePosition = Cast.toNumber(args.RELATIVE_POSITION);
        var ports = this._validatePorts(Cast.toString(args.PORT));
        var promises = ports.map(function (port) {
          var portId = _this7.externalPorts.indexOf(port);
          return _this7._peripheral.motorResetRelativePosition(portId, relativePosition);
        });
        return Promise.all(promises).then(waitPromise);
      }
    }, {
      key: "getRelativePosition",
      value: function getRelativePosition(args) {
        return this._getSensorValue(args, 'relativePosition', 0);
      }
    }, {
      key: "getColor",
      value: function getColor(args) {
        return this._getSensorValue(args, 'color', -1);
      }
    }, {
      key: "getDistance",
      value: function getDistance(args) {
        return this._getSensorValue(args, 'distance', 0);
      }
    }, {
      key: "getForce",
      value: function getForce(args) {
        return this._getSensorValue(args, 'force', 0);
      }
    }, {
      key: "getTilt",
      value: function getTilt(args) {
        var key = 'tilt' + args.XY.toUpperCase();
        return this._getSensorValue(args, key, 0);
      }
    }, {
      key: "_getSensorValue",
      value: function _getSensorValue(args, key, defaultValue) {
        var port = this._validatePorts(Cast.toString(args.PORT)).shift();
        if (port) {
          var portId = this.externalPorts.indexOf(port);
          var value = this._peripheral.inputValue(portId, key);
          return value != null ? value : defaultValue;
        }
        return defaultValue;
      }
    }, {
      key: "setHubLEDColor",
      value: function setHubLEDColor(args) {
        var color = Cast.toNumber(args.COLOR);
        return this._peripheral.setLEDColor(color).then(waitPromise);
      }
    }, {
      key: "getHubTilt",
      value: function getHubTilt(args) {
        var key = 'tilt' + args.XYZ.toUpperCase();
        var value = this._peripheral.internalInputValue(key);
        return value != null ? value : 0;
      }
    }, {
      key: "getName",
      value: function getName() {
        return this._peripheral.name ? this._peripheral.name : "";
      }
    }, {
      key: "getFirmwareVersion",
      value: function getFirmwareVersion() {
        return this._peripheral.firmwareVersion ? this._peripheral.firmwareVersion : "";
      }
    }, {
      key: "getBatteryLevel",
      value: function getBatteryLevel() {
        return this._peripheral.batteryLevel;
      }
    }, {
      key: "setupTranslations",
      value: function setupTranslations(formatMessage) {
        _setupTranslations(formatMessage);
      }
    }]);
  }();
  bleBaseBlocks = BleBaseBlocks;
  return bleBaseBlocks;
}

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

var jsonrpc;
var hasRequiredJsonrpc;
function requireJsonrpc() {
  if (hasRequiredJsonrpc) return jsonrpc;
  hasRequiredJsonrpc = 1;
  var JSONRPC = /*#__PURE__*/function () {
    function JSONRPC() {
      _classCallCheck(this, JSONRPC);
      this._requestID = 0;
      this._openRequests = {};
    }

    /**
     * Make an RPC request and retrieve the result.
     * @param {string} method - the remote method to call.
     * @param {object} params - the parameters to pass to the remote method.
     * @returns {Promise} - a promise for the result of the call.
     */
    return _createClass(JSONRPC, [{
      key: "sendRemoteRequest",
      value: function sendRemoteRequest(method, params) {
        var _this = this;
        var requestID = this._requestID++;
        var promise = new Promise(function (resolve, reject) {
          _this._openRequests[requestID] = {
            resolve: resolve,
            reject: reject
          };
        });
        this._sendRequest(method, params, requestID);
        return promise;
      }

      /**
       * Make an RPC notification with no expectation of a result or callback.
       * @param {string} method - the remote method to call.
       * @param {object} params - the parameters to pass to the remote method.
       */
    }, {
      key: "sendRemoteNotification",
      value: function sendRemoteNotification(method, params) {
        this._sendRequest(method, params);
      }

      /**
       * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
       * @param {string} method - the method requested by the remote caller.
       * @param {object} params - the parameters sent with the remote caller's request.
       */
    }, {
      key: "didReceiveCall",
      value: function didReceiveCall(/* method , params */
      ) {
        throw new Error('Must override didReceiveCall');
      }
    }, {
      key: "_sendMessage",
      value: function _sendMessage(/* jsonMessageObject */
      ) {
        throw new Error('Must override _sendMessage');
      }
    }, {
      key: "_sendRequest",
      value: function _sendRequest(method, params, id) {
        var request = {
          jsonrpc: '2.0',
          method: method,
          params: params
        };
        if (id !== null) {
          request.id = id;
        }
        this._sendMessage(request);
      }
    }, {
      key: "_handleMessage",
      value: function _handleMessage(json) {
        if (json.jsonrpc !== '2.0') {
          throw new Error("Bad or missing JSON-RPC version in message: ".concat(json));
        }
        if (Object.prototype.hasOwnProperty.call(json, 'method')) {
          this._handleRequest(json);
        } else {
          this._handleResponse(json);
        }
      }
    }, {
      key: "_sendResponse",
      value: function _sendResponse(id, result, error) {
        var response = {
          jsonrpc: '2.0',
          id: id
        };
        if (error) {
          response.error = error;
        } else {
          response.result = result || null;
        }
        this._sendMessage(response);
      }
    }, {
      key: "_handleResponse",
      value: function _handleResponse(json) {
        var result = json.result,
          error = json.error,
          id = json.id;
        var openRequest = this._openRequests[id];
        delete this._openRequests[id];
        if (openRequest) {
          if (error) {
            openRequest.reject(error);
          } else {
            openRequest.resolve(result);
          }
        }
      }
    }, {
      key: "_handleRequest",
      value: function _handleRequest(json) {
        var _this2 = this;
        var method = json.method,
          params = json.params,
          id = json.id;
        var rawResult = this.didReceiveCall(method, params);
        if (id !== null && typeof id !== 'undefined') {
          Promise.resolve(rawResult).then(function (result) {
            _this2._sendResponse(id, result);
          }, function (error) {
            _this2._sendResponse(id, null, error);
          });
        }
      }
    }]);
  }();
  jsonrpc = JSONRPC;
  return jsonrpc;
}

function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
var ble;
var hasRequiredBle;
function requireBle() {
  if (hasRequiredBle) return ble;
  hasRequiredBle = 1;
  var JSONRPC = requireJsonrpc();
  var BLE = /*#__PURE__*/function (_JSONRPC) {
    /**
     * A BLE peripheral socket object.  It handles connecting, over web sockets, to
     * BLE peripherals, and reading and writing data to them.
     * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
     * @param {string} extensionId - the id of the extension using this socket.
     * @param {object} peripheralOptions - the list of options for peripheral discovery.
     * @param {object} connectCallback - a callback for connection.
     * @param {object} resetCallback - a callback for resetting extension state.
     */
    function BLE(runtime, extensionId, peripheralOptions, connectCallback) {
      var _this;
      var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      _classCallCheck(this, BLE);
      _this = _callSuper$2(this, BLE);
      _this._socket = runtime.getScratchLinkSocket('BLE');
      _this._socket.setOnOpen(_this.requestPeripheral.bind(_this));
      _this._socket.setOnClose(_this.handleDisconnectError.bind(_this));
      _this._socket.setOnError(_this._handleRequestError.bind(_this));
      _this._socket.setHandleMessage(_this._handleMessage.bind(_this));
      _this._sendMessage = _this._socket.sendMessage.bind(_this._socket);
      _this._availablePeripherals = {};
      _this._connectCallback = connectCallback;
      _this._connected = false;
      _this._characteristicDidChangeCallback = null;
      _this._resetCallback = resetCallback;
      _this._discoverTimeoutID = null;
      _this._extensionId = extensionId;
      _this._peripheralOptions = peripheralOptions;
      _this._runtime = runtime;
      _this._socket.open();
      return _this;
    }

    /**
     * Request connection to the peripheral.
     * If the web socket is not yet open, request when the socket promise resolves.
     */
    _inherits(BLE, _JSONRPC);
    return _createClass(BLE, [{
      key: "requestPeripheral",
      value: function requestPeripheral() {
        var _this2 = this;
        this._availablePeripherals = {};
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
        this.sendRemoteRequest('discover', this._peripheralOptions).catch(function (e) {
          _this2._handleRequestError(e);
        });
      }

      /**
       * Try connecting to the input peripheral id, and then call the connect
       * callback if connection is successful.
       * @param {number} id - the id of the peripheral to connect to
       */
    }, {
      key: "connectPeripheral",
      value: function connectPeripheral(id) {
        var _this3 = this;
        this.sendRemoteRequest('connect', {
          peripheralId: id
        }).then(function () {
          _this3._connected = true;
          _this3._runtime.emit(_this3._runtime.constructor.PERIPHERAL_CONNECTED);
          _this3._connectCallback();
        }).catch(function (e) {
          _this3._handleRequestError(e);
        });
      }

      /**
       * Close the websocket.
       */
    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this._connected) {
          this._connected = false;
        }
        if (this._socket.isOpen()) {
          this._socket.close();
        }
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        // Sets connection status icon to orange
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
      }

      /**
       * @return {bool} whether the peripheral is connected.
       */
    }, {
      key: "isConnected",
      value: function isConnected() {
        return this._connected;
      }

      /**
       * Start receiving notifications from the specified ble service.
       * @param {number} serviceId - the ble service to read.
       * @param {number} characteristicId - the ble characteristic to get notifications from.
       * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
       * @return {Promise} - a promise from the remote startNotifications request.
       */
    }, {
      key: "startNotifications",
      value: function startNotifications(serviceId, characteristicId) {
        var _this4 = this;
        var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var params = {
          serviceId: serviceId,
          characteristicId: characteristicId
        };
        this._characteristicDidChangeCallback = onCharacteristicChanged;
        return this.sendRemoteRequest('startNotifications', params).catch(function (e) {
          _this4.handleDisconnectError(e);
        });
      }

      /**
       * Read from the specified ble service.
       * @param {number} serviceId - the ble service to read.
       * @param {number} characteristicId - the ble characteristic to read.
       * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
       * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
       * @return {Promise} - a promise from the remote read request.
       */
    }, {
      key: "read",
      value: function read(serviceId, characteristicId) {
        var _this5 = this;
        var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var params = {
          serviceId: serviceId,
          characteristicId: characteristicId
        };
        if (optStartNotifications) {
          params.startNotifications = true;
        }
        if (onCharacteristicChanged) {
          this._characteristicDidChangeCallback = onCharacteristicChanged;
        }
        return this.sendRemoteRequest('read', params).catch(function (e) {
          _this5.handleDisconnectError(e);
        });
      }

      /**
       * Write data to the specified ble service.
       * @param {number} serviceId - the ble service to write.
       * @param {number} characteristicId - the ble characteristic to write.
       * @param {string} message - the message to send.
       * @param {string} encoding - the message encoding type.
       * @param {boolean} withResponse - if true, resolve after peripheral's response.
       * @return {Promise} - a promise from the remote send request.
       */
    }, {
      key: "write",
      value: function write(serviceId, characteristicId, message) {
        var _this6 = this;
        var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var params = {
          serviceId: serviceId,
          characteristicId: characteristicId,
          message: message
        };
        if (encoding) {
          params.encoding = encoding;
        }
        if (withResponse !== null) {
          params.withResponse = withResponse;
        }
        return this.sendRemoteRequest('write', params).catch(function (e) {
          _this6.handleDisconnectError(e);
        });
      }

      /**
       * Handle a received call from the socket.
       * @param {string} method - a received method label.
       * @param {object} params - a received list of parameters.
       * @return {object} - optional return value.
       */
    }, {
      key: "didReceiveCall",
      value: function didReceiveCall(method, params) {
        switch (method) {
          case 'didDiscoverPeripheral':
            this._availablePeripherals[params.peripheralId] = params;
            this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);
            if (this._discoverTimeoutID) {
              window.clearTimeout(this._discoverTimeoutID);
            }
            break;
          case 'userDidPickPeripheral':
            this._availablePeripherals[params.peripheralId] = params;
            this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);
            if (this._discoverTimeoutID) {
              window.clearTimeout(this._discoverTimeoutID);
            }
            break;
          case 'userDidNotPickPeripheral':
            this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
            if (this._discoverTimeoutID) {
              window.clearTimeout(this._discoverTimeoutID);
            }
            break;
          case 'characteristicDidChange':
            if (this._characteristicDidChangeCallback) {
              this._characteristicDidChangeCallback(params.message);
            }
            break;
          case 'ping':
            return 42;
        }
      }

      /**
       * Handle an error resulting from losing connection to a peripheral.
       *
       * This could be due to:
       * - battery depletion
       * - going out of bluetooth range
       * - being powered down
       *
       * Disconnect the socket, and if the extension using this socket has a
       * reset callback, call it. Finally, emit an error to the runtime.
       */
    }, {
      key: "handleDisconnectError",
      value: function handleDisconnectError(/* e */
      ) {
        // log.error(`BLE error: ${JSON.stringify(e)}`);

        if (!this._connected) return;
        this.disconnect();
        if (this._resetCallback) {
          this._resetCallback();
        }
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
          message: "Scratch lost connection to",
          extensionId: this._extensionId
        });
      }
    }, {
      key: "_handleRequestError",
      value: function _handleRequestError(/* e */
      ) {
        // log.error(`BLE error: ${JSON.stringify(e)}`);

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
          message: "Scratch lost connection to",
          extensionId: this._extensionId
        });
      }
    }, {
      key: "_handleDiscoverTimeout",
      value: function _handleDiscoverTimeout() {
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
      }
    }]);
  }(JSONRPC);
  ble = BLE;
  return ble;
}

var global$2 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var global$1 = typeof global$2 !== "undefined" ? global$2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }
  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;
var isArray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) ;
}
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}
Buffer.isBuffer = isBuffer;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }
  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}
function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var browserAtob = {exports: {}};

browserAtob.exports;
var hasRequiredBrowserAtob;
function requireBrowserAtob() {
  if (hasRequiredBrowserAtob) return browserAtob.exports;
  hasRequiredBrowserAtob = 1;
  (function (module) {
    (function (w) {

      function findBest(atobNative) {
        // normal window
        if ('function' === typeof atobNative) {
          return atobNative;
        }

        // browserify (web worker)
        if ('function' === typeof Buffer) {
          return function atobBrowserify(a) {
            //!! Deliberately using an API that's deprecated in node.js because
            //!! this file is for browsers and we expect them to cope with it.
            //!! Discussion: github.com/node-browser-compat/atob/pull/9
            return new Buffer(a, 'base64').toString('binary');
          };
        }

        // ios web worker with base64js
        if ('object' === _typeof(w.base64js)) {
          // bufferToBinaryString
          // https://git.coolaj86.com/coolaj86/unibabel.js/blob/master/index.js#L50
          return function atobWebWorker_iOS(a) {
            var buf = w.base64js.b64ToByteArray(a);
            return Array.prototype.map.call(buf, function (ch) {
              return String.fromCharCode(ch);
            }).join('');
          };
        }
        return function () {
          // ios web worker without base64js
          throw new Error("You're probably in an old browser or an iOS webworker." + " It might help to include beatgammit's base64-js.");
        };
      }
      var atobBest = findBest(w.atob);
      w.atob = atobBest;
      if (module && module.exports) {
        module.exports = atobBest;
      }
    })(window);
  })(browserAtob);
  return browserAtob.exports;
}

var btoa = {exports: {}};

var hasRequiredBtoa;
function requireBtoa() {
  if (hasRequiredBtoa) return btoa.exports;
  hasRequiredBtoa = 1;
  (function () {

    function btoa$1(str) {
      var buffer;
      if (str instanceof Buffer) {
        buffer = str;
      } else {
        buffer = Buffer.from(str.toString(), 'binary');
      }
      return buffer.toString('base64');
    }
    btoa.exports = btoa$1;
  })();
  return btoa.exports;
}

var base64Util;
var hasRequiredBase64Util;
function requireBase64Util() {
  if (hasRequiredBase64Util) return base64Util;
  hasRequiredBase64Util = 1;
  var atob = requireBrowserAtob();
  var btoa = requireBtoa();
  var Base64Util = /*#__PURE__*/function () {
    function Base64Util() {
      _classCallCheck(this, Base64Util);
    }
    return _createClass(Base64Util, null, [{
      key: "base64ToUint8Array",
      value:
      /**
       * Convert a base64 encoded string to a Uint8Array.
       * @param {string} base64 - a base64 encoded string.
       * @return {Uint8Array} - a decoded Uint8Array.
       */
      function base64ToUint8Array(base64) {
        var binaryString = atob(base64);
        var len = binaryString.length;
        var array = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          array[i] = binaryString.charCodeAt(i);
        }
        return array;
      }

      /**
       * Convert a Uint8Array to a base64 encoded string.
       * @param {Uint8Array} array - the array to convert.
       * @return {string} - the base64 encoded string.
       */
    }, {
      key: "uint8ArrayToBase64",
      value: function uint8ArrayToBase64(array) {
        var base64 = btoa(String.fromCharCode.apply(null, array));
        return base64;
      }

      /**
      * Convert an array buffer to a base64 encoded string.
      * @param {array} buffer - an array buffer to convert.
      * @return {string} - the base64 encoded string.
      */
    }, {
      key: "arrayBufferToBase64",
      value: function arrayBufferToBase64(buffer) {
        var binary = '';
        var bytes = new Uint8Array(buffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }
    }]);
  }();
  base64Util = Base64Util;
  return base64Util;
}

var mathUtil;
var hasRequiredMathUtil;
function requireMathUtil() {
  if (hasRequiredMathUtil) return mathUtil;
  hasRequiredMathUtil = 1;
  var MathUtil = /*#__PURE__*/function () {
    function MathUtil() {
      _classCallCheck(this, MathUtil);
    }
    return _createClass(MathUtil, null, [{
      key: "degToRad",
      value:
      /**
       * Convert a value from degrees to radians.
       * @param {!number} deg Value in degrees.
       * @return {!number} Equivalent value in radians.
       */
      function degToRad(deg) {
        return deg * Math.PI / 180;
      }

      /**
       * Convert a value from radians to degrees.
       * @param {!number} rad Value in radians.
       * @return {!number} Equivalent value in degrees.
       */
    }, {
      key: "radToDeg",
      value: function radToDeg(rad) {
        return rad * 180 / Math.PI;
      }

      /**
       * Clamp a number between two limits.
       * If n < min, return min. If n > max, return max. Else, return n.
       * @param {!number} n Number to clamp.
       * @param {!number} min Minimum limit.
       * @param {!number} max Maximum limit.
       * @return {!number} Value of n clamped to min and max.
       */
    }, {
      key: "clamp",
      value: function clamp(n, min, max) {
        return Math.min(Math.max(n, min), max);
      }

      /**
       * Keep a number between two limits, wrapping "extra" into the range.
       * e.g., wrapClamp(7, 1, 5) == 2
       * wrapClamp(0, 1, 5) == 5
       * wrapClamp(-11, -10, 6) == 6, etc.
       * @param {!number} n Number to wrap.
       * @param {!number} min Minimum limit.
       * @param {!number} max Maximum limit.
       * @return {!number} Value of n wrapped between min and max.
       */
    }, {
      key: "wrapClamp",
      value: function wrapClamp(n, min, max) {
        var range = max - min + 1;
        return n - Math.floor((n - min) / range) * range;
      }

      /**
       * Convert a value from tan function in degrees.
       * @param {!number} angle in degrees
       * @return {!number} Correct tan value
       */
    }, {
      key: "tan",
      value: function tan(angle) {
        angle = angle % 360;
        switch (angle) {
          case -270:
          case 90:
            return Infinity;
          case -90:
          case 270:
            return -Infinity;
          default:
            return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));
        }
      }

      /**
       * Given an array of unique numbers,
       * returns a reduced array such that each element of the reduced array
       * represents the position of that element in a sorted version of the
       * original array.
       * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]
       * @param {Array<number>} elts The elements to sort and reduce
       * @return {Array<number>} The array of reduced orderings
       */
    }, {
      key: "reducedSortOrdering",
      value: function reducedSortOrdering(elts) {
        var sorted = elts.slice(0).sort(function (a, b) {
          return a - b;
        });
        return elts.map(function (e) {
          return sorted.indexOf(e);
        });
      }

      /**
       * Return a random number given an inclusive range and a number in that
       * range that should be excluded.
       *
       * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal
       * probability)
       *
       * @param {number} lower - The lower bound (inlcusive)
       * @param {number} upper - The upper bound (inclusive), such that lower <= upper
       * @param {number} excluded - The number to exclude (MUST be in the range)
       * @return {number} A random integer in the range [lower, upper] that is not "excluded"
       */
    }, {
      key: "inclusiveRandIntWithout",
      value: function inclusiveRandIntWithout(lower, upper, excluded) {
        // Note that subtraction is the number of items in the
        // inclusive range [lower, upper] minus 1 already
        // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).
        var possibleOptions = upper - lower;
        var randInt = lower + Math.floor(Math.random() * possibleOptions);
        if (randInt >= excluded) {
          return randInt + 1;
        }
        return randInt;
      }

      /**
       * Scales a number from one range to another.
       * @param {number} i number to be scaled
       * @param {number} iMin input range minimum
       * @param {number} iMax input range maximum
       * @param {number} oMin output range minimum
       * @param {number} oMax output range maximum
       * @return {number} scaled number
       */
    }, {
      key: "scale",
      value: function scale(i, iMin, iMax, oMin, oMax) {
        var p = (i - iMin) / (iMax - iMin);
        return p * (oMax - oMin) + oMin;
      }
    }]);
  }();
  mathUtil = MathUtil;
  return mathUtil;
}

var timer;
var hasRequiredTimer;
function requireTimer() {
  if (hasRequiredTimer) return timer;
  hasRequiredTimer = 1;
  var Timer = /*#__PURE__*/function () {
    function Timer() {
      var nowObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Timer.nowObj;
      _classCallCheck(this, Timer);
      /**
       * Used to store the start time of a timer action.
       * Updated when calling `timer.start`.
       */
      this.startTime = 0;

      /**
       * Used to pass custom logic for determining the value for "now",
       * which is sometimes useful for compatibility with Scratch 2
       */
      this.nowObj = nowObj;
    }

    /**
     * Disable use of self.performance for now as it results in lower performance
     * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
     * @type {boolean}
     */
    return _createClass(Timer, [{
      key: "time",
      value:
      /**
       * Return the currently known absolute time, in ms precision.
       * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
       */
      function time() {
        return this.nowObj.now();
      }

      /**
       * Start a timer for measuring elapsed time,
       * at the most accurate precision possible.
       */
    }, {
      key: "start",
      value: function start() {
        this.startTime = this.nowObj.now();
      }
    }, {
      key: "timeElapsed",
      value: function timeElapsed() {
        return this.nowObj.now() - this.startTime;
      }

      /**
       * Call a handler function after a specified amount of time has elapsed.
       * @param {function} handler - function to call after the timeout
       * @param {number} timeout - number of milliseconds to delay before calling the handler
       * @returns {number} - the ID of the new timeout
       */
    }, {
      key: "setTimeout",
      value: function setTimeout(handler, timeout) {
        return commonjsGlobal.setTimeout(handler, timeout);
      }

      /**
       * Clear a timeout from the pending timeout pool.
       * @param {number} timeoutId - the ID returned by `setTimeout()`
       * @memberof Timer
       */
    }, {
      key: "clearTimeout",
      value: function clearTimeout(timeoutId) {
        commonjsGlobal.clearTimeout(timeoutId);
      }
    }], [{
      key: "USE_PERFORMANCE",
      get: function get() {
        return false;
      }

      /**
       * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
       * @deprecated This is only called via the nowObj.now() if no other means is possible...
       */
    }, {
      key: "legacyDateCode",
      get: function get() {
        return {
          now: function now() {
            return new Date().getTime();
          }
        };
      }

      /**
       * Use this object to route all time functions through single access points.
       */
    }, {
      key: "nowObj",
      get: function get() {
        if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {
          return self.performance;
        } else if (Date.now) {
          return Date;
        }
        return Timer.legacyDateCode;
      }
    }]);
  }();
  timer = Timer;
  return timer;
}

var rateLimiter;
var hasRequiredRateLimiter;
function requireRateLimiter() {
  if (hasRequiredRateLimiter) return rateLimiter;
  hasRequiredRateLimiter = 1;
  var Timer = requireTimer();
  var RateLimiter = /*#__PURE__*/function () {
    /**
     * A utility for limiting the rate of repetitive send operations, such as
     * bluetooth messages being sent to hardware devices. It uses the token bucket
     * strategy: a counter accumulates tokens at a steady rate, and each send costs
     * a token. If no tokens remain, it's not okay to send.
     * @param {number} maxRate the maximum number of sends allowed per second
     * @constructor
     */
    function RateLimiter(maxRate) {
      _classCallCheck(this, RateLimiter);
      /**
       * The maximum number of tokens.
       * @type {number}
       */
      this._maxTokens = maxRate;

      /**
       * The interval in milliseconds for refilling one token. It is calculated
       * so that the tokens will be filled to maximum in one second.
       * @type {number}
       */
      this._refillInterval = 1000 / maxRate;

      /**
       * The current number of tokens in the bucket.
       * @type {number}
       */
      this._count = this._maxTokens;
      this._timer = new Timer();
      this._timer.start();

      /**
       * The last time in milliseconds when the token count was updated.
       * @type {number}
       */
      this._lastUpdateTime = this._timer.timeElapsed();
    }

    /**
     * Check if it is okay to send a message, by updating the token count,
     * taking a token and then checking if we are still under the rate limit.
     * @return {boolean} true if we are under the rate limit
     */
    return _createClass(RateLimiter, [{
      key: "okayToSend",
      value: function okayToSend() {
        // Calculate the number of tokens to refill the bucket with, based on the
        // amount of time since the last refill.
        var now = this._timer.timeElapsed();
        var timeSinceRefill = now - this._lastUpdateTime;
        var refillCount = Math.floor(timeSinceRefill / this._refillInterval);

        // If we're adding at least one token, reset _lastUpdateTime to now.
        // Otherwise, don't reset it so that we can continue measuring time until
        // the next refill.
        if (refillCount > 0) {
          this._lastUpdateTime = now;
        }

        // Refill the tokens up to the maximum
        this._count = Math.min(this._maxTokens, this._count + refillCount);

        // If we have at least one token, use one, and it's okay to send.
        if (this._count > 0) {
          this._count--;
          return true;
        }
        return false;
      }
    }]);
  }();
  rateLimiter = RateLimiter;
  return rateLimiter;
}

var ioType;
var hasRequiredIoType;
function requireIoType() {
  if (hasRequiredIoType) return ioType;
  hasRequiredIoType = 1;
  var IOType = {
    SIMPLE_MEDIUM_LINEAR_MOTOR: 0x01,
    TRAIN_MOTOR: 0x02,
    BUTTION: 0x05,
    LIGHT: 0x08,
    VOLTAGE: 0x14,
    CURRENT: 0x15,
    PIEZO_TONE: 0x16,
    RGB_LIGHT: 0x17,
    TILT_SENSOR: 0x22,
    MOTION_SENSOR: 0x23,
    COLOR_DISTANCE_SENSOR: 0x25,
    MEDIUM_LINEAR_MOTOR: 0x26,
    MOVE_HUB_MOTOR: 0x27,
    MOVE_HUB_TILT_SENSOR: 0x28,
    DUPLO_TRAIN_BASE_MOTOR: 0x29,
    DUPLO_TRAIN_BASE_SPEAKER: 0x2a,
    DUPLO_TRAIN_BASE_COLOR_SENSOR: 0x2b,
    DUPLO_TRAIN_BASE_SPEEDOMETER: 0x2c,
    TECHNIC_LARGE_MOTOR: 0x2e,
    TECHNIC_XL_MOTOR: 0x2f,
    TECHNIC_MEDIUM_ANGULAR_MOTOR: 0x30,
    TECHNIC_LARGE_ANGULAR_MOTOR: 0x31,
    REMOTE_POWER_CONTROL_BUTTON: 0x37,
    TECHNIC_HUB_TILT_SENSOR: 0x3b,
    TECHNIC_COLOR_SENSOR: 0x3d,
    TECHNIC_DISTANCE_SENSOR: 0x3e,
    TECHNIC_FORCE_SENSOR: 0x3f,
    TECHNIC_SMALL_ANGULAR_MOTOR: 0x41,
    MARIO_COLOR_BARCODE_SENSOR: 0x49,
    MARIO_PANTS: 0x4a,
    TECHNIC_MEDIUM_ANGULAR_MOTOR_GRAY: 0x4b,
    TECHNIC_LARGE_ANGULAR_MOTOR_GRAY: 0x4c
  };
  ioType = IOType;
  return ioType;
}

var device = {};

function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
var hasRequiredDevice;
function requireDevice() {
  if (hasRequiredDevice) return device;
  hasRequiredDevice = 1;
  var MathUtil = requireMathUtil();
  var IOType = requireIoType();
  var GenericDevice = /*#__PURE__*/function () {
    function GenericDevice(ioType) {
      _classCallCheck(this, GenericDevice);
      this._ioType = ioType;
      this._inputValues = {};
    }
    return _createClass(GenericDevice, [{
      key: "ioType",
      get: function get() {
        return this._ioType;
      }
    }, {
      key: "mode",
      get: function get() {
        switch (this._ioType) {
          case IOType.MEDIUM_LINEAR_MOTOR:
          case IOType.MOVE_HUB_MOTOR:
          case IOType.TECHNIC_LARGE_MOTOR:
          case IOType.TECHNIC_XL_MOTOR:
          case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR:
          case IOType.TECHNIC_LARGE_ANGULAR_MOTOR:
          case IOType.TECHNIC_SMALL_ANGULAR_MOTOR:
          case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR_GRAY:
          case IOType.TECHNIC_LARGE_ANGULAR_MOTOR_GRAY:
            return 2;
          // Relative Position
          case IOType.TILT_SENSOR:
            return 0;
          // Tilt X, Y
          case IOType.MOTION_SENSOR:
            return 0;
          // Distance
          case IOType.COLOR_DISTANCE_SENSOR:
            return 8;
          // Color and Distance
          case IOType.MOVE_HUB_TILT_SENSOR:
            return 0;
          // Tilt X, Y
          case IOType.DUPLO_TRAIN_BASE_SPEAKER:
            return 1;
          // Sound
          case IOType.DUPLO_TRAIN_BASE_COLOR_SENSOR:
            return 1;
          // Color
          case IOType.DUPLO_TRAIN_BASE_SPEEDOMETER:
            return 1;
          // Driving Distance
          case IOType.REMOTE_POWER_CONTROL_BUTTON:
            return 0;
          // Button
          case IOType.TECHNIC_HUB_TILT_SENSOR:
            return 0;
          // Tilt X, Y, Z
          case IOType.TECHNIC_COLOR_SENSOR:
            return 0;
          // Color
          case IOType.TECHNIC_DISTANCE_SENSOR:
            return 0;
          // Distance
          case IOType.TECHNIC_FORCE_SENSOR:
            return 0;
          // Force
          case IOType.MARIO_COLOR_BARCODE_SENSOR:
            return 0;
          case IOType.MARIO_PANTS:
            return 0;
          default:
            return null;
        }
      }
    }, {
      key: "inputValues",
      get: function get() {
        return this._inputValues;
      }
    }, {
      key: "updateInputValues",
      value: function updateInputValues(data) {
        var _this = this;
        if (data.length == 0) {
          this._inputValues = {};
          return;
        }
        var buffer = Buffer.from(data);
        switch (this._ioType) {
          case IOType.MEDIUM_LINEAR_MOTOR:
          case IOType.MOVE_HUB_MOTOR:
          case IOType.TECHNIC_LARGE_MOTOR:
          case IOType.TECHNIC_XL_MOTOR:
          case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR:
          case IOType.TECHNIC_LARGE_ANGULAR_MOTOR:
          case IOType.TECHNIC_SMALL_ANGULAR_MOTOR:
          case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR_GRAY:
          case IOType.TECHNIC_LARGE_ANGULAR_MOTOR_GRAY:
            this._inputValues = {
              relativePosition: buffer.readInt32LE(0)
            };
            break;
          case IOType.TILT_SENSOR:
            this._inputValues = {
              tiltX: buffer.readInt8(0),
              tiltY: buffer.readInt8(1)
            };
            break;
          case IOType.MOTION_SENSOR:
            this._inputValues = {
              distance: buffer.readInt8(0)
            };
            break;
          case IOType.COLOR_DISTANCE_SENSOR:
            this._inputValues = {
              color: buffer.readInt8(0),
              distance: buffer.readInt8(1)
            };
            break;
          case IOType.MOVE_HUB_TILT_SENSOR:
            this._inputValues = {
              tiltX: buffer.readInt8(0),
              tiltY: buffer.readInt8(1)
            };
            break;
          case IOType.DUPLO_TRAIN_BASE_COLOR_SENSOR:
            var value = buffer.readInt8(0);
            if (value > -1) {
              this._inputValues = {
                color: value
              };
              setTimeout(function () {
                _this._inputValues = {
                  color: -1
                };
              }, 100);
            }
            break;
          case IOType.DUPLO_TRAIN_BASE_SPEEDOMETER:
            this._inputValues = {
              drivingDistance: buffer.readInt32LE(0)
            };
            break;
          case IOType.REMOTE_POWER_CONTROL_BUTTON:
            this._inputValues = {
              button: buffer.readInt8(0)
            };
            break;
          case IOType.TECHNIC_HUB_TILT_SENSOR:
            this._inputValues = {
              tiltX: buffer.readInt16LE(4),
              tiltY: buffer.readInt16LE(2),
              tiltZ: buffer.readInt16LE(0)
            };
            break;
          case IOType.TECHNIC_COLOR_SENSOR:
            this._inputValues = {
              color: buffer.readInt8(0)
            };
            break;
          case IOType.TECHNIC_DISTANCE_SENSOR:
            this._inputValues = {
              distance: buffer.readInt16LE(0)
            };
            break;
          case IOType.TECHNIC_FORCE_SENSOR:
            this._inputValues = {
              force: buffer.readInt8(0)
            };
            break;
          case IOType.MARIO_COLOR_BARCODE_SENSOR:
            this._inputValues = {
              barcode: buffer.readInt16LE(0),
              color: buffer.readInt16LE(2)
            };
            break;
          case IOType.MARIO_PANTS:
            this._inputValues = {
              pants: buffer.readInt8(0)
            };
            break;
          default:
            this._inputValues = {};
            break;
        }
        this._inputValues.bytes = buffer;
      }
    }]);
  }();
  var Motor = /*#__PURE__*/function (_GenericDevice) {
    function Motor(ioType) {
      var _this2;
      _classCallCheck(this, Motor);
      _this2 = _callSuper$1(this, Motor, [ioType]);
      switch (ioType) {
        case IOType.MEDIUM_LINEAR_MOTOR:
        case IOType.MOVE_HUB_MOTOR:
          _this2._canUseSpeed = true;
          _this2._canUsePosition = false;
          _this2._speed = 75;
          break;
        case IOType.TECHNIC_LARGE_MOTOR:
        case IOType.TECHNIC_XL_MOTOR:
        case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR:
        case IOType.TECHNIC_LARGE_ANGULAR_MOTOR:
        case IOType.TECHNIC_SMALL_ANGULAR_MOTOR:
        case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR_GRAY:
        case IOType.TECHNIC_LARGE_ANGULAR_MOTOR_GRAY:
          _this2._canUseSpeed = true;
          _this2._canUsePosition = true;
          _this2._speed = 75;
          break;
        default:
          _this2._canUseSpeed = false;
          _this2._canUsePosition = false;
          _this2._speed = 0;
      }
      return _this2;
    }
    _inherits(Motor, _GenericDevice);
    return _createClass(Motor, [{
      key: "canUseSpeed",
      get: function get() {
        return this._canUseSpeed;
      }
    }, {
      key: "canUsePosition",
      get: function get() {
        return this._canUsePosition;
      }
    }, {
      key: "speed",
      get: function get() {
        return this._speed;
      },
      set: function set(value) {
        if (this._canUseSpeed) {
          this._speed = MathUtil.clamp(value, -100, 100);
        }
      }
    }]);
  }(GenericDevice);
  var createDevice = function createDevice(ioType) {
    switch (ioType) {
      case IOType.SIMPLE_MEDIUM_LINEAR_MOTOR:
      case IOType.TRAIN_MOTOR:
      case IOType.LIGHT:
      case IOType.MEDIUM_LINEAR_MOTOR:
      case IOType.MOVE_HUB_MOTOR:
      case IOType.DUPLO_TRAIN_BASE_MOTOR:
      case IOType.TECHNIC_LARGE_MOTOR:
      case IOType.TECHNIC_XL_MOTOR:
      case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR:
      case IOType.TECHNIC_LARGE_ANGULAR_MOTOR:
      case IOType.TECHNIC_SMALL_ANGULAR_MOTOR:
      case IOType.TECHNIC_MEDIUM_ANGULAR_MOTOR_GRAY:
      case IOType.TECHNIC_LARGE_ANGULAR_MOTOR_GRAY:
        return new Motor(ioType);
      default:
        return new GenericDevice(ioType);
    }
  };
  device.GenericDevice = GenericDevice;
  device.Motor = Motor;
  device.createDevice = createDevice;
  return device;
}

var hub;
var hasRequiredHub;
function requireHub() {
  if (hasRequiredHub) return hub;
  hasRequiredHub = 1;
  var BLE = requireBle();
  var Base64Util = requireBase64Util();
  var MathUtil = requireMathUtil();
  var RateLimiter = requireRateLimiter();

  //const log = require('../../../util/log');

  var IOType = requireIoType();
  var Device = requireDevice();
  var _TextDecoder;
  if (typeof TextDecoder === 'undefined') {
    _TextDecoder = null;
  } else {
    _TextDecoder = TextDecoder;
  }
  var ServiceUUID = '00001623-1212-efde-1623-785feabcd123';
  var CharacteristicUUID = '00001624-1212-efde-1623-785feabcd123';
  var SendRateMax = 20;
  var PollingInterval = 3000;
  var MAX_INT32 = Math.pow(2, 31) - 1;
  var MIN_INT32 = Math.pow(2, 31) * -1;
  var MAX_INT16 = Math.pow(2, 15) - 1;
  var MessageType = {
    HUB_PROPERTIES: 0x01,
    HUB_ATTACHED_IO: 0x04,
    GENERIC_ERROR_MESSAGES: 0x05,
    PORT_INPUT_FORMAT_SETUP: 0x41,
    PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,
    PORT_VALUE: 0x45,
    PORT_VALUE_COMBINED: 0x46,
    PORT_OUTPUT_COMMAND: 0x81,
    PORT_OUTPUT_COMMAND_FEEDBACK: 0x82
  };
  var HubPropertyReference = {
    ADVERTISING_NAME: 0x01,
    BUTTON: 0x02,
    FW_VERSION: 0x03,
    BATTERY_VOLTAGE: 0x06,
    SPEAKER_VOLUME: 0x12
  };
  var HubPropertyOperation = {
    SET: 0x01,
    ENABLE_UPDATES: 0x02,
    DISABLE_UPDATES: 0x03,
    RESET: 0x04,
    REQUEST_UPDATE: 0x05,
    UPDATE: 0x06
  };
  var numberToInt32Array = function numberToInt32Array(number) {
    var buffer = new ArrayBuffer(4);
    var dataview = new DataView(buffer);
    dataview.setInt32(0, number);
    return [dataview.getUint8(3), dataview.getUint8(2), dataview.getUint8(1), dataview.getUint8(0)];
  };
  var numberToInt16Array = function numberToInt16Array(number) {
    var buffer = new ArrayBuffer(2);
    var dataview = new DataView(buffer);
    dataview.setInt16(0, number);
    return [dataview.getUint8(1), dataview.getUint8(0)];
  };
  var Hub = /*#__PURE__*/function () {
    function Hub(runtime, extensionId) {
      var hubType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      _classCallCheck(this, Hub);
      this._runtime = runtime;
      this._extensionId = extensionId;
      this._hubType = hubType;
      this._name = null;
      this._firmwareVersion = null;
      this._batteryLevel = 0;
      this._devices = [];
      this._firstNotificationCallback = null;
      this._outputCommandFeedbackCallbacks = [];
      this._outputCommandCompletionCallbacks = [];
      this._ble = null;
      this._runtime.registerPeripheralExtension(extensionId, this);
      this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
      this._rateLimiter = new RateLimiter(SendRateMax);
      this._pollingId = null;
      this.reset = this.reset.bind(this);
      this._onConnect = this._onConnect.bind(this);
      this._onMessage = this._onMessage.bind(this);
    }
    return _createClass(Hub, [{
      key: "name",
      get: function get() {
        return this._name;
      }
    }, {
      key: "firmwareVersion",
      get: function get() {
        return this._firmwareVersion;
      }
    }, {
      key: "batteryLevel",
      get: function get() {
        return this._batteryLevel;
      }

      // BLE
    }, {
      key: "scan",
      value: function scan() {
        if (this._ble) {
          this._ble.disconnect();
        }
        var hubTypeFilter = {
          dataPrefix: []
        };
        if (this._hubType) {
          hubTypeFilter = {
            dataPrefix: [0x00, this._hubType],
            mask: [0x00, 0xff]
          };
        }
        this._ble = new BLE(this._runtime, this._extensionId, {
          filters: [{
            services: [ServiceUUID],
            manufacturerData: {
              0x0397: hubTypeFilter
            }
          }],
          optionalServices: []
        }, this._onConnect, this.reset);
      }
    }, {
      key: "connect",
      value: function connect(id) {
        if (this._ble) {
          this._ble.connectPeripheral(id);
        }
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this._ble) {
          this._ble.disconnect();
        }
        this.reset();
      }
    }, {
      key: "isConnected",
      value: function isConnected() {
        var connected = false;
        if (this._ble) {
          connected = this._ble.isConnected();
        }
        return connected;
      }
    }, {
      key: "_onConnect",
      value: function _onConnect() {
        var _this = this;
        this._ble.startNotifications(ServiceUUID, CharacteristicUUID, this._onMessage);
        this._firstNotificationCallback = function () {
          _this.sendMessage(MessageType.HUB_PROPERTIES, [HubPropertyReference.ADVERTISING_NAME, HubPropertyOperation.ENABLE_UPDATES], false);
          _this.sendMessage(MessageType.HUB_PROPERTIES, [HubPropertyReference.FW_VERSION, HubPropertyOperation.REQUEST_UPDATE]);
        };
        this._startPollingBatteryLevel();
      }
    }, {
      key: "_onMessage",
      value: function _onMessage(base64) {
        var data = Base64Util.base64ToUint8Array(base64);
        //logByteArray('<<', data);

        var length = data[0];
        if (length > 127) {
          //log.warn(`Unsupported message length: ${length}`);
          return;
        }
        var messageType = data[2];
        switch (messageType) {
          case MessageType.HUB_PROPERTIES:
            {
              var property = data[3];
              switch (property) {
                case HubPropertyReference.ADVERTISING_NAME:
                  if (_TextDecoder) {
                    var uint8Array = new Uint8Array(data.slice(5));
                    this._name = new _TextDecoder().decode(uint8Array);
                  } else {
                    this._name = 'unsupported';
                  }
                  break;
                case HubPropertyReference.FW_VERSION:
                  var value = data.slice(5);
                  if (value.length == 4) {
                    var s = value.reduce(function (output, elem) {
                      return ('0' + (elem & 0xff).toString(16)).slice(-2) + output;
                    }, '');
                    this._firmwareVersion = s.slice(0, 1) + '.' + s.slice(1, 2) + '.' + s.slice(2, 4) + '.' + s.slice(4);
                  }
                  break;
                case HubPropertyReference.BATTERY_VOLTAGE:
                  this._batteryLevel = data[5];
                  break;
              }
              break;
            }
          case MessageType.HUB_ATTACHED_IO:
            {
              var portId = data[3];
              var event = data[4];
              var ioType = data[5];
              switch (event) {
                case 0x00:
                  // Detached I/O
                  this._dettachDevice(portId);
                  break;
                case 0x01:
                  // Attached I/O
                  this._attachDevice(portId, ioType);
                  break;
              }
              break;
            }
          case MessageType.PORT_VALUE:
            {
              var _portId = data[3];
              var device = this._devices[_portId];
              if (device) {
                device.updateInputValues(data.slice(4));
                //log.debug(portId, device.inputValues);
              }
              break;
            }
          case MessageType.PORT_OUTPUT_COMMAND_FEEDBACK:
            {
              var _portId2 = data[3];
              var feedback = data[4];
              var discarded = feedback & 0x04;
              var completed = feedback & 0x02;
              var inProgress = feedback & 0x01;
              if (discarded) {
                this._clearOutputCommandCompletionCallback(_portId2);
              }
              if (completed) {
                this._clearOutputCommandFeedbackCallback(_portId2);
                this._clearOutputCommandCompletionCallback(_portId2);
              }
              if (inProgress) {
                this._moveOutputCommandFeedbackCallbackToCompletionCallback(_portId2);
              }
              break;
            }
        }
        if (this._firstNotificationCallback) {
          this._firstNotificationCallback();
          this._firstNotificationCallback = null;
        }
      }
    }, {
      key: "_dettachDevice",
      value: function _dettachDevice(portId) {
        this._devices[portId] = null;
      }
    }, {
      key: "_attachDevice",
      value: function _attachDevice(portId, ioType) {
        var _this2 = this;
        var device = Device.createDevice(ioType);
        this._devices[portId] = device;
        var mode = device.mode;
        if (mode !== null) {
          setTimeout(function () {
            _this2.sendMessage(MessageType.PORT_INPUT_FORMAT_SETUP, [portId, mode, 1, 0, 0, 0, 1], false);
          }, 100);
        }
      }
    }, {
      key: "send",
      value: function send(data) {
        var useLimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!this.isConnected()) {
          return Promise.resolve();
        }
        if (useLimiter) {
          if (!this._rateLimiter.okayToSend()) {
            return Promise.resolve();
          }
        }

        //logByteArray('>>', data);

        return this._ble.write(ServiceUUID, CharacteristicUUID, Base64Util.uint8ArrayToBase64(data), 'base64', true);
      }
    }, {
      key: "sendMessage",
      value: function sendMessage(messageType, payload) {
        var useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var command = [0x00,
        // Hub ID: Always set to 0x00 (zero)
        messageType].concat(_toConsumableArray(payload));
        command.unshift(command.length + 1);
        return this.send(command, useLimiter);
      }
    }, {
      key: "sendOutputCommand",
      value: function sendOutputCommand(portId, subCommand, payload) {
        var needsFeedback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var useLimiter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var flag = needsFeedback ? 0x11 : 0x10;
        return this.sendMessage(MessageType.PORT_OUTPUT_COMMAND, [portId, flag, subCommand].concat(_toConsumableArray(payload)), useLimiter);
      }

      // Reset and Stop
    }, {
      key: "reset",
      value: function reset() {
        this._name = null;
        this._firmwareVersion = null;
        this._batteryLevel = 0;
        this._devices = [];
        this._outputCommandFeedbackCallbacks = [];
        this._outputCommandCompletionCallbacks = [];
        this._stopPollingBatteryLevel();
      }
    }, {
      key: "stopAll",
      value: function stopAll() {
        if (this.isConnected()) {
          this.stopAllMotors();
        }
      }
    }, {
      key: "stopAllMotors",
      value: function stopAllMotors() {
        for (var _i = 0, _Object$entries = Object.entries(this._devices); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            portId = _Object$entries$_i[0],
            device = _Object$entries$_i[1];
          if (device instanceof Device.Motor) {
            this.sendOutputCommand(portId, 0x51, [0x00, 0], false);
            this._outputCommandFeedbackCallbacks[portId] = null;
            this._outputCommandCompletionCallbacks[portId] = null;
          }
        }
      }
    }, {
      key: "_startPollingBatteryLevel",
      value: function _startPollingBatteryLevel() {
        var _this3 = this;
        this.sendMessage(MessageType.HUB_PROPERTIES, [HubPropertyReference.BATTERY_VOLTAGE, HubPropertyOperation.REQUEST_UPDATE]);
        this._pollingId = window.setInterval(function () {
          _this3.sendMessage(MessageType.HUB_PROPERTIES, [HubPropertyReference.BATTERY_VOLTAGE, HubPropertyOperation.REQUEST_UPDATE]);
        }, PollingInterval);
      }
    }, {
      key: "_stopPollingBatteryLevel",
      value: function _stopPollingBatteryLevel() {
        if (this._pollingId) {
          window.clearInterval(this._pollingId);
          this._pollingId = null;
        }
      }

      // Output Command Feedback
    }, {
      key: "_createOutputCommandFeedbackPromise",
      value: function _createOutputCommandFeedbackPromise(portId) {
        var _this4 = this;
        return new Promise(function (resolve) {
          _this4._outputCommandFeedbackCallbacks[portId] = resolve;
        });
      }
    }, {
      key: "_clearOutputCommandFeedbackCallback",
      value: function _clearOutputCommandFeedbackCallback(portId) {
        if (this._outputCommandFeedbackCallbacks[portId]) {
          this._outputCommandFeedbackCallbacks[portId]();
          this._outputCommandFeedbackCallbacks[portId] = null;
        }
      }
    }, {
      key: "_clearOutputCommandCompletionCallback",
      value: function _clearOutputCommandCompletionCallback(portId) {
        if (this._outputCommandCompletionCallbacks[portId]) {
          this._outputCommandCompletionCallbacks[portId]();
          this._outputCommandCompletionCallbacks[portId] = null;
        }
      }
    }, {
      key: "_moveOutputCommandFeedbackCallbackToCompletionCallback",
      value: function _moveOutputCommandFeedbackCallbackToCompletionCallback(portId) {
        this._outputCommandCompletionCallbacks[portId] = this._outputCommandFeedbackCallbacks[portId];
        this._outputCommandFeedbackCallbacks[portId] = null;
      }

      // Motor
    }, {
      key: "getMotor",
      value: function getMotor(portId) {
        var device = this._devices[portId];
        if (device instanceof Device.Motor) {
          return device;
        } else {
          return null;
        }
      }
    }, {
      key: "motorPWM",
      value: function motorPWM(portId, power) {
        power = MathUtil.clamp(power, -100, 100);
        var motor = this.getMotor(portId);
        if (motor) {
          return this.sendOutputCommand(portId, 0x51, [0x00, power]);
        } else {
          return Promise.resolve();
        }
      }
    }, {
      key: "motorRunForDegrees",
      value: function motorRunForDegrees(portId, direction, degrees) {
        direction = direction * Math.sign(degrees);
        degrees = MathUtil.clamp(Math.abs(degrees), 1, MAX_INT32);
        var motor = this.getMotor(portId);
        if (motor && motor.canUseSpeed) {
          var speed = motor.speed * direction;
          return this.sendOutputCommand(portId, 0x0b, [].concat(_toConsumableArray(numberToInt32Array(degrees)), [speed, 100, 0x7f, 0x00])).then(this._createOutputCommandFeedbackPromise.bind(this, portId));
        } else {
          return Promise.resolve();
        }
      }
    }, {
      key: "motorRunTimed",
      value: function motorRunTimed(portId, direction, seconds) {
        var milliseconds = MathUtil.clamp(seconds * 1000, 0, MAX_INT16);
        var motor = this.getMotor(portId);
        if (motor && motor.canUseSpeed) {
          var speed = motor.speed * direction;
          return this.sendOutputCommand(portId, 0x09, [].concat(_toConsumableArray(numberToInt16Array(milliseconds)), [speed, 100, 0x7f, 0x00])).then(this._createOutputCommandFeedbackPromise.bind(this, portId));
        } else {
          return Promise.resolve();
        }
      }
    }, {
      key: "motorStart",
      value: function motorStart(portId, direction) {
        var motor = this.getMotor(portId);
        if (motor && motor.canUseSpeed) {
          var speed = motor.speed * direction;
          return this.sendOutputCommand(portId, 0x07, [speed, 100, 0x00]);
        } else {
          return Promise.resolve();
        }
      }
    }, {
      key: "motorSetSpeed",
      value: function motorSetSpeed(portId, speed) {
        var motor = this.getMotor(portId);
        if (motor && motor.canUseSpeed) {
          motor.speed = speed;
        }
      }
    }, {
      key: "motorResetRelativePosition",
      value: function motorResetRelativePosition(portId, relativePosition) {
        relativePosition = MathUtil.clamp(relativePosition, MIN_INT32, MAX_INT32);
        var motor = this.getMotor(portId);
        if (motor && motor.canUseSpeed) {
          return this.sendOutputCommand(portId, 0x51, [0x02].concat(_toConsumableArray(numberToInt32Array(relativePosition))));
        } else {
          return Promise.resolve();
        }
      }

      // Input Values
    }, {
      key: "inputValue",
      value: function inputValue(portId, key) {
        var device = this._devices[portId];
        if (device && device.inputValues.hasOwnProperty(key)) {
          return device.inputValues[key];
        }
        return null;
      }
    }, {
      key: "internalInputValue",
      value: function internalInputValue(key) {
        for (var _i2 = 0, _Object$entries2 = Object.entries(this._devices); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
            portId = _Object$entries2$_i[0],
            device = _Object$entries2$_i[1];
          if (portId >= 0x32 && device.inputValues.hasOwnProperty(key)) {
            return device.inputValues[key];
          }
        }
        return null;
      }

      // Hub LED
    }, {
      key: "setLEDColor",
      value: function setLEDColor(color) {
        if (color < 0 || color > 10) {
          color = 0;
        }
        var portId = this._devices.findIndex(function (device) {
          return device && device.ioType == IOType.RGB_LIGHT;
        });
        if (portId != -1) {
          return this.sendOutputCommand(portId, 0x51, [0x00, color]);
        } else {
          return Promise.resolve();
        }
      }
    }, {
      key: "setVolume",
      value: function setVolume(volume) {
        volume = MathUtil.clamp(volume, 0, 100);
        return this.sendMessage(MessageType.HUB_PROPERTIES, [HubPropertyReference.SPEAKER_VOLUME, HubPropertyOperation.SET, volume]);
      }
    }]);
  }();
  hub = Hub;
  return hub;
}

var formatMessage = {exports: {}};

var formatMessageParse = {exports: {}};

formatMessageParse.exports;
var hasRequiredFormatMessageParse;
function requireFormatMessageParse() {
  if (hasRequiredFormatMessageParse) return formatMessageParse.exports;
  hasRequiredFormatMessageParse = 1;
  (function (module, exports) {

    /*::
    export type AST = Element[]
    export type Element = string | Placeholder
    export type Placeholder = Plural | Styled | Typed | Simple
    export type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]
    export type Styled = [ string, string, string | SubMessages ]
    export type Typed = [ string, string ]
    export type Simple = [ string ]
    export type SubMessages = { [string]: AST }
    export type Token = [ TokenType, string ]
    export type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'
    type Context = {|
      pattern: string,
      index: number,
      tagsType: ?string,
      tokens: ?Token[]
    |}
    */
    var ARG_OPN = '{';
    var ARG_CLS = '}';
    var ARG_SEP = ',';
    var NUM_ARG = '#';
    var TAG_OPN = '<';
    var TAG_CLS = '>';
    var TAG_END = '</';
    var TAG_SELF_CLS = '/>';
    var ESC = '\'';
    var OFFSET = 'offset:';
    var simpleTypes = ['number', 'date', 'time', 'ordinal', 'duration', 'spellout'];
    var submTypes = ['plural', 'select', 'selectordinal'];

    /**
     * parse
     *
     * Turns this:
     *  `You have { numBananas, plural,
     *       =0 {no bananas}
     *      one {a banana}
     *    other {# bananas}
     *  } for sale`
     *
     * into this:
     *  [ "You have ", [ "numBananas", "plural", 0, {
     *       "=0": [ "no bananas" ],
     *      "one": [ "a banana" ],
     *    "other": [ [ '#' ], " bananas" ]
     *  } ], " for sale." ]
     *
     * tokens:
     *  [
     *    [ "text", "You have " ],
     *    [ "syntax", "{" ],
     *    [ "space", " " ],
     *    [ "id", "numBananas" ],
     *    [ "syntax", ", " ],
     *    [ "space", " " ],
     *    [ "type", "plural" ],
     *    [ "syntax", "," ],
     *    [ "space", "\n     " ],
     *    [ "selector", "=0" ],
     *    [ "space", " " ],
     *    [ "syntax", "{" ],
     *    [ "text", "no bananas" ],
     *    [ "syntax", "}" ],
     *    [ "space", "\n    " ],
     *    [ "selector", "one" ],
     *    [ "space", " " ],
     *    [ "syntax", "{" ],
     *    [ "text", "a banana" ],
     *    [ "syntax", "}" ],
     *    [ "space", "\n  " ],
     *    [ "selector", "other" ],
     *    [ "space", " " ],
     *    [ "syntax", "{" ],
     *    [ "syntax", "#" ],
     *    [ "text", " bananas" ],
     *    [ "syntax", "}" ],
     *    [ "space", "\n" ],
     *    [ "syntax", "}" ],
     *    [ "text", " for sale." ]
     *  ]
     **/
    exports = module.exports = function parse(pattern /*: string */, options /*:: ?: { tagsType?: string, tokens?: Token[] } */) /*: AST */{
      return parseAST({
        pattern: String(pattern),
        index: 0,
        tagsType: options && options.tagsType || null,
        tokens: options && options.tokens || null
      }, '');
    };
    function parseAST(current /*: Context */, parentType /*: string */) /*: AST */{
      var pattern = current.pattern;
      var length = pattern.length;
      var elements /*: AST */ = [];
      var start = current.index;
      var text = parseText(current, parentType);
      if (text) elements.push(text);
      if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);
      while (current.index < length) {
        if (pattern[current.index] === ARG_CLS) {
          if (!parentType) throw expected(current);
          break;
        }
        if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break;
        elements.push(parsePlaceholder(current));
        start = current.index;
        text = parseText(current, parentType);
        if (text) elements.push(text);
        if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);
      }
      return elements;
    }
    function parseText(current /*: Context */, parentType /*: string */) /*: string */{
      var pattern = current.pattern;
      var length = pattern.length;
      var isHashSpecial = parentType === 'plural' || parentType === 'selectordinal';
      var isAngleSpecial = !!current.tagsType;
      var isArgStyle = parentType === '{style}';
      var text = '';
      while (current.index < length) {
        var char = pattern[current.index];
        if (char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle && isWhitespace(char.charCodeAt(0))) {
          break;
        } else if (char === ESC) {
          char = pattern[++current.index];
          if (char === ESC) {
            // double is always 1 '
            text += char;
            ++current.index;
          } else if (
          // only when necessary
          char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle) {
            text += char;
            while (++current.index < length) {
              char = pattern[current.index];
              if (char === ESC && pattern[current.index + 1] === ESC) {
                // double is always 1 '
                text += ESC;
                ++current.index;
              } else if (char === ESC) {
                // end of quoted
                ++current.index;
                break;
              } else {
                text += char;
              }
            }
          } else {
            // lone ' is just a '
            text += ESC;
            // already incremented
          }
        } else {
          text += char;
          ++current.index;
        }
      }
      return text;
    }
    function isWhitespace(code /*: number */) /*: boolean */{
      return code >= 0x09 && code <= 0x0D || code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E || code >= 0x2000 && code <= 0x200D || code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F || code === 0x2060 || code === 0x3000 || code === 0xFEFF;
    }
    function skipWhitespace(current /*: Context */) /*: void */{
      var pattern = current.pattern;
      var length = pattern.length;
      var start = current.index;
      while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {
        ++current.index;
      }
      if (start < current.index && current.tokens) {
        current.tokens.push(['space', current.pattern.slice(start, current.index)]);
      }
    }
    function parsePlaceholder(current /*: Context */) /*: Placeholder */{
      var pattern = current.pattern;
      if (pattern[current.index] === NUM_ARG) {
        if (current.tokens) current.tokens.push(['syntax', NUM_ARG]);
        ++current.index; // move passed #
        return [NUM_ARG];
      }
      var tag = parseTag(current);
      if (tag) return tag;

      /* istanbul ignore if should be unreachable if parseAST and parseText are right */
      if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN);
      if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);
      ++current.index; // move passed {
      skipWhitespace(current);
      var id = parseId(current);
      if (!id) throw expected(current, 'placeholder id');
      if (current.tokens) current.tokens.push(['id', id]);
      skipWhitespace(current);
      var char = pattern[current.index];
      if (char === ARG_CLS) {
        // end placeholder
        if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
        ++current.index; // move passed }
        return [id];
      }
      if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);
      if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);
      ++current.index; // move passed ,
      skipWhitespace(current);
      var type = parseId(current);
      if (!type) throw expected(current, 'placeholder type');
      if (current.tokens) current.tokens.push(['type', type]);
      skipWhitespace(current);
      char = pattern[current.index];
      if (char === ARG_CLS) {
        // end placeholder
        if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
        if (type === 'plural' || type === 'selectordinal' || type === 'select') {
          throw expected(current, type + ' sub-messages');
        }
        ++current.index; // move passed }
        return [id, type];
      }
      if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);
      if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);
      ++current.index; // move passed ,
      skipWhitespace(current);
      var arg;
      if (type === 'plural' || type === 'selectordinal') {
        var offset = parsePluralOffset(current);
        skipWhitespace(current);
        arg = [id, type, offset, parseSubMessages(current, type)];
      } else if (type === 'select') {
        arg = [id, type, parseSubMessages(current, type)];
      } else if (simpleTypes.indexOf(type) >= 0) {
        arg = [id, type, parseSimpleFormat(current)];
      } else {
        // custom placeholder type
        var index = current.index;
        var format /*: string | SubMessages */ = parseSimpleFormat(current);
        skipWhitespace(current);
        if (pattern[current.index] === ARG_OPN) {
          current.index = index; // rewind, since should have been submessages
          format = parseSubMessages(current, type);
        }
        arg = [id, type, format];
      }
      skipWhitespace(current);
      if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS);
      if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
      ++current.index; // move passed }
      return arg;
    }
    function parseTag(current /*: Context */) /*: ?Placeholder */{
      var tagsType = current.tagsType;
      if (!tagsType || current.pattern[current.index] !== TAG_OPN) return;
      if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {
        throw expected(current, null, 'closing tag without matching opening tag');
      }
      if (current.tokens) current.tokens.push(['syntax', TAG_OPN]);
      ++current.index; // move passed <

      var id = parseId(current, true);
      if (!id) throw expected(current, 'placeholder id');
      if (current.tokens) current.tokens.push(['id', id]);
      skipWhitespace(current);
      if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {
        if (current.tokens) current.tokens.push(['syntax', TAG_SELF_CLS]);
        current.index += TAG_SELF_CLS.length;
        return [id, tagsType];
      }
      if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);
      if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);
      ++current.index; // move passed >

      var children = parseAST(current, tagsType);
      var end = current.index;
      if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS);
      if (current.tokens) current.tokens.push(['syntax', TAG_END]);
      current.index += TAG_END.length;
      var closeId = parseId(current, true);
      if (closeId && current.tokens) current.tokens.push(['id', closeId]);
      if (id !== closeId) {
        current.index = end; // rewind for better error message
        throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS);
      }
      skipWhitespace(current);
      if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);
      if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);
      ++current.index; // move passed >

      return [id, tagsType, {
        children: children
      }];
    }
    function parseId(current /*: Context */, isTag /*:: ?: boolean */) /*: string */{
      var pattern = current.pattern;
      var length = pattern.length;
      var id = '';
      while (current.index < length) {
        var char = pattern[current.index];
        if (char === ARG_OPN || char === ARG_CLS || char === ARG_SEP || char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) || isTag && (char === TAG_OPN || char === TAG_CLS || char === '/')) break;
        id += char;
        ++current.index;
      }
      return id;
    }
    function parseSimpleFormat(current /*: Context */) /*: string */{
      var start = current.index;
      var style = parseText(current, '{style}');
      if (!style) throw expected(current, 'placeholder style name');
      if (current.tokens) current.tokens.push(['style', current.pattern.slice(start, current.index)]);
      return style;
    }
    function parsePluralOffset(current /*: Context */) /*: number */{
      var pattern = current.pattern;
      var length = pattern.length;
      var offset = 0;
      if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {
        if (current.tokens) current.tokens.push(['offset', 'offset'], ['syntax', ':']);
        current.index += OFFSET.length; // move passed offset:
        skipWhitespace(current);
        var start = current.index;
        while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {
          ++current.index;
        }
        if (start === current.index) throw expected(current, 'offset number');
        if (current.tokens) current.tokens.push(['number', pattern.slice(start, current.index)]);
        offset = +pattern.slice(start, current.index);
      }
      return offset;
    }
    function isDigit(code /*: number */) /*: boolean */{
      return code >= 0x30 && code <= 0x39;
    }
    function parseSubMessages(current /*: Context */, parentType /*: string */) /*: SubMessages */{
      var pattern = current.pattern;
      var length = pattern.length;
      var options /*: SubMessages */ = {};
      while (current.index < length && pattern[current.index] !== ARG_CLS) {
        var selector = parseId(current);
        if (!selector) throw expected(current, 'sub-message selector');
        if (current.tokens) current.tokens.push(['selector', selector]);
        skipWhitespace(current);
        options[selector] = parseSubMessage(current, parentType);
        skipWhitespace(current);
      }
      if (!options.other && submTypes.indexOf(parentType) >= 0) {
        throw expected(current, null, null, '"other" sub-message must be specified in ' + parentType);
      }
      return options;
    }
    function parseSubMessage(current /*: Context */, parentType /*: string */) /*: AST */{
      if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message');
      if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);
      ++current.index; // move passed {
      var message = parseAST(current, parentType);
      if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message');
      if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
      ++current.index; // move passed }
      return message;
    }
    function expected(current /*: Context */, expected /*:: ?: ?string */, found /*:: ?: ?string */, message /*:: ?: string */) {
      var pattern = current.pattern;
      var lines = pattern.slice(0, current.index).split(/\r?\n/);
      var offset = current.index;
      var line = lines.length;
      var column = lines.slice(-1)[0].length;
      found = found || (current.index >= pattern.length ? 'end of message pattern' : parseId(current) || pattern[current.index]);
      if (!message) message = errorMessage(expected, found);
      message += ' in ' + pattern.replace(/\r?\n/g, '\n');
      return new SyntaxError(message, expected, found, offset, line, column);
    }
    function errorMessage(expected /*: ?string */, found /* string */) {
      if (!expected) return 'Unexpected ' + found + ' found';
      return 'Expected ' + expected + ' but found ' + found;
    }

    /**
     * SyntaxError
     *  Holds information about bad syntax found in a message pattern
     **/
    function SyntaxError(message /*: string */, expected /*: ?string */, found /*: ?string */, offset /*: number */, line /*: number */, column /*: number */) {
      Error.call(this, message);
      this.name = 'SyntaxError';
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;
    }
    SyntaxError.prototype = Object.create(Error.prototype);
    exports.SyntaxError = SyntaxError;
  })(formatMessageParse, formatMessageParse.exports);
  return formatMessageParse.exports;
}

var formatMessageInterpret = {exports: {}};

var formatMessageFormats;
var hasRequiredFormatMessageFormats;
function requireFormatMessageFormats() {
  if (hasRequiredFormatMessageFormats) return formatMessageFormats;
  hasRequiredFormatMessageFormats = 1;
  // @flow
  var LONG = 'long';
  var SHORT = 'short';
  var NARROW = 'narrow';
  var NUMERIC = 'numeric';
  var TWODIGIT = '2-digit';

  /**
   * formatting information
   **/
  formatMessageFormats = {
    number: {
      decimal: {
        style: 'decimal'
      },
      integer: {
        style: 'decimal',
        maximumFractionDigits: 0
      },
      currency: {
        style: 'currency',
        currency: 'USD'
      },
      percent: {
        style: 'percent'
      },
      default: {
        style: 'decimal'
      }
    },
    date: {
      short: {
        month: NUMERIC,
        day: NUMERIC,
        year: TWODIGIT
      },
      medium: {
        month: SHORT,
        day: NUMERIC,
        year: NUMERIC
      },
      long: {
        month: LONG,
        day: NUMERIC,
        year: NUMERIC
      },
      full: {
        month: LONG,
        day: NUMERIC,
        year: NUMERIC,
        weekday: LONG
      },
      default: {
        month: SHORT,
        day: NUMERIC,
        year: NUMERIC
      }
    },
    time: {
      short: {
        hour: NUMERIC,
        minute: NUMERIC
      },
      medium: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC
      },
      long: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC,
        timeZoneName: SHORT
      },
      full: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC,
        timeZoneName: SHORT
      },
      default: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC
      }
    },
    duration: {
      default: {
        hours: {
          minimumIntegerDigits: 1,
          maximumFractionDigits: 0
        },
        minutes: {
          minimumIntegerDigits: 2,
          maximumFractionDigits: 0
        },
        seconds: {
          minimumIntegerDigits: 2,
          maximumFractionDigits: 3
        }
      }
    },
    parseNumberPattern: function parseNumberPattern(pattern /*: ?string */) {
      if (!pattern) return;
      var options = {};
      var currency = pattern.match(/\b[A-Z]{3}\b/i);
      var syms = pattern.replace(/[^¤]/g, '').length;
      if (!syms && currency) syms = 1;
      if (syms) {
        options.style = 'currency';
        options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name';
        options.currency = currency ? currency[0].toUpperCase() : 'USD';
      } else if (pattern.indexOf('%') >= 0) {
        options.style = 'percent';
      }
      if (!/[@#0]/.test(pattern)) return options.style ? options : undefined;
      options.useGrouping = pattern.indexOf(',') >= 0;
      if (/E\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {
        var size = pattern.replace(/E\+?[@#0]+|[^@#0]/gi, '');
        options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21);
        options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21);
      } else {
        var parts = pattern.replace(/[^#0.]/g, '').split('.');
        var integer = parts[0];
        var n = integer.length - 1;
        while (integer[n] === '0') --n;
        options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21);
        var fraction = parts[1] || '';
        n = 0;
        while (fraction[n] === '0') ++n;
        options.minimumFractionDigits = Math.min(Math.max(n, 0), 20);
        while (fraction[n] === '#') ++n;
        options.maximumFractionDigits = Math.min(Math.max(n, 0), 20);
      }
      return options;
    },
    parseDatePattern: function parseDatePattern(pattern /*: ?string */) {
      if (!pattern) return;
      var options = {};
      for (var i = 0; i < pattern.length;) {
        var current = pattern[i];
        var n = 1;
        while (pattern[++i] === current) ++n;
        switch (current) {
          case 'G':
            options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
            break;
          case 'y':
          case 'Y':
            options.year = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 'M':
          case 'L':
            n = Math.min(Math.max(n - 1, 0), 4);
            options.month = [NUMERIC, TWODIGIT, SHORT, LONG, NARROW][n];
            break;
          case 'E':
          case 'e':
          case 'c':
            options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
            break;
          case 'd':
          case 'D':
            options.day = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 'h':
          case 'K':
            options.hour12 = true;
            options.hour = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 'H':
          case 'k':
            options.hour12 = false;
            options.hour = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 'm':
            options.minute = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 's':
          case 'S':
            options.second = n === 2 ? TWODIGIT : NUMERIC;
            break;
          case 'z':
          case 'Z':
          case 'v':
          case 'V':
            options.timeZoneName = n === 1 ? SHORT : LONG;
            break;
        }
      }
      return Object.keys(options).length ? options : undefined;
    }
  };
  return formatMessageFormats;
}

var lookupClosestLocale;
var hasRequiredLookupClosestLocale;
function requireLookupClosestLocale() {
  if (hasRequiredLookupClosestLocale) return lookupClosestLocale;
  hasRequiredLookupClosestLocale = 1;
  // @flow
  // "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
  // assumes normalized language tags, and matches in a case sensitive manner
  lookupClosestLocale = function lookupClosestLocale(locale /*: string | string[] | void */, available /*: { [string]: any } */) /*: ?string */{
    if (typeof locale === 'string' && available[locale]) return locale;
    var locales = [].concat(locale || []);
    for (var l = 0, ll = locales.length; l < ll; ++l) {
      var current = locales[l].split('-');
      while (current.length) {
        var candidate = current.join('-');
        if (available[candidate]) return candidate;
        current.pop();
      }
    }
  };
  return lookupClosestLocale;
}

var plurals;
var hasRequiredPlurals;
function requirePlurals() {
  if (hasRequiredPlurals) return plurals;
  hasRequiredPlurals = 1;

  /*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */
  var zero = 'zero',
    one = 'one',
    two = 'two',
    few = 'few',
    many = 'many',
    other = 'other';
  var f = [function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return 0 <= n && n <= 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var n = +s;
    return i === 0 || n === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 0 ? zero : n === 1 ? one : n === 2 ? two : 3 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 99 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return i === 1 && v === 0 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 1 && n % 100 !== 11 ? one : 2 <= n % 10 && n % 10 <= 4 && (n % 100 < 12 || 14 < n % 100) ? few : n % 10 === 0 || 5 <= n % 10 && n % 10 <= 9 || 11 <= n % 100 && n % 100 <= 14 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 1 && n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91 ? one : n % 10 === 2 && n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92 ? two : (3 <= n % 10 && n % 10 <= 4 || n % 10 === 9) && (n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100) ? few : n !== 0 && n % 1000000 === 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var f = +(s + '.').split('.')[1];
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) || 2 <= f % 10 && f % 10 <= 4 && (f % 100 < 12 || 14 < f % 100) ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return i === 1 && v === 0 ? one : 2 <= i && i <= 4 && v === 0 ? few : v !== 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 0 ? zero : n === 1 ? one : n === 2 ? two : n === 3 ? few : n === 6 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
    var n = +s;
    return n === 1 || t !== 0 && (i === 0 || i === 1) ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var f = +(s + '.').split('.')[1];
    return v === 0 && i % 100 === 1 || f % 100 === 1 ? one : v === 0 && i % 100 === 2 || f % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || 3 <= f % 100 && f % 100 <= 4 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    return i === 0 || i === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var f = +(s + '.').split('.')[1];
    return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9 || v !== 0 && f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n === 2 ? two : 3 <= n && n <= 6 ? few : 7 <= n && n <= 10 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : 3 <= n && n <= 10 || 13 <= n && n <= 19 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return v === 0 && i % 10 === 1 ? one : v === 0 && i % 10 === 2 ? two : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few : v !== 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var n = +s;
    return i === 1 && v === 0 ? one : i === 2 && v === 0 ? two : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
    return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n === 2 ? two : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 0 ? zero : n === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var n = +s;
    return n === 0 ? zero : (i === 0 || i === 1) && n !== 0 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var f = +(s + '.').split('.')[1];
    var n = +s;
    return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one : 2 <= n % 10 && n % 10 <= 9 && (n % 100 < 11 || 19 < n % 100) ? few : f !== 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var v = (s + '.').split('.')[1].length;
    var f = +(s + '.').split('.')[1];
    var n = +s;
    return n % 10 === 0 || 11 <= n % 100 && n % 100 <= 19 || v === 2 && 11 <= f % 100 && f % 100 <= 19 ? zero : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var f = +(s + '.').split('.')[1];
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    var n = +s;
    return i === 1 && v === 0 ? one : v !== 0 || n === 0 || n !== 1 && 1 <= n % 100 && n % 100 <= 19 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n === 0 || 2 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 19 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return i === 1 && v === 0 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i !== 1 && 0 <= i % 10 && i % 10 <= 1 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 12 <= i % 100 && i % 100 <= 14 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    return 0 <= i && i <= 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i % 10 === 0 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 11 <= i % 100 && i % 100 <= 14 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var n = +s;
    return i === 0 || n === 1 ? one : 2 <= n && n <= 10 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var f = +(s + '.').split('.')[1];
    var n = +s;
    return n === 0 || n === 1 || i === 0 && f === 1 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    var v = (s + '.').split('.')[1].length;
    return v === 0 && i % 100 === 1 ? one : v === 0 && i % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || v !== 0 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return 0 <= n && n <= 1 || 11 <= n && n <= 99 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    return i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8 || i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80 ? one : i % 10 === 3 || i % 10 === 4 || i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900 ? few : i === 0 || i % 10 === 6 || i % 100 === 40 || i % 100 === 60 || i % 100 === 90 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return (n % 10 === 2 || n % 10 === 3) && n % 100 !== 12 && n % 100 !== 13 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 3 ? one : n === 2 ? two : n === 4 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 0 || n === 7 || n === 8 || n === 9 ? zero : n === 1 ? one : n === 2 ? two : n === 3 || n === 4 ? few : n === 5 || n === 6 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 1 && n % 100 !== 11 ? one : n % 10 === 2 && n % 100 !== 12 ? two : n % 10 === 3 && n % 100 !== 13 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : n === 3 || n === 13 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 5 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 11 || n === 8 || n === 80 || n === 800 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    return i === 1 ? one : i === 0 || 2 <= i % 100 && i % 100 <= 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var i = Math.floor(Math.abs(+s));
    return i % 10 === 1 && i % 100 !== 11 ? one : i % 10 === 2 && i % 100 !== 12 ? two : (i % 10 === 7 || i % 10 === 8) && i % 100 !== 17 && i % 100 !== 18 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return 1 <= n && n <= 4 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 || n === 5 || 7 <= n && n <= 9 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n === 1 ? one : n % 10 === 4 && n % 100 !== 14 ? many : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return (n % 10 === 1 || n % 10 === 2) && n % 100 !== 11 && n % 100 !== 12 ? one : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 6 || n % 10 === 9 || n === 10 ? few : other;
  }, function (s /*: string | number */) /*: Rule */{
    var n = +s;
    return n % 10 === 3 && n % 100 !== 13 ? few : other;
  }];
  plurals = {
    af: {
      cardinal: f[0]
    },
    ak: {
      cardinal: f[1]
    },
    am: {
      cardinal: f[2]
    },
    ar: {
      cardinal: f[3]
    },
    ars: {
      cardinal: f[3]
    },
    as: {
      cardinal: f[2],
      ordinal: f[34]
    },
    asa: {
      cardinal: f[0]
    },
    ast: {
      cardinal: f[4]
    },
    az: {
      cardinal: f[0],
      ordinal: f[35]
    },
    be: {
      cardinal: f[5],
      ordinal: f[36]
    },
    bem: {
      cardinal: f[0]
    },
    bez: {
      cardinal: f[0]
    },
    bg: {
      cardinal: f[0]
    },
    bh: {
      cardinal: f[1]
    },
    bn: {
      cardinal: f[2],
      ordinal: f[34]
    },
    br: {
      cardinal: f[6]
    },
    brx: {
      cardinal: f[0]
    },
    bs: {
      cardinal: f[7]
    },
    ca: {
      cardinal: f[4],
      ordinal: f[37]
    },
    ce: {
      cardinal: f[0]
    },
    cgg: {
      cardinal: f[0]
    },
    chr: {
      cardinal: f[0]
    },
    ckb: {
      cardinal: f[0]
    },
    cs: {
      cardinal: f[8]
    },
    cy: {
      cardinal: f[9],
      ordinal: f[38]
    },
    da: {
      cardinal: f[10]
    },
    de: {
      cardinal: f[4]
    },
    dsb: {
      cardinal: f[11]
    },
    dv: {
      cardinal: f[0]
    },
    ee: {
      cardinal: f[0]
    },
    el: {
      cardinal: f[0]
    },
    en: {
      cardinal: f[4],
      ordinal: f[39]
    },
    eo: {
      cardinal: f[0]
    },
    es: {
      cardinal: f[0]
    },
    et: {
      cardinal: f[4]
    },
    eu: {
      cardinal: f[0]
    },
    fa: {
      cardinal: f[2]
    },
    ff: {
      cardinal: f[12]
    },
    fi: {
      cardinal: f[4]
    },
    fil: {
      cardinal: f[13],
      ordinal: f[0]
    },
    fo: {
      cardinal: f[0]
    },
    fr: {
      cardinal: f[12],
      ordinal: f[0]
    },
    fur: {
      cardinal: f[0]
    },
    fy: {
      cardinal: f[4]
    },
    ga: {
      cardinal: f[14],
      ordinal: f[0]
    },
    gd: {
      cardinal: f[15],
      ordinal: f[40]
    },
    gl: {
      cardinal: f[4]
    },
    gsw: {
      cardinal: f[0]
    },
    gu: {
      cardinal: f[2],
      ordinal: f[41]
    },
    guw: {
      cardinal: f[1]
    },
    gv: {
      cardinal: f[16]
    },
    ha: {
      cardinal: f[0]
    },
    haw: {
      cardinal: f[0]
    },
    he: {
      cardinal: f[17]
    },
    hi: {
      cardinal: f[2],
      ordinal: f[41]
    },
    hr: {
      cardinal: f[7]
    },
    hsb: {
      cardinal: f[11]
    },
    hu: {
      cardinal: f[0],
      ordinal: f[42]
    },
    hy: {
      cardinal: f[12],
      ordinal: f[0]
    },
    ia: {
      cardinal: f[4]
    },
    io: {
      cardinal: f[4]
    },
    is: {
      cardinal: f[18]
    },
    it: {
      cardinal: f[4],
      ordinal: f[43]
    },
    iu: {
      cardinal: f[19]
    },
    iw: {
      cardinal: f[17]
    },
    jgo: {
      cardinal: f[0]
    },
    ji: {
      cardinal: f[4]
    },
    jmc: {
      cardinal: f[0]
    },
    ka: {
      cardinal: f[0],
      ordinal: f[44]
    },
    kab: {
      cardinal: f[12]
    },
    kaj: {
      cardinal: f[0]
    },
    kcg: {
      cardinal: f[0]
    },
    kk: {
      cardinal: f[0],
      ordinal: f[45]
    },
    kkj: {
      cardinal: f[0]
    },
    kl: {
      cardinal: f[0]
    },
    kn: {
      cardinal: f[2]
    },
    ks: {
      cardinal: f[0]
    },
    ksb: {
      cardinal: f[0]
    },
    ksh: {
      cardinal: f[20]
    },
    ku: {
      cardinal: f[0]
    },
    kw: {
      cardinal: f[19]
    },
    ky: {
      cardinal: f[0]
    },
    lag: {
      cardinal: f[21]
    },
    lb: {
      cardinal: f[0]
    },
    lg: {
      cardinal: f[0]
    },
    ln: {
      cardinal: f[1]
    },
    lt: {
      cardinal: f[22]
    },
    lv: {
      cardinal: f[23]
    },
    mas: {
      cardinal: f[0]
    },
    mg: {
      cardinal: f[1]
    },
    mgo: {
      cardinal: f[0]
    },
    mk: {
      cardinal: f[24],
      ordinal: f[46]
    },
    ml: {
      cardinal: f[0]
    },
    mn: {
      cardinal: f[0]
    },
    mo: {
      cardinal: f[25],
      ordinal: f[0]
    },
    mr: {
      cardinal: f[2],
      ordinal: f[47]
    },
    mt: {
      cardinal: f[26]
    },
    nah: {
      cardinal: f[0]
    },
    naq: {
      cardinal: f[19]
    },
    nb: {
      cardinal: f[0]
    },
    nd: {
      cardinal: f[0]
    },
    ne: {
      cardinal: f[0],
      ordinal: f[48]
    },
    nl: {
      cardinal: f[4]
    },
    nn: {
      cardinal: f[0]
    },
    nnh: {
      cardinal: f[0]
    },
    no: {
      cardinal: f[0]
    },
    nr: {
      cardinal: f[0]
    },
    nso: {
      cardinal: f[1]
    },
    ny: {
      cardinal: f[0]
    },
    nyn: {
      cardinal: f[0]
    },
    om: {
      cardinal: f[0]
    },
    or: {
      cardinal: f[0],
      ordinal: f[49]
    },
    os: {
      cardinal: f[0]
    },
    pa: {
      cardinal: f[1]
    },
    pap: {
      cardinal: f[0]
    },
    pl: {
      cardinal: f[27]
    },
    prg: {
      cardinal: f[23]
    },
    ps: {
      cardinal: f[0]
    },
    pt: {
      cardinal: f[28]
    },
    'pt-PT': {
      cardinal: f[4]
    },
    rm: {
      cardinal: f[0]
    },
    ro: {
      cardinal: f[25],
      ordinal: f[0]
    },
    rof: {
      cardinal: f[0]
    },
    ru: {
      cardinal: f[29]
    },
    rwk: {
      cardinal: f[0]
    },
    saq: {
      cardinal: f[0]
    },
    sc: {
      cardinal: f[4],
      ordinal: f[43]
    },
    scn: {
      cardinal: f[4],
      ordinal: f[43]
    },
    sd: {
      cardinal: f[0]
    },
    sdh: {
      cardinal: f[0]
    },
    se: {
      cardinal: f[19]
    },
    seh: {
      cardinal: f[0]
    },
    sh: {
      cardinal: f[7]
    },
    shi: {
      cardinal: f[30]
    },
    si: {
      cardinal: f[31]
    },
    sk: {
      cardinal: f[8]
    },
    sl: {
      cardinal: f[32]
    },
    sma: {
      cardinal: f[19]
    },
    smi: {
      cardinal: f[19]
    },
    smj: {
      cardinal: f[19]
    },
    smn: {
      cardinal: f[19]
    },
    sms: {
      cardinal: f[19]
    },
    sn: {
      cardinal: f[0]
    },
    so: {
      cardinal: f[0]
    },
    sq: {
      cardinal: f[0],
      ordinal: f[50]
    },
    sr: {
      cardinal: f[7]
    },
    ss: {
      cardinal: f[0]
    },
    ssy: {
      cardinal: f[0]
    },
    st: {
      cardinal: f[0]
    },
    sv: {
      cardinal: f[4],
      ordinal: f[51]
    },
    sw: {
      cardinal: f[4]
    },
    syr: {
      cardinal: f[0]
    },
    ta: {
      cardinal: f[0]
    },
    te: {
      cardinal: f[0]
    },
    teo: {
      cardinal: f[0]
    },
    ti: {
      cardinal: f[1]
    },
    tig: {
      cardinal: f[0]
    },
    tk: {
      cardinal: f[0],
      ordinal: f[52]
    },
    tl: {
      cardinal: f[13],
      ordinal: f[0]
    },
    tn: {
      cardinal: f[0]
    },
    tr: {
      cardinal: f[0]
    },
    ts: {
      cardinal: f[0]
    },
    tzm: {
      cardinal: f[33]
    },
    ug: {
      cardinal: f[0]
    },
    uk: {
      cardinal: f[29],
      ordinal: f[53]
    },
    ur: {
      cardinal: f[4]
    },
    uz: {
      cardinal: f[0]
    },
    ve: {
      cardinal: f[0]
    },
    vo: {
      cardinal: f[0]
    },
    vun: {
      cardinal: f[0]
    },
    wa: {
      cardinal: f[1]
    },
    wae: {
      cardinal: f[0]
    },
    xh: {
      cardinal: f[0]
    },
    xog: {
      cardinal: f[0]
    },
    yi: {
      cardinal: f[4]
    },
    zu: {
      cardinal: f[2]
    },
    lo: {
      ordinal: f[0]
    },
    ms: {
      ordinal: f[0]
    },
    vi: {
      ordinal: f[0]
    }
  };
  return plurals;
}

formatMessageInterpret.exports;
var hasRequiredFormatMessageInterpret;
function requireFormatMessageInterpret() {
  if (hasRequiredFormatMessageInterpret) return formatMessageInterpret.exports;
  hasRequiredFormatMessageInterpret = 1;
  (function (module, exports) {

    var formats = requireFormatMessageFormats();
    var lookupClosestLocale = requireLookupClosestLocale();
    var plurals = requirePlurals();

    /*::
    import type {
      AST,
      SubMessages
    } from '../format-message-parse'
    type Locale = string
    type Locales = Locale | Locale[]
    type Placeholder = any[] // https://github.com/facebook/flow/issues/4050
    export type Type = (Placeholder, Locales) => (any, ?Object) => any
    export type Types = { [string]: Type }
    */

    exports = module.exports = function interpret(ast /*: AST */, locale /*:: ?: Locales */, types /*:: ?: Types */) /*: (args?: Object) => string */{
      return interpretAST(ast, null, locale || 'en', types || {}, true);
    };
    exports.toParts = function toParts(ast /*: AST */, locale /*:: ?: Locales */, types /*:: ?: Types */) /*: (args?: Object) => any[] */{
      return interpretAST(ast, null, locale || 'en', types || {}, false);
    };
    function interpretAST(elements /*: any[] */, parent /*: ?Placeholder */, locale /*: Locales */, types /*: Types */, join /*: boolean */) /*: Function */{
      var parts = elements.map(function (element) {
        return interpretElement(element, parent, locale, types, join);
      });
      if (!join) {
        return function format(args) {
          return parts.reduce(function (parts, part) {
            return parts.concat(part(args));
          }, []);
        };
      }
      if (parts.length === 1) return parts[0];
      return function format(args) {
        var message = '';
        for (var e = 0; e < parts.length; ++e) {
          message += parts[e](args);
        }
        return message;
      };
    }
    function interpretElement(element /*: Placeholder */, parent /*: ?Placeholder */, locale /*: Locales */, types /*: Types */, join /*: boolean */) /*: Function */{
      if (typeof element === 'string') {
        var value /*: string */ = element;
        return function format() {
          return value;
        };
      }
      var id = element[0];
      var type = element[1];
      if (parent && element[0] === '#') {
        id = parent[0];
        var offset = parent[2];
        var formatter = (types.number || defaults.number)([id, 'number'], locale);
        return function format(args) {
          return formatter(getArg(id, args) - offset, args);
        };
      }

      // pre-process children
      var children;
      if (type === 'plural' || type === 'selectordinal') {
        children = {};
        Object.keys(element[3]).forEach(function (key) {
          children[key] = interpretAST(element[3][key], element, locale, types, join);
        });
        element = [element[0], element[1], element[2], children];
      } else if (element[2] && _typeof(element[2]) === 'object') {
        children = {};
        Object.keys(element[2]).forEach(function (key) {
          children[key] = interpretAST(element[2][key], element, locale, types, join);
        });
        element = [element[0], element[1], children];
      }
      var getFrmt = type && (types[type] || defaults[type]);
      if (getFrmt) {
        var frmt = getFrmt(element, locale);
        return function format(args) {
          return frmt(getArg(id, args), args);
        };
      }
      return join ? function format(args) {
        return String(getArg(id, args));
      } : function format(args) {
        return getArg(id, args);
      };
    }
    function getArg(id /*: string */, args /*: ?Object */) /*: any */{
      if (args && id in args) return args[id];
      var parts = id.split('.');
      var a = args;
      for (var i = 0, ii = parts.length; a && i < ii; ++i) {
        a = a[parts[i]];
      }
      return a;
    }
    function interpretNumber(element /*: Placeholder */, locales /*: Locales */) {
      var style = element[2];
      var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;
      return new Intl.NumberFormat(locales, options).format;
    }
    function interpretDuration(element /*: Placeholder */, locales /*: Locales */) {
      var style = element[2];
      var options = formats.duration[style] || formats.duration.default;
      var fs = new Intl.NumberFormat(locales, options.seconds).format;
      var fm = new Intl.NumberFormat(locales, options.minutes).format;
      var fh = new Intl.NumberFormat(locales, options.hours).format;
      var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':';
      return function (s, args) {
        s = +s;
        if (!isFinite(s)) return fs(s);
        var h = ~~(s / 60 / 60); // ~~ acts much like Math.trunc
        var m = ~~(s / 60 % 60);
        var dur = (h ? fh(Math.abs(h)) + sep : '') + fm(Math.abs(m)) + sep + fs(Math.abs(s % 60));
        return s < 0 ? fh(-1).replace(fh(1), dur) : dur;
      };
    }
    function interpretDateTime(element /*: Placeholder */, locales /*: Locales */) {
      var type = element[1];
      var style = element[2];
      var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default;
      return new Intl.DateTimeFormat(locales, options).format;
    }
    function interpretPlural(element /*: Placeholder */, locales /*: Locales */) {
      var type = element[1];
      var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal';
      var offset = element[2];
      var children = element[3];
      var pluralRules;
      if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {
        pluralRules = new Intl.PluralRules(locales, {
          type: pluralType
        });
      } else {
        var locale = lookupClosestLocale(locales, plurals);
        var select = locale && plurals[locale][pluralType] || returnOther;
        pluralRules = {
          select: select
        };
      }
      return function (value, args) {
        var clause = children['=' + +value] || children[pluralRules.select(value - offset)] || children.other;
        return clause(args);
      };
    }
    function returnOther(/*:: n:number */) {
      return 'other';
    }
    function interpretSelect(element /*: Placeholder */, locales /*: Locales */) {
      var children = element[2];
      return function (value, args) {
        var clause = children[value] || children.other;
        return clause(args);
      };
    }
    var defaults /*: Types */ = {
      number: interpretNumber,
      ordinal: interpretNumber,
      // TODO: support rbnf
      spellout: interpretNumber,
      // TODO: support rbnf
      duration: interpretDuration,
      date: interpretDateTime,
      time: interpretDateTime,
      plural: interpretPlural,
      selectordinal: interpretPlural,
      select: interpretSelect
    };
    exports.types = defaults;
  })(formatMessageInterpret, formatMessageInterpret.exports);
  return formatMessageInterpret.exports;
}

formatMessage.exports;
var hasRequiredFormatMessage;
function requireFormatMessage() {
  if (hasRequiredFormatMessage) return formatMessage.exports;
  hasRequiredFormatMessage = 1;
  (function (module, exports) {

    var parse = requireFormatMessageParse();
    var interpret = requireFormatMessageInterpret();
    var plurals = requirePlurals();
    var lookupClosestLocale = requireLookupClosestLocale();
    var origFormats = requireFormatMessageFormats();

    /*::
    import type { Types } from 'format-message-interpret'
    type Locale = string
    type Locales = Locale | Locale[]
    type Message = string | {|
      id?: string,
      default: string,
      description?: string
    |}
    type Translations = { [string]: ?{ [string]: string | Translation } }
    type Translation = {
      message: string,
      format?: (args?: Object) => string,
      toParts?: (args?: Object) => any[],
    }
    type Replacement = ?string | (string, string, locales?: Locales) => ?string
    type GenerateId = (string) => string
    type MissingTranslation = 'ignore' | 'warning' | 'error'
    type FormatObject = { [string]: * }
    type Options = {
      locale?: Locales,
      translations?: ?Translations,
      generateId?: GenerateId,
      missingReplacement?: Replacement,
      missingTranslation?: MissingTranslation,
      formats?: {
        number?: FormatObject,
        date?: FormatObject,
        time?: FormatObject
      },
      types?: Types
    }
    type Setup = {|
      locale: Locales,
      translations: Translations,
      generateId: GenerateId,
      missingReplacement: Replacement,
      missingTranslation: MissingTranslation,
      formats: {
        number: FormatObject,
        date: FormatObject,
        time: FormatObject
      },
      types: Types
    |}
    type FormatMessage = {
      (msg: Message, args?: Object, locales?: Locales): string,
      rich (msg: Message, args?: Object, locales?: Locales): any[],
      setup (opt?: Options): Setup,
      number (value: number, style?: string, locales?: Locales): string,
      date (value: number | Date, style?: string, locales?: Locales): string,
      time (value: number | Date, style?: string, locales?: Locales): string,
      select (value: any, options: Object): any,
      custom (placeholder: any[], locales: Locales, value: any, args: Object): any,
      plural (value: number, offset: any, options: any, locale: any): any,
      selectordinal (value: number, offset: any, options: any, locale: any): any,
      namespace (): FormatMessage
    }
    */

    function assign /*:: <T: Object> */(target /*: T */, source /*: Object */) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
      return target;
    }
    function namespace() /*: FormatMessage */{
      var formats = assign({}, origFormats);
      var currentLocales /*: Locales */ = 'en';
      var translations /*: Translations */ = {};
      var generateId /*: GenerateId */ = function generateId(pattern) {
        return pattern;
      };
      var missingReplacement /*: Replacement */ = null;
      var missingTranslation /*: MissingTranslation */ = 'warning';
      var types /*: Types */ = {};
      function formatMessage(msg /*: Message */, args /*:: ?: Object */, locales /*:: ?: Locales */) {
        var pattern = typeof msg === 'string' ? msg : msg.default;
        var id = _typeof(msg) === 'object' && msg.id || generateId(pattern);
        var translated = translate(pattern, id, locales || currentLocales);
        var format = translated.format || (translated.format = interpret(parse(translated.message), locales || currentLocales, types));
        return format(args);
      }
      formatMessage.rich = function rich(msg /*: Message */, args /*:: ?: Object */, locales /*:: ?: Locales */) {
        var pattern = typeof msg === 'string' ? msg : msg.default;
        var id = _typeof(msg) === 'object' && msg.id || generateId(pattern);
        var translated = translate(pattern, id, locales || currentLocales);
        var format = translated.toParts || (translated.toParts = interpret.toParts(parse(translated.message, {
          tagsType: tagsType
        }), locales || currentLocales, types));
        return format(args);
      };
      var tagsType = '<>';
      function richType(node /*: any[] */, locales /*: Locales */) {
        var style = node[2];
        return function (fn, args) {
          var props = _typeof(style) === 'object' ? mapObject(style, args) : style;
          return typeof fn === 'function' ? fn(props) : fn;
        };
      }
      types[tagsType] = richType;
      function mapObject(object /* { [string]: (args?: Object) => any } */, args /*: ?Object */) {
        return Object.keys(object).reduce(function (mapped, key) {
          mapped[key] = object[key](args);
          return mapped;
        }, {});
      }
      function translate(pattern /*: string */, id /*: string */, locales /*: Locales */) /*: Translation */{
        var locale = lookupClosestLocale(locales, translations) || 'en';
        var messages = translations[locale] || (translations[locale] = {});
        var translated = messages[id];
        if (typeof translated === 'string') {
          translated = messages[id] = {
            message: translated
          };
        }
        if (!translated) {
          var message = 'Translation for "' + id + '" in "' + locale + '" is missing';
          if (missingTranslation === 'warning') {
            /* istanbul ignore else */
            if (typeof console !== 'undefined') console.warn(message);
          } else if (missingTranslation !== 'ignore') {
            // 'error'
            throw new Error(message);
          }
          var replacement = typeof missingReplacement === 'function' ? missingReplacement(pattern, id, locale) || pattern : missingReplacement || pattern;
          translated = messages[id] = {
            message: replacement
          };
        }
        return translated;
      }
      formatMessage.setup = function setup(opt /*:: ?: Options */) {
        opt = opt || {};
        if (opt.locale) currentLocales = opt.locale;
        if ('translations' in opt) translations = opt.translations || {};
        if (opt.generateId) generateId = opt.generateId;
        if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement;
        if (opt.missingTranslation) missingTranslation = opt.missingTranslation;
        if (opt.formats) {
          if (opt.formats.number) assign(formats.number, opt.formats.number);
          if (opt.formats.date) assign(formats.date, opt.formats.date);
          if (opt.formats.time) assign(formats.time, opt.formats.time);
        }
        if (opt.types) {
          types = opt.types;
          types[tagsType] = richType;
        }
        return {
          locale: currentLocales,
          translations: translations,
          generateId: generateId,
          missingReplacement: missingReplacement,
          missingTranslation: missingTranslation,
          formats: formats,
          types: types
        };
      };
      formatMessage.number = function (value /*: number */, style /*:: ?: string */, locales /*:: ?: Locales */) {
        var options = style && formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;
        return new Intl.NumberFormat(locales || currentLocales, options).format(value);
      };
      formatMessage.date = function (value /*:: ?: number | Date */, style /*:: ?: string */, locales /*:: ?: Locales */) {
        var options = style && formats.date[style] || formats.parseDatePattern(style) || formats.date.default;
        return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);
      };
      formatMessage.time = function (value /*:: ?: number | Date */, style /*:: ?: string */, locales /*:: ?: Locales */) {
        var options = style && formats.time[style] || formats.parseDatePattern(style) || formats.time.default;
        return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);
      };
      formatMessage.select = function (value /*: any */, options /*: Object */) {
        return options[value] || options.other;
      };
      formatMessage.custom = function (placeholder /*: any[] */, locales /*: Locales */, value /*: any */, args /*: Object */) {
        if (!(placeholder[1] in types)) return value;
        return types[placeholder[1]](placeholder, locales)(value, args);
      };
      formatMessage.plural = plural.bind(null, 'cardinal');
      formatMessage.selectordinal = plural.bind(null, 'ordinal');
      function plural(pluralType /*: 'cardinal' | 'ordinal' */, value /*: number */, offset /*: any */, options /*: any */, locale /*: any */) {
        if (_typeof(offset) === 'object' && _typeof(options) !== 'object') {
          // offset is optional
          locale = options;
          options = offset;
          offset = 0;
        }
        var closest = lookupClosestLocale(locale || currentLocales, plurals);
        var plural = closest && plurals[closest][pluralType] || returnOther;
        return options['=' + +value] || options[plural(value - offset)] || options.other;
      }
      function returnOther(/*:: n:number */) {
        return 'other';
      }
      formatMessage.namespace = namespace;
      return formatMessage;
    }
    module.exports = namespace();
  })(formatMessage, formatMessage.exports);
  return formatMessage.exports;
}

function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
_spikeprimeble.exports;
var hasRequired_spikeprimeble;
function require_spikeprimeble() {
  if (hasRequired_spikeprimeble) return _spikeprimeble.exports;
  hasRequired_spikeprimeble = 1;
  (function (module, exports) {
    // Browser-compatible Scratch VM utilities
    var ArgumentType = {
      ANGLE: 'angle',
      BOOLEAN: 'Boolean',
      COLOR: 'color',
      NUMBER: 'number',
      STRING: 'string',
      MATRIX: 'matrix',
      NOTE: 'note',
      IMAGE: 'image'
    };
    var BlockType = {
      BOOLEAN: 'Boolean',
      BUTTON: 'button',
      COMMAND: 'command',
      CONDITIONAL: 'conditional',
      EVENT: 'event',
      HAT: 'hat',
      LOOP: 'loop',
      REPORTER: 'reporter'
    };
    var Base64Util = {
      base64ToUint8Array: function base64ToUint8Array(base64) {
        var binaryString = atob(base64);
        var len = binaryString.length;
        var array = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          array[i] = binaryString.charCodeAt(i);
        }
        return array;
      }
    };
    var RateLimiter = /*#__PURE__*/function () {
      function RateLimiter(maxRate) {
        _classCallCheck(this, RateLimiter);
        this._maxTokens = maxRate;
        this._refillInterval = 1000 / maxRate;
        this._count = this._maxTokens;
        this._lastUpdateTime = Date.now();
      }
      return _createClass(RateLimiter, [{
        key: "okayToSend",
        value: function okayToSend() {
          var now = Date.now();
          var timeSinceRefill = now - this._lastUpdateTime;
          var refillCount = Math.floor(timeSinceRefill / this._refillInterval);
          if (refillCount > 0) this._lastUpdateTime = now;
          this._count = Math.min(this._maxTokens, this._count + refillCount);
          if (this._count > 0) {
            this._count--;
            return true;
          }
          return false;
        }
      }]);
    }();
    var BleBaseBlocks = requireBleBaseBlocks();
    var Hub = requireHub();
    var blockIconURI = '';
    var formatMessage = requireFormatMessage();
    var extensionURL = 'https://cdn.jsdelivr.net/gh/CrispStrobe/scratch-lego-bluetooth-extensions@master/dist/spikeprime_ble.mjs';

    // SPIKE Prime BLE UUIDs - YOUR WORKING APPROACH
    var SPIKE_PRIME_SERVICE_UUID = '0000fd02-0000-1000-8000-00805f9b34fb';
    var SPIKE_PRIME_WRITE_UUID = '0000fd02-0001-1000-8000-00805f9b34fb';
    var SPIKE_PRIME_NOTIFY_UUID = '0000fd02-0002-1000-8000-00805f9b34fb';

    // Standard LEGO UUIDs as fallback
    var LEGO_SERVICE_UUID = '00001623-1212-efde-1623-785feabcd123';
    var LEGO_CHAR_UUID = '00001624-1212-efde-1623-785feabcd123';

    // Constants from working BTC version
    var BTSendRateMax = 40;
    var SpikePorts = ['A', 'B', 'C', 'D', 'E', 'F'];
    var SpikeMotorStopMode = {
      float: 0,
      brake: 1,
      hold: 2
    };
    var SpikeOrientation = {
      front: 1,
      back: 2,
      up: 3,
      down: 4,
      rightside: 5,
      leftside: 6
    };

    // SPIKE Prime Motor Settings
    var SpikeMotorSetting = /*#__PURE__*/function () {
      function SpikeMotorSetting() {
        _classCallCheck(this, SpikeMotorSetting);
        this._speed = 75;
        this._stopMode = SpikeMotorStopMode.brake;
        this._stallDetection = true;
      }
      return _createClass(SpikeMotorSetting, [{
        key: "speed",
        get: function get() {
          return this._speed;
        },
        set: function set(value) {
          this._speed = this._clamp(value, -100, 100);
        }
      }, {
        key: "stopMode",
        get: function get() {
          return this._stopMode;
        },
        set: function set(value) {
          if (value >= 0 && value <= 2) this._stopMode = value;
        }
      }, {
        key: "stallDetection",
        get: function get() {
          return this._stallDetection;
        },
        set: function set(value) {
          this._stallDetection = value;
        }
      }, {
        key: "_clamp",
        value: function _clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
      }]);
    }(); // Complete BLE SPIKE Prime Hub
    var CompleteBLESpikePrimeHub = /*#__PURE__*/function (_Hub) {
      function CompleteBLESpikePrimeHub(runtime, extensionId) {
        var _this7;
        _classCallCheck(this, CompleteBLESpikePrimeHub);
        console.log('🚀 CompleteBLESpikePrimeHub: Initializing...');

        // Initialize without hub type for UUID scanning
        _this7 = _callSuper(this, CompleteBLESpikePrimeHub, [runtime, extensionId, null]);

        // Connection state
        _this7._connectionAttempts = 0;
        _this7._connectionMethod = 'none';
        _this7._connected = false;
        _this7._useSpikePrimeUUIDs = true;

        // Communication state
        _this7._remainingText = '';
        _this7._openRequests = {};
        _this7._requestId = 0;

        // Python REPL state
        _this7._pythonAvailable = false;
        _this7._sensorLoopRunning = false;
        _this7._replHistory = [];
        _this7._replOutput = '';

        // Sensor data
        _this7._sensors = {
          buttons: [0, 0, 0, 0],
          angle: {
            pitch: 0,
            roll: 0,
            yaw: 0
          },
          acceleration: {
            x: 0,
            y: 0,
            z: 0
          },
          gyro: {
            x: 0,
            y: 0,
            z: 0
          },
          orientation: SpikeOrientation.front,
          battery: 100,
          temperature: 25,
          hubTemp: 25,
          gestures: {
            tapped: false,
            doubletapped: false,
            shake: false,
            freefall: false
          },
          motorPositions: {}
        };
        _this7._portValues = {};
        _this7._pixelBrightness = 100;
        _this7._volume = 100;

        // Motor settings
        _this7._motorSettings = {
          A: new SpikeMotorSetting(),
          B: new SpikeMotorSetting(),
          C: new SpikeMotorSetting(),
          D: new SpikeMotorSetting(),
          E: new SpikeMotorSetting(),
          F: new SpikeMotorSetting()
        };

        // Movement and timer
        _this7._movementMotors = ['A', 'B'];
        _this7._timer = {
          start: Date.now(),
          current: 0
        };

        // Rate limiting - safe loading
        try {
          _this7._rateLimiter = new RateLimiter(BTSendRateMax);
        } catch (e) {
          _this7._rateLimiter = {
            okayToSend: function okayToSend() {
              return true;
            }
          };
        }

        // Connection monitoring
        _this7._keepAliveInterval = null;
        _this7._lastHeartbeat = Date.now();

        // Update timer safely
        var self = _this7;
        setInterval(function () {
          self._timer.current = (Date.now() - self._timer.start) / 1000;
        }, 10);
        console.log('✅ CompleteBLESpikePrimeHub: Initialization complete');
        return _this7;
      }

      // Getters
      _inherits(CompleteBLESpikePrimeHub, _Hub);
      return _createClass(CompleteBLESpikePrimeHub, [{
        key: "angle",
        get: function get() {
          return this._sensors.angle;
        }
      }, {
        key: "orientation",
        get: function get() {
          return this._sensors.orientation;
        }
      }, {
        key: "portValues",
        get: function get() {
          return this._portValues;
        }
      }, {
        key: "pixelBrightness",
        get: function get() {
          return this._pixelBrightness;
        },
        set: function set(value) {
          this._pixelBrightness = this._clamp(value, 0, 100);
        }
      }, {
        key: "motorSettings",
        get: function get() {
          return this._motorSettings;
        }
      }, {
        key: "acceleration",
        get: function get() {
          return this._sensors.acceleration;
        }
      }, {
        key: "gyro",
        get: function get() {
          return this._sensors.gyro;
        }
      }, {
        key: "battery",
        get: function get() {
          return this._sensors.battery;
        }
      }, {
        key: "temperature",
        get: function get() {
          return this._sensors.temperature;
        }
      }, {
        key: "hubTemp",
        get: function get() {
          return this._sensors.hubTemp;
        }
      }, {
        key: "gestures",
        get: function get() {
          return this._sensors.gestures;
        }
      }, {
        key: "movementMotors",
        get: function get() {
          return this._movementMotors;
        }
      }, {
        key: "timer",
        get: function get() {
          return this._timer.current;
        }
      }, {
        key: "volume",
        get: function get() {
          return this._volume;
        }
      }, {
        key: "replOutput",
        get: function get() {
          return this._replOutput;
        }
      }, {
        key: "replHistory",
        get: function get() {
          return this._replHistory;
        }

        // Override scan with UUID-first approach
      }, {
        key: "scan",
        value: function scan() {
          console.log('🔍 CompleteBLESpikePrimeHub: Starting BLE scan...');
          this._connectionAttempts++;
          if (this._ble) {
            console.log('📴 CompleteBLESpikePrimeHub: Cleaning up existing connection...');
            this._ble.disconnect();
          }
          var self = this;
          return this._attemptSpikePrimeUUIDs().catch(function (error) {
            console.warn('⚠️ CompleteBLESpikePrimeHub: UUID method failed:', error.message);
            self._useSpikePrimeUUIDs = false;
            return self._attemptStandardLego();
          }).catch(function (error) {
            console.error('❌ CompleteBLESpikePrimeHub: All scan methods failed:', error);
            throw error;
          });
        }
      }, {
        key: "_attemptSpikePrimeUUIDs",
        value: function _attemptSpikePrimeUUIDs() {
          console.log('🎯 CompleteBLESpikePrimeHub: PRIMARY - SPIKE Prime UUID scan');
          this._connectionMethod = 'spike_uuids';
          try {
            var BLE = require('../../../io/ble');
            var options = {
              filters: [{
                services: [SPIKE_PRIME_SERVICE_UUID]
              }, {
                namePrefix: 'LEGO Hub'
              }, {
                namePrefix: 'Technic Hub'
              }],
              optionalServices: [SPIKE_PRIME_SERVICE_UUID]
            };
            console.log('📡 CompleteBLESpikePrimeHub: SPIKE UUID scan config:', JSON.stringify(options, null, 2));
            this._ble = new BLE(this._runtime, this._extensionId, options, this._onConnect, this.reset, this._onMessage);
            console.log('✅ CompleteBLESpikePrimeHub: SPIKE Prime UUID scanner ready');
            return Promise.resolve();
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: UUID scan setup failed:', error);
            throw error;
          }
        }
      }, {
        key: "_attemptStandardLego",
        value: function _attemptStandardLego() {
          console.log('🔄 CompleteBLESpikePrimeHub: FALLBACK - Standard LEGO scan');
          this._connectionMethod = 'standard_lego';
          try {
            var BLE = require('../../../io/ble');
            var options = {
              filters: [{
                services: [LEGO_SERVICE_UUID]
              }],
              optionalServices: [LEGO_SERVICE_UUID]
            };
            console.log('📡 CompleteBLESpikePrimeHub: Standard LEGO scan config:', JSON.stringify(options, null, 2));
            this._ble = new BLE(this._runtime, this._extensionId, options, this._onConnect, this.reset, this._onMessage);
            console.log('✅ CompleteBLESpikePrimeHub: Standard LEGO scanner ready');
            return Promise.resolve();
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: Standard scan setup failed:', error);
            throw error;
          }
        }

        // Enhanced connection handler
      }, {
        key: "_onConnect",
        value: function _onConnect() {
          var timestamp = new Date().toLocaleTimeString();
          console.log('[' + timestamp + '] CompleteBLESpikePrimeHub: CONNECTION ESTABLISHED!');
          console.log('📊 Connection details: Method=' + this._connectionMethod + ', Attempt=' + this._connectionAttempts + ', UUIDs=' + this._useSpikePrimeUUIDs);
          try {
            if (this._useSpikePrimeUUIDs) {
              console.log('🎯 CompleteBLESpikePrimeHub: Setting up SPIKE Prime communication...');
              this._setupSpikePrimeCommunication();
            } else {
              console.log('🎯 CompleteBLESpikePrimeHub: Using standard LEGO communication...');
              _superPropGet(CompleteBLESpikePrimeHub, "_onConnect", this, 3)([]);
            }

            // Start Python REPL initialization
            var self = this;
            setTimeout(function () {
              self._initializePythonREPL();
            }, 1000);

            // Start connection monitoring
            this._startConnectionMonitoring();
            this._connected = true;
            console.log('🎉 CompleteBLESpikePrimeHub: Connection fully established!');
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: Connection setup failed:', error);
            this.reset();
          }
        }
      }, {
        key: "_setupSpikePrimeCommunication",
        value: function _setupSpikePrimeCommunication() {
          console.log('📡 CompleteBLESpikePrimeHub: Configuring SPIKE Prime characteristics...');
          try {
            var self = this;

            // Start notifications
            this._ble.startNotifications(SPIKE_PRIME_SERVICE_UUID, SPIKE_PRIME_NOTIFY_UUID, function (base64) {
              self._onMessage({
                message: base64
              });
            });
            console.log('✅ CompleteBLESpikePrimeHub: Notifications enabled');

            // Send initial hub property requests
            this._firstNotificationCallback = function () {
              console.log('📤 CompleteBLESpikePrimeHub: Sending initial hub requests...');
              self.sendMessage(0x01, [0x01, 0x02], false); // Name
              self.sendMessage(0x01, [0x03, 0x05], false); // Firmware
              self.sendMessage(0x01, [0x06, 0x05], false); // Battery
              console.log('✅ CompleteBLESpikePrimeHub: Initial hub requests sent');
            };
            this._startPollingBatteryLevel();
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: SPIKE Prime communication setup failed:', error);
            throw error;
          }
        }
      }, {
        key: "_initializePythonREPL",
        value: function _initializePythonREPL() {
          console.log('🐍 CompleteBLESpikePrimeHub: Initializing Python REPL...');

          // Send Ctrl-C to interrupt any running program
          this.sendRaw('\x03');
          var self = this;
          setTimeout(function () {
            console.log('🐍 CompleteBLESpikePrimeHub: Confirming Python REPL availability...');
            self.sendRaw('import hub\r\nprint("PYTHON_AVAILABLE")\r\n');
          }, 500);
        }
      }, {
        key: "_startConnectionMonitoring",
        value: function _startConnectionMonitoring() {
          console.log('💓 CompleteBLESpikePrimeHub: Starting connection monitoring...');
          if (this._keepAliveInterval) {
            clearInterval(this._keepAliveInterval);
          }
          var self = this;
          this._keepAliveInterval = setInterval(function () {
            var now = Date.now();
            var timeSinceLastMessage = now - self._lastHeartbeat;
            if (self.isConnected()) {
              console.log('💓 CompleteBLESpikePrimeHub: Heartbeat - Last: ' + timeSinceLastMessage + 'ms, Method: ' + self._connectionMethod + ', Python: ' + self._pythonAvailable);
              if (timeSinceLastMessage > 10000) {
                // 10 seconds
                console.log('📡 CompleteBLESpikePrimeHub: Sending keep-alive...');
                self.sendMessage(0x01, [0x06, 0x05], false); // Battery request
              }
              if (timeSinceLastMessage > 25000) {
                // 25 seconds
                console.error('💀 CompleteBLESpikePrimeHub: Connection timeout, recovering...');
                self._recoverConnection();
              }
            } else {
              console.warn('⚠️ CompleteBLESpikePrimeHub: Connection lost during monitoring');
              self._stopConnectionMonitoring();
            }
          }, 5000);
          console.log('✅ CompleteBLESpikePrimeHub: Connection monitoring active');
        }
      }, {
        key: "_stopConnectionMonitoring",
        value: function _stopConnectionMonitoring() {
          if (this._keepAliveInterval) {
            console.log('⏹️ CompleteBLESpikePrimeHub: Stopping connection monitoring');
            clearInterval(this._keepAliveInterval);
            this._keepAliveInterval = null;
          }
        }
      }, {
        key: "_recoverConnection",
        value: function _recoverConnection() {
          console.log('🔧 CompleteBLESpikePrimeHub: Attempting connection recovery...');
          if (this.isConnected()) {
            this.sendMessage(0x01, [0x01, 0x05], false); // Hub name request
          } else {
            console.log('🔄 CompleteBLESpikePrimeHub: Full reconnection needed');
            this.reset();
          }
        }

        // Enhanced message handling
      }, {
        key: "_onMessage",
        value: function _onMessage(params) {
          var timestamp = new Date().toLocaleTimeString();
          this._lastHeartbeat = Date.now();
          try {
            var text;
            var data;
            if (typeof params.message === 'string') {
              // BLE base64 message

              data = Base64Util.base64ToUint8Array(params.message);
              text = new TextDecoder().decode(data);
              if (data.length >= 3) {
                var length = data[0];
                var messageType = data[2];
                var dataStr = Array.from(data.slice(0, Math.min(8, data.length))).map(function (b) {
                  return '0x' + b.toString(16).padStart(2, '0');
                }).join(',');
                var suffix = data.length > 8 ? '...' : '';
                console.log('[' + timestamp + '] CompleteBLESpikePrimeHub: BLE MSG - Len:' + length + ', Type:0x' + messageType.toString(16) + ', Data:[' + dataStr + suffix + ']');

                // Process as LEGO BLE message
                _superPropGet(CompleteBLESpikePrimeHub, "_onMessage", this, 3)([params.message]);
                return;
              }
            } else {
              text = params.message;
            }

            // Process as Python REPL output
            var responses = (this._remainingText + text).split('\r\n');
            this._remainingText = responses.pop() || '';
            for (var i = 0; i < responses.length; i++) {
              var responseText = responses[i];
              var trimmedText = responseText.trim();
              if (!trimmedText) continue;
              console.log('[' + timestamp + '] CompleteBLESpikePrimeHub: PYTHON - "' + trimmedText + '"');

              // Try JSON parsing first
              try {
                var json = JSON.parse(trimmedText);
                this._parseJSONResponse(json);
              } catch (error) {
                // Process as raw Python output
                this._parsePythonData(trimmedText);
              }
            }
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: Message processing error:', error);
          }
        }
      }, {
        key: "_parsePythonData",
        value: function _parsePythonData(dataText) {
          try {
            if (dataText.indexOf('PYTHON_AVAILABLE') !== -1) {
              if (!this._pythonAvailable) {
                this._pythonAvailable = true;
                console.log('🐍 CompleteBLESpikePrimeHub: Python REPL confirmed available!');
                this._initializeContinuousSensorMonitoring();
              }
            } else if (dataText.indexOf('SENSORS:') === 0) {
              this._parseSensorData(dataText.substring(8));
            } else if (dataText.indexOf('GESTURE:') === 0) {
              var gesture = dataText.substring(8).toLowerCase();
              if (this._sensors.gestures.hasOwnProperty(gesture)) {
                this._sensors.gestures[gesture] = true;
                var self = this;
                setTimeout(function () {
                  self._sensors.gestures[gesture] = false;
                }, 100);
              }
            } else if (dataText.indexOf('>>>') === 0) {
              this._replOutput += dataText + '\n';
              if (this._replOutput.length > 1000) {
                this._replOutput = this._replOutput.substring(this._replOutput.length - 1000);
              }
            }
          } catch (error) {
            console.warn('⚠️ CompleteBLESpikePrimeHub: Error parsing Python data:', error);
          }
        }
      }, {
        key: "_parseSensorData",
        value: function _parseSensorData(sensorData) {
          try {
            var parts = sensorData.split('|');
            if (parts.length >= 5) {
              // Angles
              var angles = parts[0].split(',').map(parseFloat);
              if (angles.length === 3) {
                this._sensors.angle = {
                  yaw: angles[0],
                  pitch: angles[1],
                  roll: angles[2]
                };
              }

              // Acceleration
              var accel = parts[1].split(',').map(parseFloat);
              if (accel.length === 3) {
                this._sensors.acceleration = {
                  x: accel[0],
                  y: accel[1],
                  z: accel[2]
                };
              }

              // Orientation
              this._sensors.orientation = parseInt(parts[2], 10);

              // Temperatures
              var temps = parts[3].split(',').map(parseFloat);
              if (temps.length >= 2) {
                this._sensors.temperature = temps[0];
                this._sensors.hubTemp = temps[1];
              }

              // Motor positions
              if (parts[4]) {
                var motorPairs = parts[4].split('|');
                for (var i = 0; i < motorPairs.length; i++) {
                  var pair = motorPairs[i];
                  var splitPair = pair.split(':');
                  var port = splitPair[0];
                  var values = splitPair[1];
                  if (port && values) {
                    var motorValues = values.split(',').map(parseFloat);
                    var speed = motorValues[0];
                    var relDeg = motorValues[1];
                    var absDeg = motorValues[2];
                    var pwm = motorValues[3];
                    this._sensors.motorPositions[port] = {
                      speed: speed,
                      relativePosition: relDeg,
                      absolutePosition: absDeg,
                      power: pwm
                    };
                  }
                }
              }
            }
          } catch (error) {
            console.warn('⚠️ CompleteBLESpikePrimeHub: Error parsing sensor data:', error);
          }
        }
      }, {
        key: "_parseJSONResponse",
        value: function _parseJSONResponse(response) {
          // Handle JSON-RPC responses
          if (response.hasOwnProperty('i')) {
            var openRequest = this._openRequests[response.i];
            if (openRequest) {
              openRequest.resolve(response.r);
              delete this._openRequests[response.i];
            }
          }
          if (response.hasOwnProperty('m')) {
            // Handle hub status messages
            this._parseHubStatusResponse(response);
          }
        }
      }, {
        key: "_parseHubStatusResponse",
        value: function _parseHubStatusResponse(response) {
          // Hub status parsing
          if (response.m === 0 && response.p) {
            // Port data parsing
            for (var i = 0; i < 6 && i < response.p.length; i++) {
              var port = SpikePorts[i];
              if (response.p[i] && response.p[i].length >= 2) {
                var deviceId = response.p[i][0];
                var values = response.p[i][1];
                switch (deviceId) {
                  case 48: // Large motor
                  case 49:
                    // Medium motor
                    this._portValues[port] = {
                      type: 'motor',
                      speed: values[0] || 0,
                      degreesCounted: values[1] || 0,
                      position: ((values[2] || 0) + 360) % 360,
                      power: values[3] || 0,
                      relativePosition: values[1] || 0,
                      absolutePosition: values[2] || 0
                    };
                    break;
                  case 61:
                    // Color sensor
                    this._portValues[port] = {
                      type: 'color',
                      color: values[0] || 0,
                      reflection: values[1] || 0,
                      ambient: values[2] || 0
                    };
                    break;
                  case 62:
                    // Distance sensor
                    this._portValues[port] = {
                      type: 'distance',
                      distance: values[0] === -1 ? 0 : values[0] || 0
                    };
                    break;
                  case 63:
                    // Force sensor
                    this._portValues[port] = {
                      type: 'force',
                      force: values[0] || 0,
                      pressed: (values[1] || 0) > 0
                    };
                    break;
                }
              }
            }
          }
        }
      }, {
        key: "_initializeContinuousSensorMonitoring",
        value: function _initializeContinuousSensorMonitoring() {
          if (this._sensorLoopRunning) return;
          this._sensorLoopRunning = true;
          console.log('🔄 CompleteBLESpikePrimeHub: Starting continuous sensor monitoring...');

          // Sensor monitoring script
          var sensorScript = 'import hub, utime\n' + 'def continuous_sensor_loop():\n' + '    while True:\n' + '        try:\n' + '            yaw_angle, pitch_angle, roll_angle = hub.motion.position()\n' + '            accel_x, accel_y, accel_z = hub.motion.accelerometer()\n' + '            orientation = hub.motion.orientation()\n' + '            battery_temp = hub.battery.temperature()\n' + '            hub_temp = hub.temperature()\n' + '            motor_data = {}\n' + '            for port in "ABCDEF":\n' + '                if hasattr(hub.port[port], "motor"):\n' + '                    try:\n' + '                        speed, rel_deg, abs_deg, pwm = hub.port[port].motor.get()\n' + '                        motor_data[port] = f"{speed},{rel_deg},{abs_deg},{pwm}"\n' + '                    except: pass\n' + '            motor_str = "|".join([f"{k}:{v}" for k, v in motor_data.items()])\n' + '            print(f"SENSORS:{yaw_angle},{pitch_angle},{roll_angle}|{accel_x},{accel_y},{accel_z}|{orientation}|{battery_temp},{hub_temp}|{motor_str}")\n' + '            for gesture in ["tapped", "doubletapped", "shake", "freefall"]:\n' + '                if hub.motion.was_gesture(gesture):\n' + '                    print(f"GESTURE:{gesture.upper()}")\n' + '        except Exception as e:\n' + '            pass\n' + '        utime.sleep_ms(100)\n' + 'continuous_sensor_loop()\n';
          this.sendPythonCommand(sensorScript);
        }

        // Enhanced send method
      }, {
        key: "send",
        value: function send(data, useLimiter) {
          if (useLimiter === undefined) useLimiter = true;
          var timestamp = new Date().toLocaleTimeString();
          if (!this.isConnected()) {
            console.warn('⚠️ CompleteBLESpikePrimeHub: Cannot send - not connected');
            return Promise.resolve();
          }
          if (useLimiter && !this._rateLimiter.okayToSend()) {
            console.log('⏳ CompleteBLESpikePrimeHub: Rate limited');
            return Promise.resolve();
          }
          var dataStr = Array.from(data.slice(0, Math.min(6, data.length))).map(function (b) {
            return '0x' + b.toString(16).padStart(2, '0');
          }).join(',');
          var suffix = data.length > 6 ? '...' : '';
          console.log('[' + timestamp + '] CompleteBLESpikePrimeHub: SEND - Method:' + this._connectionMethod + ', Len:' + data.length + ', Data:[' + dataStr + suffix + ']');
          try {
            var serviceUUID = this._useSpikePrimeUUIDs ? SPIKE_PRIME_SERVICE_UUID : LEGO_SERVICE_UUID;
            var writeUUID = this._useSpikePrimeUUIDs ? SPIKE_PRIME_WRITE_UUID : LEGO_CHAR_UUID;
            return this._ble.write(serviceUUID, writeUUID, Base64Util.uint8ArrayToBase64(data), 'base64', true).then(function () {
              console.log('✅ CompleteBLESpikePrimeHub: Data sent successfully');
            }).catch(function (error) {
              console.error('❌ CompleteBLESpikePrimeHub: Send failed:', error);
              throw error;
            });
          } catch (error) {
            console.error('❌ CompleteBLESpikePrimeHub: Send setup failed:', error);
            return Promise.reject(error);
          }
        }

        // Python communication methods
      }, {
        key: "sendRaw",
        value: function sendRaw(text, useLimiter, id) {
          if (!this.isConnected()) return Promise.resolve();
          console.log('🐍 CompleteBLESpikePrimeHub: Sending raw Python: "' + text.replace(/\r\n/g, '\\r\\n') + '"');
          if (id) {
            var self = this;
            var promise = new Promise(function (resolve, reject) {
              self._openRequests[id] = {
                resolve: resolve,
                reject: reject
              };
            });
            this._sendRawMessage(text);
            return promise;
          }
          return this._sendRawMessage(text);
        }
      }, {
        key: "sendPythonCommand",
        value: function sendPythonCommand(pythonCode) {
          var codePreview = pythonCode.substring(0, 100);
          var suffix = pythonCode.length > 100 ? '...' : '';
          console.log('🐍 CompleteBLESpikePrimeHub: Python command: ' + codePreview + suffix);
          return this.sendRaw(pythonCode + '\r\n');
        }
      }, {
        key: "sendReplCommand",
        value: function sendReplCommand(pythonCode) {
          this._replHistory.push(pythonCode);
          if (this._replHistory.length > 50) {
            this._replHistory.shift();
          }
          var escapedCode = pythonCode.replace(/"/g, '\\"');
          var wrappedCode = 'try:\n' + '    _result = eval("' + escapedCode + '")\n' + '    if _result is not None:\n' + '        print(f">>> {_result}")\n' + '    else:\n' + '        exec("' + escapedCode + '")\n' + '        print(">>> Command executed")\n' + 'except Exception as e:\n' + '    print(f">>> Error: {e}")\n';
          return this.sendPythonCommand(wrappedCode);
        }
      }, {
        key: "_sendRawMessage",
        value: function _sendRawMessage(text) {
          // For BLE, send as binary data
          var encoder = new TextEncoder();
          var data = encoder.encode(text);
          return this.send(data, false);
        }

        // Utility methods
      }, {
        key: "_clamp",
        value: function _clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        // Override reset
      }, {
        key: "reset",
        value: function reset() {
          console.log('🔄 CompleteBLESpikePrimeHub: Comprehensive reset...');
          this._connected = false;
          this._pythonAvailable = false;
          this._sensorLoopRunning = false;
          this._useSpikePrimeUUIDs = true;
          this._remainingText = '';
          this._replOutput = '';
          this._replHistory = [];
          this._openRequests = {};
          this._stopConnectionMonitoring();

          // Reset sensors
          this._sensors = {
            buttons: [0, 0, 0, 0],
            angle: {
              pitch: 0,
              roll: 0,
              yaw: 0
            },
            acceleration: {
              x: 0,
              y: 0,
              z: 0
            },
            gyro: {
              x: 0,
              y: 0,
              z: 0
            },
            orientation: SpikeOrientation.front,
            battery: 100,
            temperature: 25,
            hubTemp: 25,
            gestures: {
              tapped: false,
              doubletapped: false,
              shake: false,
              freefall: false
            },
            motorPositions: {}
          };
          this._portValues = {};
          this._timer.start = Date.now();
          this._timer.current = 0;
          console.log('📊 CompleteBLESpikePrimeHub: Reset stats - Attempts:' + this._connectionAttempts + ', Method:' + this._connectionMethod);
          _superPropGet(CompleteBLESpikePrimeHub, "reset", this, 3)([]);
          console.log('✅ CompleteBLESpikePrimeHub: Reset complete');
        }

        // Override isConnected
      }, {
        key: "isConnected",
        value: function isConnected() {
          var connected = this._connected && _superPropGet(CompleteBLESpikePrimeHub, "isConnected", this, 3)([]);
          if (Math.random() < 0.01) {
            // 1% logging
            console.log('🔍 CompleteBLESpikePrimeHub: Status - Connected:' + connected + ', Python:' + this._pythonAvailable + ', Method:' + this._connectionMethod);
          }
          return connected;
        }

        // Control methods
      }, {
        key: "stopAll",
        value: function stopAll() {
          this.stopAllMotors();
          this.stopSound();
        }
      }, {
        key: "stopSound",
        value: function stopSound() {
          this.sendPythonCommand('import hub; hub.sound.stop()');
        }
      }, {
        key: "stopAllMotors",
        value: function stopAllMotors() {
          this.sendPythonCommand('import hub; [hub.port[p].motor.stop() for p in "ABCDEF" if hasattr(hub.port[p], "motor")]');
        }
      }]);
    }(Hub); // Main Extension Class
    var Scratch3SpikePrimeBlocks = /*#__PURE__*/function (_BleBaseBlocks) {
      function Scratch3SpikePrimeBlocks(runtime) {
        var _this8;
        _classCallCheck(this, Scratch3SpikePrimeBlocks);
        console.log('🎯 Scratch3SpikePrimeBlocks: Initializing BLE SPIKE Prime extension...');

        // Use the complete BLE SPIKE Prime hub
        _this8 = _callSuper(this, Scratch3SpikePrimeBlocks, [new CompleteBLESpikePrimeHub(runtime, Scratch3SpikePrimeBlocks.EXTENSION_ID)]);
        if (runtime.formatMessage) {
          formatMessage = runtime.formatMessage;
        }
        console.log('✅ Scratch3SpikePrimeBlocks: BLE extension initialized');
        return _this8;
      }
      _inherits(Scratch3SpikePrimeBlocks, _BleBaseBlocks);
      return _createClass(Scratch3SpikePrimeBlocks, [{
        key: "externalPorts",
        get: function get() {
          return SpikePorts;
        }
      }, {
        key: "multipleExternalPorts",
        get: function get() {
          return ['A', 'B', 'C', 'D', 'E', 'F', 'A+B', 'C+D', 'E+F', 'A+B+C+D+E+F'];
        }
      }, {
        key: "hasInternalTiltSensorBlocks",
        get: function get() {
          return true;
        }
      }, {
        key: "hasAdvancedBlocks",
        get: function get() {
          return true;
        }
      }, {
        key: "setupTranslations",
        value: function setupTranslations(formatMessage) {
          var localeSetup = formatMessage.setup();
          var translations = {
            'en': {
              'spikeprime.motorStart': '[PORT] start motor [DIRECTION]',
              'spikeprime.motorStop': '[PORT] stop motor',
              'spikeprime.motorSetSpeed': '[PORT] set speed to [SPEED] %',
              'spikeprime.getPosition': '[PORT] position',
              'spikeprime.displayText': 'write [TEXT]',
              'spikeprime.displayImage': 'turn on [MATRIX]',
              'spikeprime.displayClear': 'turn off pixels',
              'spikeprime.getDistance': '[PORT] distance',
              'spikeprime.getColor': '[PORT] color',
              'spikeprime.getAngle': '[AXIS] angle',
              'spikeprime.isGesture': 'hub [GESTURE]?',
              'spikeprime.playBeep': 'beep [FREQUENCY] Hz for [DURATION] ms',
              'spikeprime.getBatteryLevel': 'battery level %',
              'spikeprime.isButtonPressed': '[BUTTON] button pressed?',
              'spikeprime.runPythonCommand': 'run Python: [CODE]'
            },
            'de': {
              'spikeprime.motorStart': '[PORT] Motor [DIRECTION] starten',
              'spikeprime.motorStop': '[PORT] Motor stoppen',
              'spikeprime.motorSetSpeed': '[PORT] Geschwindigkeit auf [SPEED] % setzen',
              'spikeprime.getPosition': '[PORT] Position',
              'spikeprime.displayText': '[TEXT] schreiben',
              'spikeprime.displayImage': '[MATRIX] einschalten',
              'spikeprime.displayClear': 'Pixel ausschalten',
              'spikeprime.getDistance': '[PORT] Entfernung',
              'spikeprime.getColor': '[PORT] Farbe',
              'spikeprime.getAngle': '[AXIS] Winkel',
              'spikeprime.isGesture': 'Hub [GESTURE]?',
              'spikeprime.playBeep': '[FREQUENCY] Hz Piep für [DURATION] ms',
              'spikeprime.getBatteryLevel': 'Batteriestand %',
              'spikeprime.isButtonPressed': '[BUTTON] Taste gedrückt?',
              'spikeprime.runPythonCommand': 'Python ausführen: [CODE]',
              // Menu item translations
              'spikeprime.pitch': 'Neigung',
              'spikeprime.roll': 'Rollen',
              'spikeprime.yaw': 'Gieren',
              'spikeprime.tapped': 'angetippt',
              'spikeprime.doubletapped': 'doppelt angetippt',
              'spikeprime.shake': 'geschüttelt',
              'spikeprime.freefall': 'freier Fall',
              'spikeprime.left': 'links',
              'spikeprime.center': 'mitte',
              'spikeprime.right': 'rechts'
            }
          };
          for (var locale in translations) {
            if (!localeSetup.translations[locale]) {
              localeSetup.translations[locale] = {};
            }
            Object.assign(localeSetup.translations[locale], translations[locale]);
          }
        }
      }, {
        key: "getInfo",
        value: function getInfo() {
          this.setupTranslations(formatMessage);
          return {
            id: Scratch3SpikePrimeBlocks.EXTENSION_ID,
            name: 'SPIKE Prime BLE',
            extensionURL: Scratch3SpikePrimeBlocks.extensionURL,
            blockIconURI: blockIconURI,
            showStatusButton: true,
            blocks: [
            // Motor Control
            {
              opcode: 'motorStart',
              text: formatMessage({
                id: 'spikeprime.motorStart',
                default: '[PORT] start motor [DIRECTION]'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'MULTIPLE_PORT',
                  defaultValue: 'A'
                },
                DIRECTION: {
                  type: this.getArgumentType('NUMBER'),
                  menu: 'DIRECTION',
                  defaultValue: 1
                }
              }
            }, {
              opcode: 'motorStop',
              text: formatMessage({
                id: 'spikeprime.motorStop',
                default: '[PORT] stop motor'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'MULTIPLE_PORT',
                  defaultValue: 'A'
                }
              }
            }, {
              opcode: 'motorSetSpeed',
              text: formatMessage({
                id: 'spikeprime.motorSetSpeed',
                default: '[PORT] set speed to [SPEED] %'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'MULTIPLE_PORT',
                  defaultValue: 'A'
                },
                SPEED: {
                  type: this.getArgumentType('NUMBER'),
                  defaultValue: 75
                }
              }
            }, {
              opcode: 'getPosition',
              text: formatMessage({
                id: 'spikeprime.getPosition',
                default: '[PORT] position'
              }),
              blockType: this.getBlockType('REPORTER'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'PORT',
                  defaultValue: 'A'
                }
              }
            }, '---',
            // Display Control
            {
              opcode: 'displayText',
              text: formatMessage({
                id: 'spikeprime.displayText',
                default: 'write [TEXT]'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                TEXT: {
                  type: this.getArgumentType('STRING'),
                  defaultValue: 'Hello'
                }
              }
            }, {
              opcode: 'displayImage',
              text: formatMessage({
                id: 'spikeprime.displayImage',
                default: 'turn on [MATRIX]'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                MATRIX: {
                  type: this.getArgumentType('MATRIX'),
                  defaultValue: '1101111011000001000101110'
                }
              }
            }, {
              opcode: 'displayClear',
              text: formatMessage({
                id: 'spikeprime.displayClear',
                default: 'turn off pixels'
              }),
              blockType: this.getBlockType('COMMAND')
            }, '---',
            // Sensors
            {
              opcode: 'getDistance',
              text: formatMessage({
                id: 'spikeprime.getDistance',
                default: '[PORT] distance'
              }),
              blockType: this.getBlockType('REPORTER'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'PORT',
                  defaultValue: 'A'
                }
              }
            }, {
              opcode: 'getColor',
              text: formatMessage({
                id: 'spikeprime.getColor',
                default: '[PORT] color'
              }),
              blockType: this.getBlockType('REPORTER'),
              arguments: {
                PORT: {
                  type: this.getArgumentType('STRING'),
                  menu: 'PORT',
                  defaultValue: 'A'
                }
              }
            }, {
              opcode: 'getAngle',
              text: formatMessage({
                id: 'spikeprime.getAngle',
                default: '[AXIS] angle'
              }),
              blockType: this.getBlockType('REPORTER'),
              arguments: {
                AXIS: {
                  type: this.getArgumentType('STRING'),
                  menu: 'AXIS',
                  defaultValue: 'pitch'
                }
              }
            }, {
              opcode: 'isGesture',
              text: formatMessage({
                id: 'spikeprime.isGesture',
                default: 'hub [GESTURE]?'
              }),
              blockType: this.getBlockType('BOOLEAN'),
              arguments: {
                GESTURE: {
                  type: this.getArgumentType('STRING'),
                  menu: 'GESTURE',
                  defaultValue: 'tapped'
                }
              }
            }, '---',
            // Sound
            {
              opcode: 'playBeep',
              text: formatMessage({
                id: 'spikeprime.playBeep',
                default: 'beep [FREQUENCY] Hz for [DURATION] ms'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                FREQUENCY: {
                  type: this.getArgumentType('NUMBER'),
                  defaultValue: 440
                },
                DURATION: {
                  type: this.getArgumentType('NUMBER'),
                  defaultValue: 500
                }
              }
            }, '---',
            // Status
            {
              opcode: 'getBatteryLevel',
              text: formatMessage({
                id: 'spikeprime.getBatteryLevel',
                default: 'battery level %'
              }),
              blockType: this.getBlockType('REPORTER')
            }, {
              opcode: 'isButtonPressed',
              text: formatMessage({
                id: 'spikeprime.isButtonPressed',
                default: '[BUTTON] button pressed?'
              }),
              blockType: this.getBlockType('BOOLEAN'),
              arguments: {
                BUTTON: {
                  type: this.getArgumentType('STRING'),
                  menu: 'BUTTON',
                  defaultValue: 'center'
                }
              }
            }, '---',
            // Python
            {
              opcode: 'runPythonCommand',
              text: formatMessage({
                id: 'spikeprime.runPythonCommand',
                default: 'run Python: [CODE]'
              }),
              blockType: this.getBlockType('COMMAND'),
              arguments: {
                CODE: {
                  type: this.getArgumentType('STRING'),
                  defaultValue: 'print("Hello BLE!")'
                }
              }
            }],
            menus: {
              PORT: {
                acceptReporters: true,
                items: SpikePorts
              },
              MULTIPLE_PORT: {
                acceptReporters: true,
                items: ['A', 'B', 'C', 'D', 'E', 'F', 'A+B', 'C+D', 'E+F']
              },
              DIRECTION: {
                acceptReporters: false,
                items: [{
                  text: '⬆️',
                  value: '1'
                }, {
                  text: '⬇️',
                  value: '-1'
                }]
              },
              AXIS: {
                acceptReporters: false,
                items: [{
                  text: formatMessage({
                    id: 'spikeprime.pitch',
                    default: 'pitch'
                  }),
                  value: 'pitch'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.roll',
                    default: 'roll'
                  }),
                  value: 'roll'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.yaw',
                    default: 'yaw'
                  }),
                  value: 'yaw'
                }]
              },
              GESTURE: {
                acceptReporters: false,
                items: [{
                  text: formatMessage({
                    id: 'spikeprime.tapped',
                    default: 'tapped'
                  }),
                  value: 'tapped'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.doubletapped',
                    default: 'doubletapped'
                  }),
                  value: 'doubletapped'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.shake',
                    default: 'shake'
                  }),
                  value: 'shake'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.freefall',
                    default: 'freefall'
                  }),
                  value: 'freefall'
                }]
              },
              BUTTON: {
                acceptReporters: false,
                items: [{
                  text: formatMessage({
                    id: 'spikeprime.left',
                    default: 'left'
                  }),
                  value: 'left'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.center',
                    default: 'center'
                  }),
                  value: 'center'
                }, {
                  text: formatMessage({
                    id: 'spikeprime.right',
                    default: 'right'
                  }),
                  value: 'right'
                }]
              }
            }
          };
        }

        // Helper methods
      }, {
        key: "getBlockType",
        value: function getBlockType(type) {
          try {
            return BlockType[type];
          } catch (e) {
            return type.toLowerCase();
          }
        }
      }, {
        key: "getArgumentType",
        value: function getArgumentType(type) {
          try {
            return ArgumentType[type];
          } catch (e) {
            return type.toLowerCase();
          }
        }
      }, {
        key: "getCast",
        value: function getCast() {
          try {
            return requireCast();
          } catch (e) {
            return {
              toString: function toString(value) {
                return String(value);
              },
              toNumber: function toNumber(value) {
                return Number(value) || 0;
              }
            };
          }
        }

        // Block implementations
      }, {
        key: "motorStart",
        value: function motorStart(args) {
          var direction = this.getCast().toNumber(args.DIRECTION);
          var ports = this._validatePorts(this.getCast().toString(args.PORT));
          var self = this;
          var promises = ports.map(function (port) {
            var setting = self._peripheral.motorSettings[port];
            return self._peripheral.sendPythonCommand('import hub; hub.port.' + port + '.motor.pwm(' + Math.round(setting.speed * direction) + ')');
          });
          return Promise.all(promises);
        }
      }, {
        key: "motorStop",
        value: function motorStop(args) {
          var ports = this._validatePorts(this.getCast().toString(args.PORT));
          var self = this;
          var promises = ports.map(function (port) {
            return self._peripheral.sendPythonCommand('import hub; hub.port.' + port + '.motor.stop()');
          });
          return Promise.all(promises);
        }
      }, {
        key: "motorSetSpeed",
        value: function motorSetSpeed(args) {
          var speed = this.getCast().toNumber(args.SPEED);
          var ports = this._validatePorts(this.getCast().toString(args.PORT));
          var self = this;
          ports.forEach(function (port) {
            self._peripheral.motorSettings[port].speed = speed;
          });
        }
      }, {
        key: "getPosition",
        value: function getPosition(args) {
          var port = this.getCast().toString(args.PORT).trim().toUpperCase();
          var portData = this._peripheral.portValues[port];
          return portData && portData.position ? portData.position : 0;
        }
      }, {
        key: "displayText",
        value: function displayText(args) {
          var text = this.getCast().toString(args.TEXT);
          var escapedText = text.replace(/"/g, '\\"');
          return this._peripheral.sendPythonCommand('import hub; hub.display.show("' + escapedText + '")');
        }
      }, {
        key: "displayImage",
        value: function displayImage(args) {
          var matrix = this.getCast().toString(args.MATRIX);
          Math.round(9 * this._peripheral.pixelBrightness / 100);
          var symbol = (matrix.replace(/\D/g, '') + '0'.repeat(25)).slice(0, 25);
          var altImage = symbol.replace(/1/g, '9').replace(/0/g, '_').match(/.{5}/g).join(':');
          return this._peripheral.sendPythonCommand('import hub; hub.display.show(hub.Image("' + altImage + '"))');
        }
      }, {
        key: "displayClear",
        value: function displayClear() {
          return this._peripheral.sendPythonCommand('import hub; hub.display.clear()');
        }
      }, {
        key: "getDistance",
        value: function getDistance(args) {
          var port = this.getCast().toString(args.PORT).trim().toUpperCase();
          var portData = this._peripheral.portValues[port];
          return portData && portData.type === 'distance' ? portData.distance : 0;
        }
      }, {
        key: "getColor",
        value: function getColor(args) {
          var port = this.getCast().toString(args.PORT).trim().toUpperCase();
          var portData = this._peripheral.portValues[port];
          if (portData && portData.type === 'color') {
            var colorNames = ['black', 'magenta', 'purple', 'blue', 'azure', 'turquoise', 'green', 'yellow', 'orange', 'red', 'white'];
            return colorNames[portData.color] || 'none';
          }
          return 'none';
        }
      }, {
        key: "getAngle",
        value: function getAngle(args) {
          var axis = this.getCast().toString(args.AXIS);
          return this._peripheral.angle[axis] || 0;
        }
      }, {
        key: "isGesture",
        value: function isGesture(args) {
          var gesture = this.getCast().toString(args.GESTURE);
          return this._peripheral.gestures[gesture] || false;
        }
      }, {
        key: "playBeep",
        value: function playBeep(args) {
          var frequency = this.getCast().toNumber(args.FREQUENCY);
          var duration = this.getCast().toNumber(args.DURATION);
          return this._peripheral.sendPythonCommand('import hub; hub.sound.beep(' + frequency + ', ' + duration + ')');
        }
      }, {
        key: "getBatteryLevel",
        value: function getBatteryLevel() {
          return this._peripheral.battery || 100;
        }
      }, {
        key: "isButtonPressed",
        value: function isButtonPressed(args) {
          var button = this.getCast().toString(args.BUTTON);
          var buttonIndex = {
            left: 0,
            center: 1,
            right: 2
          }[button];
          return buttonIndex !== undefined ? this._peripheral._sensors.buttons[buttonIndex] === 1 : false;
        }
      }, {
        key: "runPythonCommand",
        value: function runPythonCommand(args) {
          var code = this.getCast().toString(args.CODE);
          return this._peripheral.sendPythonCommand(code);
        }
      }, {
        key: "_validatePorts",
        value: function _validatePorts(text) {
          return text.toUpperCase().replace(/[^ABCDEF]/g, '').split('').filter(function (x, i, self) {
            return self.indexOf(x) === i;
          }).sort();
        }
      }], [{
        key: "EXTENSION_ID",
        get: function get() {
          return 'spikeprime';
        }
      }, {
        key: "extensionURL",
        get: function get() {
          return extensionURL;
        },
        set: function set(url) {
          extensionURL = url;
        }
      }]);
    }(BleBaseBlocks); // Extension export for bundling
    var ExtensionClass = Scratch3SpikePrimeBlocks;
    module.exports = ExtensionClass;
    exports.blockClass = ExtensionClass;
  })(_spikeprimeble, _spikeprimeble.exports);
  return _spikeprimeble.exports;
}

require_spikeprimeble();

export { entry };

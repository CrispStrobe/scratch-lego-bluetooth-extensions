var en = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Build with SPIKE Prime or Robot Inventor (legacy v. 2 firmware with bluetooth classic). Supports motors, sensors, lights, and displays.",
	"gui.extension.spikeprime.connectingMessage": "Connecting to SPIKE Prime..."
};
var de = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Baue mit SPIKE Prime or Robot Inventor (alte Firmware Version 2.x). Unterstützt Motoren, Sensoren, Lichter und Displays.",
	"gui.extension.spikeprime.connectingMessage": "Verbinde mit SPIKE Prime..."
};
var fr = {
	"gui.extension.spikeprime.name": "LEGO Education SPIKE Prime",
	"gui.extension.spikeprime.description": "Construisez avec SPIKE Prime ou Robot Inventor (v. 2 firmware). Prend en charge les moteurs, capteurs, lumières et écrans.",
	"gui.extension.spikeprime.connectingMessage": "Connexion à SPIKE Prime..."
};
var translations$1 = {
	en: en,
	de: de,
	fr: fr
};

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAF0CAYAAAD/4EcMAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAACWKADAAQAAAABAAABdAAAAAAO8RAJAAAU8ElEQVR4Ae3YQW5cOQxFUVfDq/H+t2JvpxrIMBN9wY8BJZ6epaEw+ocaXNTr/f3x/vAfAQIECBAgQIBATOC/2CSDCBAgQIAAAQIE/ggILA+BAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECnwgIEPgHAl/vf/CPBP+Jn1dw2IBR9jtgyT6RwJ6AX7D2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBQQWEsiBwgQIECAAAECewICa8/LaQIECBAgQIDAUkBgLYkcIECAAAECBAjsCQisPS+nCRAgQIAAAQJLAYG1JHKAAAECBAgQILAnILD2vJwmQIAAAQIECCwFBNaSyAECBAgQIECAwJ6AwNrzcpoAAQIECBAgsBR4vb8/3stTDhAgQIAAAQIECDwW8AvWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBATWMyenCBAgQIAAAQKPBQTWYyoHCRAgQIAAAQLPBD6fHXOKQFjg6x0eWDzu5/W7f8D3/s6v+m/b757wtPe8p+M0gT8CfsHyEAgQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFjg9f7+eIdnGkeAAAECBAgQGC3gF6zR6/fxBAgQIECAQIWAwKpQNZMAAQIECBAYLSCwRq/fxxMgQIAAAQIVAgKrQtVMAgQIECBAYLSAwBq9fh9PgAABAgQIVAgIrApVMwkQIECAAIHRAgJr9Pp9PAECBAgQIFAhILAqVM0kQIAAAQIERgsIrNHr9/EECBAgQIBAhYDAqlA1kwABAgQIEBgtILBGr9/HEyBAgAABAhUCAqtC1UwCBAgQIEBgtIDAGr1+H0+AAAECBAhUCAisClUzCRAgQIAAgdECAmv0+n08AQIECBAgUCHwWTHUTAJLga/38kirAz+v313H9/7Or/pv2++e8LT3vKfjNIE/An7B8hAIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBYQGCFQY0jQIAAAQIECAgsb4AAAQIECBAgEBYQWGFQ4wgQIECAAAECAssbIECAAAECBAiEBQRWGNQ4AgQIECBAgIDA8gYIECBAgAABAmEBgRUGNY4AAQIECBAgILC8AQIECBAgQIBAWEBghUGNI0CAAAECBAgILG+AAAECBAgQIBAWEFhhUOMIECBAgAABAgLLGyBAgAABAgQIhAUEVhjUOAIECBAgQICAwPIGCBAgQIAAAQJhAYEVBjWOAAECBAgQICCwvAECBAgQIECAQFhAYIVBjSNAgAABAgQICCxvgAABAgQIECAQFhBYYVDjCBAgQIAAAQICyxsgQIAAAQIECIQFBFYY1DgCBAgQIECAgMDyBggQIECAAAECYQGBFQY1jgABAgQIECAgsLwBAgQIECBAgEBY4PX+/niHZxpHgAABAgQIEBgt4Bes0ev38QQIECBAgECFgMCqUDWTAAECBAgQGC0gsEav38cTIECAAAECFQICq0LVTAIECBAgQGC0gMAavX4fT4AAAQIECFQICKwKVTMJECBAgACB0QICa/T6fTwBAgQIECBQISCwKlTNJECAAAECBEYLCKzR6/fxBAgQIECAQIWAwKpQNZMAAQIECBAYLSCwRq/fxxMgQIAAAQIVAgKrQtVMAgQIECBAYLSAwBq9fh9PgAABAgQIVAgIrApVMwkQIECAAIHRAgJr9Pp9PAECBAgQIFAh8Fkx1EwCBP4S+Hr/9T+a//Hn9bsL+t7f+VX/7d/ut/p+5hO4QMAvWBcs0ScQIECAAAECvQQEVq99uA0BAgQIECBwgYDAumCJPoEAAQIECBDoJSCweu3DbQgQIECAAIELBATWBUv0CQQIECBAgEAvAYHVax9uQ4AAAQIECFwgILAuWKJPIECAAAECBHoJCKxe+3AbAgQIECBA4AIBgXXBEn0CAQIECBAg0EtAYPXah9sQIECAAAECFwgIrAuW6BMIECBAgACBXgICq9c+3IYAAQIECBC4QEBgXbBEn0CAAAECBAj0EhBYvfbhNgQIECBAgMAFAgLrgiX6BAIECBAgQKCXgMDqtQ+3IUCAAAECBC4QEFgXLNEnECBAgAABAr0EBFavfbgNAQIECBAgcIGAwLpgiT6BAAECBAgQ6CUgsHrtw20IECBAgACBCwQE1gVL9AkECBAgQIBALwGB1WsfbkOAAAECBAhcICCwLliiTyBAgAABAgR6CQisXvtwGwIECBAgQOACAYF1wRJ9AgECBAgQINBLQGD12ofbECBAgAABAhcICKwLlugTCBAgQIAAgV4CAqvXPtyGAAECBAgQuEBAYF2wRJ9AgAABAgQI9BIQWL324TYECBAgQIDABQIC64Il+gQCBAgQIECgl4DA6rUPtyFAgAABAgQuEBBYFyzRJxAgQIAAAQK9BARWr324DQECBAgQIHCBgMC6YIk+gQABAgQIEOglILB67cNtCBAgQIAAgQsEBNYFS/QJBAgQIECAQC8BgdVrH25DgAABAgQIXCAgsC5Yok8gQIAAAQIEegkIrF77cBsCBAgQIEDgAgGBdcESfQIBAgQIECDQS0Bg9dqH2xAgQIAAAQIXCAisC5boEwgQIECAAIFeAq/398e715XchgABAgQIECBwtoBfsM7en9sTIECAAAECDQUEVsOluBIBAgQIECBwtoDAOnt/bk+AAAECBAg0FBBYDZfiSgQIECBAgMDZAgLr7P25PQECBAgQINBQQGA1XIorESBAgAABAmcLCKyz9+f2BAgQIECAQEMBgdVwKa5EgAABAgQInC0gsM7en9sTIECAAAECDQUEVsOluBIBAgQIECBwtoDAOnt/bk+AAAECBAg0FBBYDZfiSgQIECBAgMDZAgLr7P25PQECBAgQINBQQGA1XIorESBAgAABAmcLCKyz9+f2BAgQIECAQEOBz4Z3ciUCBE4X+Hqf9QU/r7Pu67YECLQX8AtW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCAuu0jbkvAQIECBAg0F5AYLVfkQsSIECAAAECpwkIrNM25r4ECBAgQIBAewGB1X5FLkiAAAECBAicJiCwTtuY+xIgQIAAAQLtBQRW+xW5IAECBAgQIHCagMA6bWPuS4AAAQIECLQXEFjtV+SCBAgQIECAwGkCn6dd2H0JEDhA4Od1wCVdkQABAnUCfsGqszWZAAECBAgQGCogsIYu3mcTIECAAAECdQICq87WZAIECBAgQGCogMAaunifTYAAAQIECNQJCKw6W5MJECBAgACBoQICa+jifTYBAgQIECBQJyCw6mxNJkCAAAECBIYKCKyhi/fZBAgQIECAQJ2AwKqzNZkAAQIECBAYKiCwhi7eZxMgQIAAAQJ1AgKrztZkAgQIECBAYKiAwBq6eJ9NgAABAgQI1AkIrDpbkwkQIECAAIGhAgJr6OJ9NgECBAgQIFAnILDqbE0mQIAAAQIEhgoIrKGL99kECBAgQIBAnYDAqrM1mQABAgQIEBgqILCGLt5nEyBAgAABAnUCAqvO1mQCBAgQIEBgqIDAGrp4n02AAAECBAjUCQisOluTCRAgQIAAgaECAmvo4n02AQIECBAgUCcgsOpsTSZAgAABAgSGCgisoYv32QQIECBAgECdgMCqszWZAAECBAgQGCogsIYu3mcTIECAAAECdQICq87WZAIECBAgQGCogMAaunifTYAAAQIECNQJCKw6W5MJECBAgACBoQICa+jifTYBAgQIECBQJyCw6mxNJkCAAAECBIYKCKyhi/fZBAgQIECAQJ2AwKqzNZkAAQIECBAYKiCwhi7eZxMgQIAAAQJ1AgKrztZkAgQIECBAYKiAwBq6eJ9NgAABAgQI1AkIrDpbkwkQIECAAIGhAgJr6OJ9NgECBAgQIFAnILDqbE0mQIAAAQIEhgoIrKGL99kECBAgQIBAnYDAqrM1mQABAgQIEBgqILCGLt5nEyBAgAABAnUCAqvO1mQCBAgQIEBgqMD/dCwx5rhX9OkAAAAASUVORK5CYII=";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='40px' height='40px' viewBox='0 0 40 40' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3espikeprime-small%3c/title%3e %3cg id='spikeprime-small' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3crect id='body' stroke='%237C87A5' fill='white' x='9.5' y='4.5' width='21' height='31' rx='1.5'%3e%3c/rect%3e %3cg id='matrix' transform='translate(13.000000%2c 12.000000)' fill='%23FFD500'%3e %3crect id='d' x='6' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy' x='9' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-3' x='6' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-2' x='9' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-11' x='0' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-10' x='3' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-9' x='0' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-8' x='3' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-15' x='12' y='3' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-14' x='3' y='9' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-13' x='12' y='6' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-12' x='6' y='12' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-16' x='3' y='0' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-17' x='9' y='0' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-5' x='6' y='9' width='2' height='2'%3e%3c/rect%3e %3crect id='d-copy-4' x='9' y='9' width='2' height='2'%3e%3c/rect%3e %3c/g%3e %3ccircle id='Oval' stroke='%234C97FF' cx='26.5' cy='8.5' r='1.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy' stroke='%237C87A5' cx='20' cy='31' r='2.5'%3e%3c/circle%3e %3c/g%3e%3c/svg%3e";

var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='79px' height='123px' viewBox='0 0 79 123' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3espikeprime-illustration%3c/title%3e %3cg id='spikeprime-illustration' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cg id='Group' transform='translate(1.000000%2c 1.000000)'%3e %3crect id='Rectangle' stroke='%237C87A5' fill='white' x='0' y='0' width='77' height='121' rx='5.5'%3e%3c/rect%3e %3ccircle id='Oval' stroke='%237C87A5' stroke-width='0.5' cx='5.5' cy='5.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy-3' stroke='%237C87A5' stroke-width='0.5' cx='71.5' cy='5.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy' stroke='%237C87A5' stroke-width='0.5' cx='5.5' cy='115.5' r='3.5'%3e%3c/circle%3e %3ccircle id='Oval-Copy-5' stroke='%237C87A5' stroke-width='0.5' cx='71.5' cy='115.5' r='3.5'%3e%3c/circle%3e %3cpath d='M16.5%2c99 C13.4624339%2c99 11%2c101.462434 11%2c104.5 C11%2c107.537566 13.4624339%2c110 16.5%2c110 C38.5%2c110 38.5%2c110 60.5%2c110 C63.5375661%2c110 66%2c107.537566 66%2c104.5 C66%2c101.462434 63.5375661%2c99 60.5%2c99 C38.5%2c99 38.5%2c99 16.5%2c99 Z' id='Path' stroke='%237C87A5' stroke-width='0.5'%3e%3c/path%3e %3ccircle id='Center-Button' stroke='%237C87A5' stroke-width='1.5' fill='white' cx='38.5' cy='104.5' r='10.5'%3e%3c/circle%3e %3ccircle id='Bluetooth' stroke='%234C97FF' stroke-width='1.5' cx='60.5' cy='16.5' r='6.5'%3e%3c/circle%3e %3cg id='matrix' transform='translate(12.000000%2c 34.000000)' fill='%23FFD500'%3e %3crect id='Rectangle-Copy-24' x='0' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-26' x='11' y='0' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-25' x='11' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-29' x='22' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-28' x='33' y='0' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-27' x='33' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-31' x='44' y='11' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-42' x='0' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-40' x='11' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-39' x='11' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-38' x='22' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-37' x='22' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-36' x='33' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-35' x='33' y='33' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-34' x='44' y='22' width='9' height='9'%3e%3c/rect%3e %3crect id='Rectangle-Copy-45' x='22' y='44' width='9' height='9'%3e%3c/rect%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

/**
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.name',
      default: 'LEGO Education SPIKE Prime',
      description: 'Name for the SPIKE Prime extension'
    });
  },
  extensionId: 'spikeprime',
  collaborator: 'CrispStrobe',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.description',
      default: 'Build with SPIKE Prime or Robot Inventor (legacy v. 2 firmware with bluetooth classic). Supports motors, sensors, lights, and displays.',
      description: 'Description for the SPIKE Prime extension'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: true,
  internetConnectionRequired: false,
  launchPeripheralConnectionFlow: true,
  useAutoScan: true,
  connectionIconURL: img,
  connectionSmallIconURL: img$1,
  get connectingMessage() {
    return formatMessage$1({
      id: 'gui.extension.spikeprime.connectingMessage',
      default: 'Connecting to SPIKE Prime (over bluetooth classic SPP)...',
      description: 'Message shown when connecting to SPIKE Prime'
    });
  },
  helpLink: 'https://education.lego.com/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = true,
      o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = true, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var ArgumentType = require('../../extension-support/argument-type');
var BlockType = require('../../extension-support/block-type');
var Cast = require('../../util/cast');
var BT = require('../../io/bt');
var Base64Util = require('../../util/base64-util');
var MathUtil = require('../../util/math-util');
var RateLimiter = require('../../util/rateLimiter.js');
require('./lib/color');
var translations = {
  "en": {
    "spikeprime.title": "SPIKE Prime Ultimate",
    "spikeprime.setMovementMotors": "set movement motors [PORT_A] and [PORT_B]",
    "spikeprime.moveForward": "move [DIRECTION] for [VALUE] [UNIT]",
    "spikeprime.steer": "start steering [STEERING]",
    "spikeprime.startTank": "start tank drive left [LEFT_SPEED] right [RIGHT_SPEED]",
    "spikeprime.setMovementSpeed": "set movement speed to [SPEED]%",
    "spikeprime.stopMovement": "stop movement",
    "spikeprime.motorRunFor": "[PORT] run [DIRECTION] for [VALUE] [UNIT]",
    "spikeprime.motorRunToPosition": "[PORT] run to position [POSITION] degrees",
    "spikeprime.motorStart": "[PORT] start motor [DIRECTION]",
    "spikeprime.motorStop": "[PORT] stop motor",
    "spikeprime.motorSetSpeed": "[PORT] set speed to [SPEED] %",
    "spikeprime.motorSetStopAction": "[PORT] set stop action to [ACTION]",
    "spikeprime.getPosition": "[PORT] position",
    "spikeprime.getRelativePosition": "[PORT] relative position",
    "spikeprime.getAbsolutePosition": "[PORT] absolute position",
    "spikeprime.getSpeed": "[PORT] speed (deg/s)",
    "spikeprime.resetMotorPosition": "reset [PORT] motor position to [POSITION]",
    "spikeprime.displayText": "write [TEXT]",
    "spikeprime.displayImage": "turn on [MATRIX]",
    "spikeprime.displayPattern": "display pattern [PATTERN]",
    "spikeprime.displayClear": "turn off pixels",
    "spikeprime.setPixel": "set pixel [X] [Y] to [BRIGHTNESS] %",
    "spikeprime.rotateDisplay": "rotate display [ANGLE] degrees",
    "spikeprime.setCenterButtonColor": "set center button to [COLOR]",
    "spikeprime.getAngle": "[AXIS] angle",
    "spikeprime.getGyroRate": "gyro rate [AXIS] (deg/s)",
    "spikeprime.getFilteredGyroRate": "filtered gyro rate [AXIS] (deg/s)",
    "spikeprime.getAcceleration": "acceleration [AXIS] (milli-g)",
    "spikeprime.getFilteredAcceleration": "filtered acceleration [AXIS] (milli-g)",
    "spikeprime.resetYaw": "reset yaw angle",
    "spikeprime.presetYaw": "preset yaw to [ANGLE] degrees",
    "spikeprime.setMatrix3x3ColorGrid": "set [PORT] 3x3 colors: [P1][P2][P3] [P4][P5][P6] [P7][P8][P9]",
    "spikeprime.setMatrix3x3BrightnessGrid": "set [PORT] 3x3 brightness: [B1][B2][B3] [B4][B5][B6] [B7][B8][B9]",
    "spikeprime.setMatrix3x3PixelEmoji": "set [PORT] 3x3 pixel [X],[Y] to [COLOR] brightness [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Custom": "set [PORT] 3x3 custom pattern [PATTERN]",
    "spikeprime.generateMatrix3x3Code": "generate 3x3 code for pattern [PATTERN]",
    "spikeprime.setMatrix3x3SolidColor": "set [PORT] 3x3 matrix all [COLOR] brightness [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Level": "set [PORT] 3x3 battery level to [LEVEL]",
    "spikeprime.setMatrix3x3Transition": "set [PORT] 3x3 transition [EFFECT]",
    "spikeprime.clearMatrix3x3": "clear [PORT] 3x3 matrix",
    "spikeprime.whenGesture": "when hub [GESTURE]",
    "spikeprime.isGesture": "hub [GESTURE]?",
    "spikeprime.getOrientation": "orientation",
    "spikeprime.playHubSound": "play hub sound [SOUND]",
    "spikeprime.playBeep": "beep [FREQUENCY] Hz for [DURATION] ms",
    "spikeprime.playNote": "play note [NOTE] for [SECS] seconds",
    "spikeprime.playWaveBeep": "beep [WAVEFORM] [FREQUENCY] Hz for [DURATION] ms",
    "spikeprime.setVolume": "set volume to [VOLUME]%",
    "spikeprime.stopSound": "stop all sounds",
    "spikeprime.getBatteryLevel": "battery level %",
    "spikeprime.getBatteryTemperature": "battery temperature",
    "spikeprime.getHubTemperature": "hub temperature",
    "spikeprime.getTimer": "timer",
    "spikeprime.resetTimer": "reset timer",
    "spikeprime.getDistance": "[PORT] distance",
    "spikeprime.setDistanceLights": "set [PORT] distance lights [TL] [TR] [BL] [BR]",
    "spikeprime.getColor": "[PORT] color",
    "spikeprime.getReflection": "[PORT] reflection",
    "spikeprime.getAmbientLight": "[PORT] ambient light",
    "spikeprime.getForce": "[PORT] force",
    "spikeprime.isForceSensorPressed": "[PORT] force sensor pressed?",
    "spikeprime.whenColor": "when [PORT] sees [COLOR]",
    "spikeprime.isColor": "[PORT] sees [COLOR]?",
    "spikeprime.whenForceSensor": "when [PORT] is [STATE]",
    "spikeprime.isButtonPressed": "[BUTTON] button pressed?",
    "spikeprime.whenButtonPressed": "when [BUTTON] button pressed",
    "spikeprime.runReplCommand": "run Python REPL: [CODE]",
    "spikeprime.getReplOutput": "REPL output",
    "spikeprime.clearReplOutput": "clear REPL output",
    "spikeprime.getReplHistory": "REPL command [INDEX]",
    "spikeprime.runPythonCommand": "run Python: [CODE]",
    "spikeprime.runHubCommand": "run hub command: [CODE]",
    "spikeprime.exitScript": "exit Python script"
  },
  "de": {
    "spikeprime.title": "SPIKE Prime Ultimate",
    "spikeprime.setMovementMotors": "setze Bewegungsmotoren [PORT_A] und [PORT_B]",
    "spikeprime.moveForward": "bewege [DIRECTION] für [VALUE] [UNIT]",
    "spikeprime.steer": "starte Lenkung [STEERING]",
    "spikeprime.startTank": "starte Panzerfahrt links [LEFT_SPEED] rechts [RIGHT_SPEED]",
    "spikeprime.setMovementSpeed": "setze Bewegungsgeschwindigkeit auf [SPEED]%",
    "spikeprime.stopMovement": "stoppe Bewegung",
    "spikeprime.motorRunFor": "[PORT] drehe [DIRECTION] für [VALUE] [UNIT]",
    "spikeprime.motorRunToPosition": "[PORT] drehe zu Position [POSITION] Grad",
    "spikeprime.motorStart": "[PORT] starte Motor [DIRECTION]",
    "spikeprime.motorStop": "[PORT] stoppe Motor",
    "spikeprime.motorSetSpeed": "[PORT] setze Geschwindigkeit auf [SPEED] %",
    "spikeprime.motorSetStopAction": "[PORT] setze Stopp-Aktion auf [ACTION]",
    "spikeprime.getPosition": "[PORT] Position",
    "spikeprime.getRelativePosition": "[PORT] relative Position",
    "spikeprime.getAbsolutePosition": "[PORT] absolute Position",
    "spikeprime.getSpeed": "[PORT] Geschwindigkeit (Grad/s)",
    "spikeprime.resetMotorPosition": "setze [PORT] Motorposition auf [POSITION] zurück",
    "spikeprime.displayText": "schreibe [TEXT]",
    "spikeprime.displayImage": "schalte [MATRIX] ein",
    "spikeprime.displayPattern": "zeige Muster [PATTERN]",
    "spikeprime.displayClear": "schalte Pixel aus",
    "spikeprime.setPixel": "setze Pixel [X] [Y] auf [BRIGHTNESS] %",
    "spikeprime.rotateDisplay": "drehe Display [ANGLE] Grad",
    "spikeprime.setCenterButtonColor": "setze mittleren Knopf auf [COLOR]",
    "spikeprime.getAngle": "[AXIS] Winkel",
    "spikeprime.getGyroRate": "Gyroskop-Rate [AXIS] (Grad/s)",
    "spikeprime.getFilteredGyroRate": "gefilterte Gyroskop-Rate [AXIS] (Grad/s)",
    "spikeprime.getAcceleration": "Beschleunigung [AXIS] (Milli-g)",
    "spikeprime.getFilteredAcceleration": "gefilterte Beschleunigung [AXIS] (Milli-g)",
    "spikeprime.resetYaw": "setze Gier-Winkel zurück",
    "spikeprime.presetYaw": "setze Gier-Winkel auf [ANGLE] Grad",
    "spikeprime.setMatrix3x3ColorGrid": "setze [PORT] 3x3 Farben: [P1][P2][P3] [P4][P5][P6] [P7][P8][P9]",
    "spikeprime.setMatrix3x3BrightnessGrid": "setze [PORT] 3x3 Helligkeit: [B1][B2][B3] [B4][B5][B6] [B7][B8][B9]",
    "spikeprime.setMatrix3x3PixelEmoji": "setze [PORT] 3x3 Pixel [X],[Y] auf [COLOR] Helligkeit [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Custom": "setze [PORT] 3x3 benutzerdefiniertes Muster [PATTERN]",
    "spikeprime.generateMatrix3x3Code": "generiere 3x3 Code für Muster [PATTERN]",
    "spikeprime.setMatrix3x3SolidColor": "setze [PORT] 3x3 Matrix alle [COLOR] Helligkeit [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Level": "setze [PORT] 3x3 Batteriestand auf [LEVEL]",
    "spikeprime.setMatrix3x3Transition": "setze [PORT] 3x3 Übergang [EFFECT]",
    "spikeprime.clearMatrix3x3": "lösche [PORT] 3x3 Matrix",
    "spikeprime.whenGesture": "wenn Hub [GESTURE]",
    "spikeprime.isGesture": "Hub [GESTURE]?",
    "spikeprime.getOrientation": "Ausrichtung",
    "spikeprime.playHubSound": "spiele Hub-Sound [SOUND]",
    "spikeprime.playBeep": "piepse [FREQUENCY] Hz für [DURATION] ms",
    "spikeprime.playNote": "spiele Note [NOTE] für [SECS] Sekunden",
    "spikeprime.playWaveBeep": "piepse [WAVEFORM] [FREQUENCY] Hz für [DURATION] ms",
    "spikeprime.setVolume": "setze Lautstärke auf [VOLUME]%",
    "spikeprime.stopSound": "stoppe alle Sounds",
    "spikeprime.getBatteryLevel": "Batteriestand %",
    "spikeprime.getBatteryTemperature": "Batterietemperatur",
    "spikeprime.getHubTemperature": "Hub-Temperatur",
    "spikeprime.getTimer": "Timer",
    "spikeprime.resetTimer": "setze Timer zurück",
    "spikeprime.getDistance": "[PORT] Entfernung",
    "spikeprime.setDistanceLights": "setze [PORT] Entfernungslichter [TL] [TR] [BL] [BR]",
    "spikeprime.getColor": "[PORT] Farbe",
    "spikeprime.getReflection": "[PORT] Reflexion",
    "spikeprime.getAmbientLight": "[PORT] Umgebungslicht",
    "spikeprime.getForce": "[PORT] Kraft",
    "spikeprime.isForceSensorPressed": "[PORT] Kraftsensor gedrückt?",
    "spikeprime.whenColor": "wenn [PORT] sieht [COLOR]",
    "spikeprime.isColor": "[PORT] sieht [COLOR]?",
    "spikeprime.whenForceSensor": "wenn [PORT] ist [STATE]",
    "spikeprime.isButtonPressed": "[BUTTON] Knopf gedrückt?",
    "spikeprime.whenButtonPressed": "wenn [BUTTON] Knopf gedrückt",
    "spikeprime.runReplCommand": "führe Python REPL aus: [CODE]",
    "spikeprime.getReplOutput": "REPL Ausgabe",
    "spikeprime.clearReplOutput": "lösche REPL Ausgabe",
    "spikeprime.getReplHistory": "REPL Befehl [INDEX]",
    "spikeprime.runPythonCommand": "führe Python aus: [CODE]",
    "spikeprime.runHubCommand": "führe Hub-Befehl aus: [CODE]",
    "spikeprime.exitScript": "beende Python-Skript",
    "spikeprime.menu.direction.forward": "vorwärts",
    "spikeprime.menu.direction.backward": "rückwärts",
    "spikeprime.menu.moveUnit.cm": "cm",
    "spikeprime.menu.moveUnit.in": "Zoll",
    "spikeprime.menu.moveUnit.rotations": "Umdrehungen",
    "spikeprime.menu.moveUnit.degrees": "Grad",
    "spikeprime.menu.moveUnit.seconds": "Sekunden",
    "spikeprime.menu.stopAction.coast": "ausrollen",
    "spikeprime.menu.stopAction.brake": "bremsen",
    "spikeprime.menu.stopAction.hold": "halten",
    "spikeprime.menu.color.red": "rot",
    "spikeprime.menu.color.green": "grün",
    "spikeprime.menu.color.blue": "blau",
    "spikeprime.menu.color.yellow": "gelb",
    "spikeprime.menu.color.cyan": "cyan",
    "spikeprime.menu.color.magenta": "magenta",
    "spikeprime.menu.color.white": "weiß",
    "spikeprime.menu.color.black": "schwarz",
    "spikeprime.menu.forceState.pressed": "gedrückt",
    "spikeprime.menu.forceState.hardPressed": "fest gedrückt",
    "spikeprime.menu.forceState.released": "losgelassen",
    "spikeprime.menu.button.left": "links",
    "spikeprime.menu.button.center": "mitte",
    "spikeprime.menu.button.right": "rechts",
    "spikeprime.menu.button.connect": "verbinden",
    "spikeprime.menu.gesture.tapped": "angetippt",
    "spikeprime.menu.gesture.doubletapped": "doppelt angetippt",
    "spikeprime.menu.gesture.shake": "geschüttelt",
    "spikeprime.menu.gesture.freefall": "freier Fall",
    "spikeprime.menu.waveform.sin": "Sinus",
    "spikeprime.menu.waveform.square": "Rechteck",
    "spikeprime.menu.waveform.triangle": "Dreieck",
    "spikeprime.menu.waveform.sawtooth": "Sägezahn"
  },
  "fr": {
    "spikeprime.title": "SPIKE Prime Ultimate",
    "spikeprime.setMovementMotors": "définir moteurs de mouvement [PORT_A] et [PORT_B]",
    "spikeprime.moveForward": "avancer [DIRECTION] pendant [VALUE] [UNIT]",
    "spikeprime.steer": "commencer direction [STEERING]",
    "spikeprime.startTank": "commencer conduite chenilles gauche [LEFT_SPEED] droite [RIGHT_SPEED]",
    "spikeprime.setMovementSpeed": "définir vitesse de mouvement à [SPEED]%",
    "spikeprime.stopMovement": "arrêter mouvement",
    "spikeprime.motorRunFor": "[PORT] tourner [DIRECTION] pendant [VALUE] [UNIT]",
    "spikeprime.motorRunToPosition": "[PORT] tourner à position [POSITION] degrés",
    "spikeprime.motorStart": "[PORT] démarrer moteur [DIRECTION]",
    "spikeprime.motorStop": "[PORT] arrêter moteur",
    "spikeprime.motorSetSpeed": "[PORT] définir vitesse à [SPEED] %",
    "spikeprime.motorSetStopAction": "[PORT] définir action d'arrêt à [ACTION]",
    "spikeprime.getPosition": "[PORT] position",
    "spikeprime.getRelativePosition": "[PORT] position relative",
    "spikeprime.getAbsolutePosition": "[PORT] position absolue",
    "spikeprime.getSpeed": "[PORT] vitesse (deg/s)",
    "spikeprime.resetMotorPosition": "remettre position moteur [PORT] à [POSITION]",
    "spikeprime.displayText": "écrire [TEXT]",
    "spikeprime.displayImage": "allumer [MATRIX]",
    "spikeprime.displayPattern": "afficher motif [PATTERN]",
    "spikeprime.displayClear": "éteindre pixels",
    "spikeprime.setPixel": "définir pixel [X] [Y] à [BRIGHTNESS] %",
    "spikeprime.rotateDisplay": "tourner affichage [ANGLE] degrés",
    "spikeprime.setCenterButtonColor": "définir bouton central à [COLOR]",
    "spikeprime.getAngle": "angle [AXIS]",
    "spikeprime.getGyroRate": "taux gyroscope [AXIS] (deg/s)",
    "spikeprime.getFilteredGyroRate": "taux gyroscope filtré [AXIS] (deg/s)",
    "spikeprime.getAcceleration": "accélération [AXIS] (milli-g)",
    "spikeprime.getFilteredAcceleration": "accélération filtrée [AXIS] (milli-g)",
    "spikeprime.resetYaw": "remettre angle de lacet",
    "spikeprime.presetYaw": "prédéfinir lacet à [ANGLE] degrés",
    "spikeprime.setMatrix3x3ColorGrid": "définir [PORT] 3x3 couleurs: [P1][P2][P3] [P4][P5][P6] [P7][P8][P9]",
    "spikeprime.setMatrix3x3BrightnessGrid": "définir [PORT] 3x3 luminosité: [B1][B2][B3] [B4][B5][B6] [B7][B8][B9]",
    "spikeprime.setMatrix3x3PixelEmoji": "définir [PORT] 3x3 pixel [X],[Y] à [COLOR] luminosité [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Custom": "définir [PORT] 3x3 motif personnalisé [PATTERN]",
    "spikeprime.generateMatrix3x3Code": "générer code 3x3 pour motif [PATTERN]",
    "spikeprime.setMatrix3x3SolidColor": "définir [PORT] 3x3 matrice tout [COLOR] luminosité [BRIGHTNESS]",
    "spikeprime.setMatrix3x3Level": "définir [PORT] 3x3 niveau batterie à [LEVEL]",
    "spikeprime.setMatrix3x3Transition": "définir [PORT] 3x3 transition [EFFECT]",
    "spikeprime.clearMatrix3x3": "effacer [PORT] 3x3 matrice",
    "spikeprime.whenGesture": "quand hub [GESTURE]",
    "spikeprime.isGesture": "hub [GESTURE]?",
    "spikeprime.getOrientation": "orientation",
    "spikeprime.playHubSound": "jouer son hub [SOUND]",
    "spikeprime.playBeep": "biper [FREQUENCY] Hz pendant [DURATION] ms",
    "spikeprime.playNote": "jouer note [NOTE] pendant [SECS] secondes",
    "spikeprime.playWaveBeep": "biper [WAVEFORM] [FREQUENCY] Hz pendant [DURATION] ms",
    "spikeprime.setVolume": "définir volume à [VOLUME]%",
    "spikeprime.stopSound": "arrêter tous les sons",
    "spikeprime.getBatteryLevel": "niveau batterie %",
    "spikeprime.getBatteryTemperature": "température batterie",
    "spikeprime.getHubTemperature": "température hub",
    "spikeprime.getTimer": "minuteur",
    "spikeprime.resetTimer": "remettre minuteur",
    "spikeprime.getDistance": "[PORT] distance",
    "spikeprime.setDistanceLights": "définir [PORT] lumières distance [TL] [TR] [BL] [BR]",
    "spikeprime.getColor": "[PORT] couleur",
    "spikeprime.getReflection": "[PORT] réflexion",
    "spikeprime.getAmbientLight": "[PORT] lumière ambiante",
    "spikeprime.getForce": "[PORT] force",
    "spikeprime.isForceSensorPressed": "[PORT] capteur force pressé?",
    "spikeprime.whenColor": "quand [PORT] voit [COLOR]",
    "spikeprime.isColor": "[PORT] voit [COLOR]?",
    "spikeprime.whenForceSensor": "quand [PORT] est [STATE]",
    "spikeprime.isButtonPressed": "bouton [BUTTON] pressé?",
    "spikeprime.whenButtonPressed": "quand bouton [BUTTON] pressé",
    "spikeprime.runReplCommand": "exécuter Python REPL: [CODE]",
    "spikeprime.getReplOutput": "sortie REPL",
    "spikeprime.clearReplOutput": "effacer sortie REPL",
    "spikeprime.getReplHistory": "commande REPL [INDEX]",
    "spikeprime.runPythonCommand": "exécuter Python: [CODE]",
    "spikeprime.runHubCommand": "exécuter commande hub: [CODE]",
    "spikeprime.exitScript": "quitter script Python"
  }
};
// note: This extension supports LEGO Education SPIKE Prime Hub / Robot Inventor Hub
// with v. 2 firmware (legacy), which usese bluetooth classic (not ble)!
// you can switch firmwares by running *upgrade* from spike prime app (then you must use another extension which supports ble),
// or *downgrade* https://spikelegacy.legoeducation.com/hubdowngrade/#step-1
// or you can use dfu-utils to exchange firmware to a v.2.x one: https://github.com/gpdaniels/spike-prime/
// so that you can use *this* (bluetooth classic) extension here
var blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAUKADAAQAAAABAAAAUAAAAAASKG51AAAEUUlEQVR4Ae2cTWgTURDHZxORatUeFLUeqtaThSDFHopQ1HoQhB4LigjWq3pTEbUXK+LHUb2qICrYkwiCF7UUpYdq0UA9iFVbaFXqoWq1CMm6/022SZNsnsmb3X2kM7Dp5s17k5lf5r15KewjEhECQkAICAEhIASEgBBYjAQs7qB7r9zvoLR90rbtNsd2I7f9Ku1NWZY1TDHrat+pA4NV2ig5jBVg76W7Z2yyLpBts9ot6XkVjY5TabKot+/0wYtVDC85hC1QN/NS6efxeDzW2ZGg1kQzraivK/mhYTf+mp2jkeQYPR1MUiqVSlM8tosrE2NswWDaErnwOtpbjIGH+PBFwid8sfARSwxX3GwAs2uem3lcznHbwayAeL5y2F/CYSRrwy0YUU3b77NEt4aIkpMZbxIbiHraiVbX5yLM842tuHECzHka8h3gHe8n+jmX++CB90SvJ4iudS+EmOvBc8c2hXncqc4KMg/w2pqIbh/KXLhHG3RBSk0A9KbtsZ2ZbMO0xT3E02Xe8b/WBEB+LP9vsSYAomBArg8QYT3EhXuIp8u843+tiSKCaouCMTxOdPhODtJKZx8PXZBSEwCx5qHaqrYxQYCsCYAAA4gn9gSBqLzNmlgDy4cYrFYAavKNfgqPFvxDqMX5uV9OKu1fzhaDTjJQE6IAFICaBDSHR78Gqta8wgAr7V84nvm9TGFNoOFloF/1DLpdE5BquGSgipBCLwAVgFRqAagipNCHtwb6Vc+g2xUAdNWSgZoEw8vAoKutn31NQKrhkoEqQgq9AFQAUqkFoIqQQh/eGhh0tfWzrwCgq5YM1CQYXgb6OepXPStt97MfcLtkoCZgASgANQloDo9+DfSrnpW2a4KodrhM4WrJZcdFn4F+AfhVYb/+EbVLBmqCF4ACUJOA5nBz10C/KqwZMPdwmcKaRAWgANQkoDncyDXw1ZsPhOvb9Iwb3to1DbR92xb30oyXfbhRAPFYav+jlzT26cuCQCcmpwnX23efqbtrh1FPghoF0IPXsGo57d3dSpub1rkgP45/pSfPRlyw6NOzv3MB4CjfGFNEMGWReYB39Mg+Smzd6GYanrDEPdqgQx/0NUWMAggoyLxldUuL+KANOogALMJD8wXDm7YlusxPaa+4lOoTdpsxGRh24FyfZwxAbFUgKBh+4um8vn79wmw3BiD2eRBU2z9zf4sYoA06iNe3qFMEDUYBbN60nmZ+/KYbNx9T0tnzYV+IC/dogw59TAJo1D4Qm2RvL/jg4YuifAI89DFJOAFOOYE1ImPyTseoKFaMwyYZ2xRcXrXl+ikH37ICX1mEDSDOpnLOY+nCCUE45EZHgvrdC98g7jlaOg7mjeVbA52DvZzHBtM4XmlwaNRdu/I+J9JbZB58gm/wEYeQcTlU8Kikntlzl++dtdL2efd4JT1TgYx24Zl6+JgX8WI7/s6LW/4KASEgBISAEBACQkAILC4C/wDBL1fytvgQdgAAAABJRU5ErkJggg==';
var formatMessage = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var extensionURL = 'https://cdn.jsdelivr.net/gh/CrispStrobe/scratch-lego-bluetooth-extensions@master/dist/spikeprime_btc.mjs';
// Translation setup function
var setupTranslations = function setupTranslations() {
  try {
    var localeSetup = formatMessage.setup();
    if (localeSetup && localeSetup.translations && localeSetup.translations[localeSetup.locale]) {
      Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
    }
  } catch (e) {
    // Fails silently, which is fine.
  }
};
var BTSendRateMax = 40;
var SpikePorts = ['A', 'B', 'C', 'D', 'E', 'F'];
var SpikeMotorStopMode = {
  brake: 1};
var SpikeOrientation = {
  front: 1,
  back: 2,
  up: 3,
  down: 4,
  rightside: 5,
  leftside: 6
};
// Built-in sound files
var HubSoundFiles = ['menu_click', 'menu_fastback', 'menu_program_start', 'menu_program_stop', 'menu_shutdown', 'startup'];
var ColorEmojiMap = {
  '⚫': 0,
  // off
  '🟣': 1,
  // magenta
  '🟪': 2,
  // violet
  '🔵': 3,
  // blue
  '🔷': 4,
  // turquoise
  '🟢': 5,
  // mint
  '🟩': 6,
  // green
  '🟡': 7,
  // yellow
  '🟠': 8,
  // orange
  '🔴': 9,
  // red
  '⚪': 10 // white
};
// Display patterns as matrices
var DisplayPatterns = {
  heart: '960000960960a60960960000960',
  smile: '760076000078000076000760',
  sad: '760076000087600076000760',
  angry: '970079000087600079000970',
  surprised: '760076000999900076000760',
  wink: '760070000078000076000760',
  arrow_up: '060060060686060606000000',
  arrow_down: '000060606068606060606000',
  arrow_left: '000060068006000060000000',
  arrow_right: '000600000680600060000000',
  check: '000000080000806080000000',
  x: '970000970000090000970000970',
  square: '979797900009900099000979797',
  triangle: '060060606996999999600000',
  diamond: '060060606906906060000600',
  plus: '060000600999996060000600',
  minus: '000000000999999000000000',
  dot: '000000000000a00000000000000',
  frame: '979797900009900099000979797',
  spiral: '979797060000900009000979797'
};
// LED colors for center button
var CenterLEDColors = {
  OFF: 0,
  PINK: 1,
  PURPLE: 2,
  BLUE: 3,
  TEAL: 4,
  GREEN: 5,
  LIME: 6,
  YELLOW: 7,
  ORANGE: 8,
  RED: 9,
  WHITE: 10,
  GREY: 11
};
// Sound waveforms
var SoundWaveforms = {
  sin: 'hub.sound.SOUND_SIN',
  square: 'hub.sound.SOUND_SQUARE',
  triangle: 'hub.sound.SOUND_TRIANGLE',
  sawtooth: 'hub.sound.SOUND_SAWTOOTH'
};
// [SpikePrime class and SpikeMotorSetting class implementations remain unchanged - omitted for brevity]
var SpikeMotorSetting = /*#__PURE__*/function () {
  function SpikeMotorSetting() {
    _classCallCheck(this, SpikeMotorSetting);
    this._speed = 75;
    this._stopMode = SpikeMotorStopMode.brake;
    this._stallDetection = true;
  }
  return _createClass(SpikeMotorSetting, [{
    key: "speed",
    get: function get() {
      return this._speed;
    },
    set: function set(value) {
      this._speed = MathUtil.clamp(value, -100, 100);
    }
  }, {
    key: "stopMode",
    get: function get() {
      return this._stopMode;
    },
    set: function set(value) {
      if (value >= 0 && value <= 2) this._stopMode = value;
    }
  }, {
    key: "stallDetection",
    get: function get() {
      return this._stallDetection;
    },
    set: function set(value) {
      this._stallDetection = value;
    }
  }]);
}();
var SpikePrime = /*#__PURE__*/function () {
  function SpikePrime(runtime, extensionId) {
    var _this = this;
    _classCallCheck(this, SpikePrime);
    this._runtime = runtime;
    this._extensionId = extensionId;
    this._remainingText = '';
    this._sensors = {
      buttons: [0, 0, 0, 0],
      angle: {
        pitch: 0,
        roll: 0,
        yaw: 0
      },
      acceleration: {
        x: 0,
        y: 0,
        z: 0
      },
      accelerationFiltered: {
        x: 0,
        y: 0,
        z: 0
      },
      gyro: {
        x: 0,
        y: 0,
        z: 0
      },
      gyroFiltered: {
        x: 0,
        y: 0,
        z: 0
      },
      orientation: SpikeOrientation.front,
      battery: 100,
      temperature: 25,
      hubTemp: 25,
      gestures: {
        tapped: false,
        doubletapped: false,
        shake: false,
        freefall: false
      },
      hubStatus: {},
      motorPositions: {},
      buttonTiming: {}
    };
    this._portValues = {};
    this._pixelBrightness = 100;
    this._motorSettings = {
      A: new SpikeMotorSetting(),
      B: new SpikeMotorSetting(),
      C: new SpikeMotorSetting(),
      D: new SpikeMotorSetting(),
      E: new SpikeMotorSetting(),
      F: new SpikeMotorSetting()
    };
    // Movement motor pair and timer functionality
    this._movementMotors = ['A', 'B'];
    this._timer = {
      start: Date.now(),
      current: 0
    };
    this._volume = 100;
    // REPL functionality
    this._replHistory = [];
    this._replVariables = {};
    this._replOutput = '';
    this._bt = null;
    this._runtime.registerPeripheralExtension(extensionId, this);
    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
    this._rateLimiter = new RateLimiter(BTSendRateMax);
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._openRequests = {};
    this._pythonAvailable = false;
    this._sensorLoopRunning = false;
    // Update timer every 10ms
    setInterval(function () {
      _this._timer.current = (Date.now() - _this._timer.start) / 1000;
    }, 10);
  }
  // Getters
  return _createClass(SpikePrime, [{
    key: "angle",
    get: function get() {
      return this._sensors.angle;
    }
  }, {
    key: "orientation",
    get: function get() {
      return this._sensors.orientation;
    }
  }, {
    key: "portValues",
    get: function get() {
      return this._portValues;
    }
  }, {
    key: "pixelBrightness",
    get: function get() {
      return this._pixelBrightness;
    },
    set: function set(value) {
      this._pixelBrightness = value;
    }
  }, {
    key: "motorSettings",
    get: function get() {
      return this._motorSettings;
    }
  }, {
    key: "acceleration",
    get: function get() {
      return this._sensors.acceleration;
    }
  }, {
    key: "accelerationFiltered",
    get: function get() {
      return this._sensors.accelerationFiltered;
    }
  }, {
    key: "gyro",
    get: function get() {
      return this._sensors.gyro;
    }
  }, {
    key: "gyroFiltered",
    get: function get() {
      return this._sensors.gyroFiltered;
    }
  }, {
    key: "battery",
    get: function get() {
      return this._sensors.battery;
    }
  }, {
    key: "temperature",
    get: function get() {
      return this._sensors.temperature;
    }
  }, {
    key: "hubTemp",
    get: function get() {
      return this._sensors.hubTemp;
    }
  }, {
    key: "gestures",
    get: function get() {
      return this._sensors.gestures;
    }
  }, {
    key: "movementMotors",
    get: function get() {
      return this._movementMotors;
    }
  }, {
    key: "timer",
    get: function get() {
      return this._timer.current;
    }
  }, {
    key: "volume",
    get: function get() {
      return this._volume;
    }
  }, {
    key: "replOutput",
    get: function get() {
      return this._replOutput;
    }
  }, {
    key: "replHistory",
    get: function get() {
      return this._replHistory;
    }
  }, {
    key: "beep",
    value: function beep(freq, time) {
      //console.log(`freq: ${freq}, time: ${time}`);
    }
  }, {
    key: "stopAll",
    value: function stopAll() {
      this.stopAllMotors();
      this.stopSound();
    }
  }, {
    key: "stopSound",
    value: function stopSound() {
      this.sendPythonCommand('import hub; hub.sound.stop()');
    }
  }, {
    key: "stopAllMotors",
    value: function stopAllMotors() {
      this.sendPythonCommand('import hub; [hub.port[p].motor.stop() for p in "ABCDEF" if hasattr(hub.port[p], "motor")]');
    }
  }, {
    key: "scan",
    value: function scan() {
      if (this._bt) {
        this._bt.disconnect();
      }
      this._bt = new BT(this._runtime, this._extensionId, {
        majorDeviceClass: 8,
        minorDeviceClass: 1
      }, this._onConnect, this.reset, this._onMessage);
    }
  }, {
    key: "connect",
    value: function connect(id) {
      if (this._bt) {
        this._bt.connectPeripheral(id);
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._bt) {
        this._bt.disconnect();
      }
      this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      this._remainingText = '';
      this._sensors = {
        buttons: [0, 0, 0, 0],
        angle: {
          pitch: 0,
          roll: 0,
          yaw: 0
        },
        acceleration: {
          x: 0,
          y: 0,
          z: 0
        },
        accelerationFiltered: {
          x: 0,
          y: 0,
          z: 0
        },
        gyro: {
          x: 0,
          y: 0,
          z: 0
        },
        gyroFiltered: {
          x: 0,
          y: 0,
          z: 0
        },
        orientation: SpikeOrientation.front,
        battery: 100,
        temperature: 25,
        hubTemp: 25,
        gestures: {
          tapped: false,
          doubletapped: false,
          shake: false,
          freefall: false
        },
        hubStatus: {},
        motorPositions: {},
        buttonTiming: {}
      };
      this._portValues = {};
      this._pythonAvailable = false;
      this._sensorLoopRunning = false;
      // Reset timer and REPL
      this._timer.start = Date.now();
      this._timer.current = 0;
      this._replOutput = '';
      this._replHistory = [];
      this._replVariables = {};
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      var connected = false;
      if (this._bt) {
        connected = this._bt.isConnected();
      }
      return connected;
    }
    // Sends a JSON-RPC command (for built-in functions)
  }, {
    key: "sendJSON",
    value: function sendJSON(json) {
      var useLimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var jsonText = JSON.stringify(json);
      return this.sendRaw("".concat(jsonText, "\r"), useLimiter, json.i);
    }
    // Sends a raw string (for Python REPL commands)
  }, {
    key: "sendRaw",
    value: function sendRaw(text) {
      var _this2 = this;
      var useLimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (!this.isConnected()) return Promise.resolve();
      if (useLimiter) {
        if (!this._rateLimiter.okayToSend()) return Promise.resolve();
      }
      if (!id) {
        return this._bt.sendMessage({
          message: text
        });
      }
      var promise = new Promise(function (resolve, reject) {
        _this2._openRequests[id] = {
          resolve: resolve,
          reject: reject
        };
      });
      this._bt.sendMessage({
        message: text
      });
      return promise;
    }
  }, {
    key: "sendCommand",
    value: function sendCommand(method, params) {
      var needsResponse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (needsResponse) {
        var id = Math.random().toString(36).slice(-4);
        return this.sendJSON({
          i: id,
          m: method,
          p: params
        });
      }
      return this.sendJSON({
        m: method,
        p: params
      });
    }
    // Send raw Python code to the REPL
  }, {
    key: "sendPythonCommand",
    value: function sendPythonCommand(pythonCode) {
      return this.sendRaw("".concat(pythonCode, "\r\n"));
    }
    // REPL-specific command that captures output
  }, {
    key: "sendReplCommand",
    value: function sendReplCommand(pythonCode) {
      this._replHistory.push(pythonCode);
      if (this._replHistory.length > 50) {
        this._replHistory.shift(); // Keep only last 50 commands
      }
      // Wrap command to capture output
      var wrappedCode = "\ntry:\n    _result = eval(\"".concat(pythonCode.replace(/"/g, '\\"'), "\")\n    if _result is not None:\n        print(f\">>> {_result}\")\n    else:\n        exec(\"").concat(pythonCode.replace(/"/g, '\\"'), "\")\n        print(\">>> Command executed\")\nexcept Exception as e:\n    print(f\">>> Error: {e}\")\n");
      return this.sendPythonCommand(wrappedCode);
    }
  }, {
    key: "_onConnect",
    value: function _onConnect() {
      var _this3 = this;
      // Send Ctrl-C to interrupt any running program and enter the REPL
      this.sendRaw('\x03');
      setTimeout(function () {
        // Attempt to confirm Python REPL is active
        _this3.sendRaw('import hub\r\nprint("PYTHON_AVAILABLE")\r\n');
        // Re-request initial state data
        _this3.sendCommand('trigger_current_state', {}, false);
      }, 250); // Delay to allow the hub to switch to REPL mode
    }
    // Start continuous sensor monitoring
  }, {
    key: "_initializeContinuousSensorMonitoring",
    value: function _initializeContinuousSensorMonitoring() {
      if (!this._pythonAvailable || this._sensorLoopRunning) return;
      this._sensorLoopRunning = true;
      console.log("Starting continuous sensor monitoring script on hub...");
      var sensorScript = "\nimport hub, utime, sys\ndef continuous_sensor_loop():\n    while True:\n        try:\n            # Motion sensors\n            yaw_angle, pitch_angle, roll_angle = hub.motion.position()\n            accel_x, accel_y, accel_z = hub.motion.accelerometer()\n            orientation = hub.motion.orientation()\n            # Temperatures\n            battery_temp = hub.battery.temperature()\n            hub_temp = hub.temperature()\n            # Motor data\n            motor_data = {}\n            for port in 'ABCDEF':\n                if hasattr(hub.port[port], 'motor'):\n                    try:\n                        speed, rel_deg, abs_deg, pwm = hub.port[port].motor.get()\n                        motor_data[port] = f\"{speed},{rel_deg},{abs_deg},{pwm}\"\n                    except: pass\n            motor_str = \"|\".join([f\"{k}:{v}\" for k, v in motor_data.items()])\n            # Print data in a single, parseable line\n            print(f\"SENSORS:{yaw_angle},{pitch_angle},{roll_angle}|{accel_x},{accel_y},{accel_z}|{orientation}|{battery_temp},{hub_temp}|{motor_str}\")\n            # Gesture detection\n            for gesture in ['tapped', 'doubletapped', 'shake', 'freefall']:\n                if hub.motion.was_gesture(gesture):\n                    print(f\"GESTURE:{gesture.upper()}\")\n        except Exception as e:\n            pass # Ignore errors in the loop to keep it running\n        utime.sleep_ms(100)\ncontinuous_sensor_loop()\n";
      // Send the script to the REPL for execution
      this.sendPythonCommand(sensorScript);
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(params) {
      var message = params.message;
      var data = Base64Util.base64ToUint8Array(message);
      var text = new TextDecoder().decode(data);
      var responses = (this._remainingText + text).split('\r\n');
      this._remainingText = responses.pop();
      var _iterator = _createForOfIteratorHelper(responses),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var responseText = _step.value;
          var trimmedText = responseText.trim();
          if (!trimmedText) continue;
          // First, try to parse as JSON (for standard hub responses)
          try {
            var json = JSON.parse(trimmedText);
            if (json.hasOwnProperty('i') || json.m !== 0) {
              //console.log('< JSON: ' + trimmedText);
            }
            this._parseResponse(json);
          } catch (error) {
            // If not JSON, treat it as raw output from our Python script
            //console.log('< RAW: ' + trimmedText);
            this._parseData(trimmedText);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "_parseData",
    value: function _parseData(dataText) {
      var _this4 = this;
      try {
        if (dataText.startsWith('SENSORS:')) {
          var sensorData = dataText.substring(8);
          var parts = sensorData.split('|');
          if (parts.length >= 5) {
            // Angles
            var angles = parts[0].split(',').map(parseFloat);
            if (angles.length === 3) this._sensors.angle = {
              yaw: angles[0],
              pitch: angles[1],
              roll: angles[2]
            };
            // Acceleration
            var accel = parts[1].split(',').map(parseFloat);
            if (accel.length === 3) this._sensors.acceleration = {
              x: accel[0],
              y: accel[1],
              z: accel[2]
            };
            // Orientation
            this._sensors.orientation = parseInt(parts[2], 10);
            // Temperatures
            var temps = parts[3].split(',').map(parseFloat);
            if (temps.length >= 2) {
              this._sensors.temperature = temps[0];
              this._sensors.hubTemp = temps[1];
            }
            // Motor positions
            if (parts[4]) {
              var motorPairs = parts[4].split('|');
              var _iterator2 = _createForOfIteratorHelper(motorPairs),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var pair = _step2.value;
                  var _pair$split = pair.split(':'),
                    _pair$split2 = _slicedToArray(_pair$split, 2),
                    port = _pair$split2[0],
                    values = _pair$split2[1];
                  if (port && values) {
                    var _values$split$map = values.split(',').map(parseFloat),
                      _values$split$map2 = _slicedToArray(_values$split$map, 4),
                      speed = _values$split$map2[0],
                      relDeg = _values$split$map2[1],
                      absDeg = _values$split$map2[2],
                      pwm = _values$split$map2[3];
                    this._sensors.motorPositions[port] = {
                      speed: speed,
                      relativePosition: relDeg,
                      absolutePosition: absDeg,
                      power: pwm
                    };
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        } else if (dataText.startsWith('GESTURE:')) {
          var gesture = dataText.substring(8).toLowerCase();
          if (this._sensors.gestures.hasOwnProperty(gesture)) {
            this._sensors.gestures[gesture] = true;
            setTimeout(function () {
              _this4._sensors.gestures[gesture] = false;
            }, 100);
          }
        } else if (dataText.includes('PYTHON_AVAILABLE')) {
          if (!this._pythonAvailable) {
            this._pythonAvailable = true;
            console.log('Python REPL is available on hub.');
            this._initializeContinuousSensorMonitoring();
          }
        } else if (dataText.startsWith('>>>')) {
          // NEW: Capture REPL output
          this._replOutput += dataText + '\n';
          // Keep only last 1000 characters to prevent memory issues
          if (this._replOutput.length > 1000) {
            this._replOutput = this._replOutput.substring(this._replOutput.length - 1000);
          }
        }
      } catch (error) {
        console.warn('Error parsing raw data:', error, 'Data:', dataText);
      }
    }
  }, {
    key: "_parseResponse",
    value: function _parseResponse(response) {
      if (response.hasOwnProperty('m')) {
        switch (response.m) {
          case 0:
            // Hub status - enhanced parsing
            this._parseHubStatus(response);
            break;
          case 1:
            // Storage
            break;
          case 2:
            // Battery - enhanced
            if (response.p && response.p.length >= 2) {
              this._sensors.battery = Math.round(response.p[1]);
            }
            break;
          case 3:
            // Button - enhanced
            this._parseButtonEvent(response);
            break;
          case 4:
            // Event (Orientation, Gesture) - enhanced
            this._parseEventResponse(response);
            break;
        }
      }
      if (response.hasOwnProperty('i')) {
        var openRequest = this._openRequests[response.i];
        delete this._openRequests[response.i];
        if (openRequest) {
          openRequest.resolve();
        }
      }
    }
  }, {
    key: "_parseHubStatus",
    value: function _parseHubStatus(response) {
      // Enhanced port parsing with more sensor types
      for (var i = 0; i < 6; i++) {
        var port = SpikePorts[i];
        var deviceId = response.p[i][0];
        var values = response.p[i][1];
        switch (deviceId) {
          case 48: // Large motor
          case 49:
            // Medium motor
            this._portValues[port] = {
              type: 'motor',
              speed: values[0],
              degreesCounted: values[1],
              position: (values[2] + 360) % 360,
              power: values[3],
              relativePosition: values[1] || 0,
              absolutePosition: values[2] || 0
            };
            break;
          case 61:
            // Color sensor
            if (values.length >= 4) {
              this._portValues[port] = {
                type: 'color',
                color: values[0],
                reflection: values[1],
                ambient: values[2],
                red: values[3] || 0,
                green: values[4] || 0,
                blue: values[5] || 0
              };
            }
            break;
          case 62:
            // Distance sensor
            this._portValues[port] = {
              type: 'distance',
              distance: values[0] === -1 ? 0 : values[0]
            };
            break;
          case 63:
            // Force sensor
            this._portValues[port] = {
              type: 'force',
              force: values[0],
              pressed: values[1] > 0
            };
            break;
          default:
            this._portValues[port] = {
              type: 'unknown'
            };
            break;
        }
      }
      // Enhanced angle and motion parsing
      if (response.p.length > 8) {
        // Standard angle data
        if (response.p[8] && response.p[8].length >= 3) {
          this._sensors.angle = {
            yaw: response.p[8][0],
            pitch: response.p[8][1],
            roll: response.p[8][2]
          };
        }
      }
    }
  }, {
    key: "_parseButtonEvent",
    value: function _parseButtonEvent(response) {
      if (response.p && response.p.length >= 2) {
        var button = response.p[0];
        var pressed = response.p[1] === 1;
        var buttonIndex = {
          left: 0,
          center: 1,
          right: 2
        }[button];
        if (buttonIndex !== undefined) {
          this._sensors.buttons[buttonIndex] = pressed ? 1 : 0;
        }
      }
    }
  }, {
    key: "_parseEventResponse",
    value: function _parseEventResponse(response) {
      var _this5 = this;
      if (SpikeOrientation.hasOwnProperty(response.p)) {
        this._sensors.orientation = SpikeOrientation[response.p];
      }
      // Enhanced gesture parsing
      var gestureMap = {
        'tapped': 'tapped',
        'doubletapped': 'doubletapped',
        'shake': 'shake',
        'freefall': 'freefall'
      };
      if (gestureMap[response.p]) {
        this._sensors.gestures[gestureMap[response.p]] = true;
        // Reset gesture after short delay
        setTimeout(function () {
          _this5._sensors.gestures[gestureMap[response.p]] = false;
        }, 100);
      }
    }
  }]);
}();
var Scratch3SpikePrimeBlocks = /*#__PURE__*/function () {
  function Scratch3SpikePrimeBlocks(runtime) {
    _classCallCheck(this, Scratch3SpikePrimeBlocks);
    this.runtime = runtime;
    this._peripheral = new SpikePrime(this.runtime, Scratch3SpikePrimeBlocks.EXTENSION_ID);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);
    if (runtime.formatMessage) {
      formatMessage = runtime.formatMessage;
    }
  }
  return _createClass(Scratch3SpikePrimeBlocks, [{
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: Scratch3SpikePrimeBlocks.EXTENSION_ID,
        name: formatMessage({
          id: 'spikeprime.title',
          default: 'SPIKE Prime Ultimate'
        }),
        blockIconURI: blockIconURI,
        showStatusButton: true,
        blocks: [
        // ===== MOVEMENT CONTROLS (NEW) =====
        {
          opcode: 'setMovementMotors',
          text: formatMessage({
            id: 'spikeprime.setMovementMotors',
            default: 'set movement motors [PORT_A] and [PORT_B]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT_A: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            PORT_B: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'B'
            }
          }
        }, {
          opcode: 'moveForward',
          text: formatMessage({
            id: 'spikeprime.moveForward',
            default: 'move [DIRECTION] for [VALUE] [UNIT]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            DIRECTION: {
              type: ArgumentType.STRING,
              menu: 'MOVE_DIRECTION',
              defaultValue: 'forward'
            },
            VALUE: {
              type: ArgumentType.NUMBER,
              defaultValue: 10
            },
            UNIT: {
              type: ArgumentType.STRING,
              menu: 'MOVE_UNIT',
              defaultValue: 'cm'
            }
          }
        }, {
          opcode: 'steer',
          text: formatMessage({
            id: 'spikeprime.steer',
            default: 'start steering [STEERING]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            STEERING: {
              type: ArgumentType.NUMBER,
              defaultValue: 50
            }
          }
        }, {
          opcode: 'startTank',
          text: formatMessage({
            id: 'spikeprime.startTank',
            default: 'start tank drive left [LEFT_SPEED] right [RIGHT_SPEED]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            LEFT_SPEED: {
              type: ArgumentType.NUMBER,
              defaultValue: 50
            },
            RIGHT_SPEED: {
              type: ArgumentType.NUMBER,
              defaultValue: 50
            }
          }
        }, {
          opcode: 'setMovementSpeed',
          text: formatMessage({
            id: 'spikeprime.setMovementSpeed',
            default: 'set movement speed to [SPEED]%'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            SPEED: {
              type: ArgumentType.NUMBER,
              defaultValue: 50
            }
          }
        }, {
          opcode: 'stopMovement',
          text: formatMessage({
            id: 'spikeprime.stopMovement',
            default: 'stop movement'
          }),
          blockType: BlockType.COMMAND
        }, '---',
        // ===== MOTOR CONTROL =====
        {
          opcode: 'motorRunFor',
          text: formatMessage({
            id: 'spikeprime.motorRunFor',
            default: '[PORT] run [DIRECTION] for [VALUE] [UNIT]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            DIRECTION: {
              type: ArgumentType.NUMBER,
              menu: 'DIRECTION',
              defaultValue: 1
            },
            VALUE: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            UNIT: {
              type: ArgumentType.STRING,
              menu: 'MOTOR_UNIT',
              defaultValue: 'rotations'
            }
          }
        }, {
          opcode: 'motorRunToPosition',
          text: formatMessage({
            id: 'spikeprime.motorRunToPosition',
            default: '[PORT] run to position [POSITION] degrees'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'C'
            },
            POSITION: {
              type: ArgumentType.ANGLE,
              defaultValue: 0
            }
          }
        }, {
          opcode: 'motorStart',
          text: formatMessage({
            id: 'spikeprime.motorStart',
            default: '[PORT] start motor [DIRECTION]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            DIRECTION: {
              type: ArgumentType.NUMBER,
              menu: 'DIRECTION',
              defaultValue: 1
            }
          }
        }, {
          opcode: 'motorStop',
          text: formatMessage({
            id: 'spikeprime.motorStop',
            default: '[PORT] stop motor'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'motorSetSpeed',
          text: formatMessage({
            id: 'spikeprime.motorSetSpeed',
            default: '[PORT] set speed to [SPEED] %'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'MULTIPLE_PORT',
              defaultValue: 'A'
            },
            SPEED: {
              type: ArgumentType.NUMBER,
              defaultValue: 75
            }
          }
        }, {
          opcode: 'motorSetStopAction',
          text: formatMessage({
            id: 'spikeprime.motorSetStopAction',
            default: '[PORT] set stop action to [ACTION]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            ACTION: {
              type: ArgumentType.STRING,
              menu: 'STOP_ACTION',
              defaultValue: 'brake'
            }
          }
        }, {
          opcode: 'getPosition',
          text: formatMessage({
            id: 'spikeprime.getPosition',
            default: '[PORT] position'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        },
        // ===== MOTOR ENHANCEMENTS =====
        {
          opcode: 'getRelativePosition',
          text: formatMessage({
            id: 'spikeprime.getRelativePosition',
            default: '[PORT] relative position'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getAbsolutePosition',
          text: formatMessage({
            id: 'spikeprime.getAbsolutePosition',
            default: '[PORT] absolute position'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getSpeed',
          text: formatMessage({
            id: 'spikeprime.getSpeed',
            default: '[PORT] speed (deg/s)'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'resetMotorPosition',
          text: formatMessage({
            id: 'spikeprime.resetMotorPosition',
            default: 'reset [PORT] motor position to [POSITION]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            POSITION: {
              type: ArgumentType.NUMBER,
              defaultValue: 0
            }
          }
        }, '---',
        // ===== DISPLAY CONTROL =====
        {
          opcode: 'displayText',
          text: formatMessage({
            id: 'spikeprime.displayText',
            default: 'write [TEXT]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            TEXT: {
              type: ArgumentType.STRING,
              defaultValue: 'Hello'
            }
          }
        }, {
          opcode: 'displayImage',
          text: formatMessage({
            id: 'spikeprime.displayImage',
            default: 'turn on [MATRIX]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            MATRIX: {
              type: ArgumentType.MATRIX,
              defaultValue: '1101111011000001000101110'
            }
          }
        }, {
          opcode: 'displayPattern',
          text: formatMessage({
            id: 'spikeprime.displayPattern',
            default: 'display pattern [PATTERN]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PATTERN: {
              type: ArgumentType.STRING,
              menu: 'DISPLAY_PATTERN',
              defaultValue: 'heart'
            }
          }
        }, {
          opcode: 'displayClear',
          text: formatMessage({
            id: 'spikeprime.displayClear',
            default: 'turn off pixels'
          }),
          blockType: BlockType.COMMAND
        }, {
          opcode: 'setPixel',
          text: formatMessage({
            id: 'spikeprime.setPixel',
            default: 'set pixel [X] [Y] to [BRIGHTNESS] %'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            X: {
              type: ArgumentType.NUMBER,
              defaultValue: 3
            },
            Y: {
              type: ArgumentType.NUMBER,
              defaultValue: 3
            },
            BRIGHTNESS: {
              type: ArgumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'rotateDisplay',
          text: formatMessage({
            id: 'spikeprime.rotateDisplay',
            default: 'rotate display [ANGLE] degrees'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            ANGLE: {
              type: ArgumentType.STRING,
              menu: 'ROTATION_ANGLE',
              defaultValue: '90'
            }
          }
        }, {
          opcode: 'setCenterButtonColor',
          text: formatMessage({
            id: 'spikeprime.setCenterButtonColor',
            default: 'set center button to [COLOR]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            COLOR: {
              type: ArgumentType.STRING,
              menu: 'CENTER_LED_COLOR',
              defaultValue: 'GREEN'
            }
          }
        }, '---',
        // ===== IMU & GYRO =====
        {
          opcode: 'getAngle',
          text: formatMessage({
            id: 'spikeprime.getAngle',
            default: '[AXIS] angle'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            AXIS: {
              type: ArgumentType.STRING,
              menu: 'AXIS',
              defaultValue: 'pitch'
            }
          }
        }, {
          opcode: 'getGyroRate',
          text: formatMessage({
            id: 'spikeprime.getGyroRate',
            default: 'gyro rate [AXIS] (deg/s)'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            AXIS: {
              type: ArgumentType.STRING,
              menu: 'AXIS',
              defaultValue: 'yaw'
            }
          }
        }, {
          opcode: 'getFilteredGyroRate',
          text: formatMessage({
            id: 'spikeprime.getFilteredGyroRate',
            default: 'filtered gyro rate [AXIS] (deg/s)'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            AXIS: {
              type: ArgumentType.STRING,
              menu: 'AXIS',
              defaultValue: 'yaw'
            }
          }
        }, {
          opcode: 'getAcceleration',
          text: formatMessage({
            id: 'spikeprime.getAcceleration',
            default: 'acceleration [AXIS] (milli-g)'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            AXIS: {
              type: ArgumentType.STRING,
              menu: 'AXIS_XYZ',
              defaultValue: 'x'
            }
          }
        }, {
          opcode: 'getFilteredAcceleration',
          text: formatMessage({
            id: 'spikeprime.getFilteredAcceleration',
            default: 'filtered acceleration [AXIS] (milli-g)'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            AXIS: {
              type: ArgumentType.STRING,
              menu: 'AXIS_XYZ',
              defaultValue: 'x'
            }
          }
        }, {
          opcode: 'resetYaw',
          text: formatMessage({
            id: 'spikeprime.resetYaw',
            default: 'reset yaw angle'
          }),
          blockType: BlockType.COMMAND
        }, {
          opcode: 'presetYaw',
          text: formatMessage({
            id: 'spikeprime.presetYaw',
            default: 'preset yaw to [ANGLE] degrees'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            ANGLE: {
              type: ArgumentType.NUMBER,
              defaultValue: 0
            }
          }
        }, '---',
        // ===== 3X3 LED COLOR MATRIX =====
        {
          opcode: 'setMatrix3x3ColorGrid',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3ColorGrid',
            default: 'set [PORT] 3x3 colors: [P1][P2][P3] [P4][P5][P6] [P7][P8][P9]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            P1: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P2: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '⚫'
            },
            P3: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P4: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P5: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P6: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P7: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '⚫'
            },
            P8: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            P9: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '⚫'
            }
          }
        }, {
          opcode: 'setMatrix3x3BrightnessGrid',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3BrightnessGrid',
            default: 'set [PORT] 3x3 brightness: [B1][B2][B3] [B4][B5][B6] [B7][B8][B9]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            B1: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B2: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B3: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B4: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B5: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B6: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B7: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B8: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            },
            B9: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '8'
            }
          }
        }, {
          opcode: 'setMatrix3x3PixelEmoji',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3PixelEmoji',
            default: 'set [PORT] 3x3 pixel [X],[Y] to [COLOR] brightness [BRIGHTNESS]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            X: {
              type: ArgumentType.NUMBER,
              defaultValue: 2
            },
            Y: {
              type: ArgumentType.NUMBER,
              defaultValue: 2
            },
            COLOR: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            BRIGHTNESS: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '5'
            }
          }
        }, {
          opcode: 'setMatrix3x3Custom',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3Custom',
            default: 'set [PORT] 3x3 custom pattern [PATTERN]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            PATTERN: {
              type: ArgumentType.STRING,
              defaultValue: 'r8 g6 b4\ny7 w9 o5\nm3 v2 .1'
            }
          }
        }, {
          opcode: 'generateMatrix3x3Code',
          text: formatMessage({
            id: 'spikeprime.generateMatrix3x3Code',
            default: 'generate 3x3 code for pattern [PATTERN]'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PATTERN: {
              type: ArgumentType.STRING,
              defaultValue: 'r8 .1 r8\nr6 r10 r6\n.1 r8 .1'
            }
          }
        }, {
          opcode: 'setMatrix3x3SolidColor',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3SolidColor',
            default: 'set [PORT] 3x3 matrix all [COLOR] brightness [BRIGHTNESS]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            COLOR: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_COLOR_EMOJI',
              defaultValue: '🔴'
            },
            BRIGHTNESS: {
              type: ArgumentType.STRING,
              menu: 'BRIGHTNESS_1_TO_10',
              defaultValue: '5'
            }
          }
        }, {
          opcode: 'setMatrix3x3Level',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3Level',
            default: 'set [PORT] 3x3 battery level to [LEVEL]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            LEVEL: {
              type: ArgumentType.NUMBER,
              defaultValue: 5
            }
          }
        }, {
          opcode: 'setMatrix3x3Transition',
          text: formatMessage({
            id: 'spikeprime.setMatrix3x3Transition',
            default: 'set [PORT] 3x3 transition [EFFECT]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            EFFECT: {
              type: ArgumentType.STRING,
              menu: 'MATRIX_3X3_TRANSITION',
              defaultValue: 'none'
            }
          }
        }, {
          opcode: 'clearMatrix3x3',
          text: formatMessage({
            id: 'spikeprime.clearMatrix3x3',
            default: 'clear [PORT] 3x3 matrix'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, '---',
        // ===== ENHANCED GESTURES =====
        {
          opcode: 'whenGesture',
          blockType: BlockType.HAT,
          text: formatMessage({
            id: 'spikeprime.whenGesture',
            default: 'when hub [GESTURE]'
          }),
          arguments: {
            GESTURE: {
              type: ArgumentType.STRING,
              menu: 'GESTURE',
              defaultValue: 'tapped'
            }
          }
        }, {
          opcode: 'isGesture',
          blockType: BlockType.BOOLEAN,
          text: formatMessage({
            id: 'spikeprime.isGesture',
            default: 'hub [GESTURE]?'
          }),
          arguments: {
            GESTURE: {
              type: ArgumentType.STRING,
              menu: 'GESTURE',
              defaultValue: 'tapped'
            }
          }
        }, {
          opcode: 'getOrientation',
          text: formatMessage({
            id: 'spikeprime.getOrientation',
            default: 'orientation'
          }),
          blockType: BlockType.REPORTER
        }, '---',
        // ===== SOUND SYSTEM =====
        {
          opcode: 'playHubSound',
          text: formatMessage({
            id: 'spikeprime.playHubSound',
            default: 'play hub sound [SOUND]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            SOUND: {
              type: ArgumentType.STRING,
              menu: 'HUB_SOUND',
              defaultValue: 'startup'
            }
          }
        }, {
          opcode: 'playBeep',
          text: formatMessage({
            id: 'spikeprime.playBeep',
            default: 'beep [FREQUENCY] Hz for [DURATION] ms'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            FREQUENCY: {
              type: ArgumentType.NUMBER,
              defaultValue: 440
            },
            DURATION: {
              type: ArgumentType.NUMBER,
              defaultValue: 500
            }
          }
        }, {
          opcode: 'playNote',
          text: formatMessage({
            id: 'spikeprime.playNote',
            default: 'play note [NOTE] for [SECS] seconds'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            NOTE: {
              type: ArgumentType.NOTE,
              defaultValue: 60
            },
            SECS: {
              type: ArgumentType.NUMBER,
              defaultValue: 0.5
            }
          }
        }, {
          opcode: 'playWaveBeep',
          text: formatMessage({
            id: 'spikeprime.playWaveBeep',
            default: 'beep [WAVEFORM] [FREQUENCY] Hz for [DURATION] ms'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            WAVEFORM: {
              type: ArgumentType.STRING,
              menu: 'WAVEFORM',
              defaultValue: 'sin'
            },
            FREQUENCY: {
              type: ArgumentType.NUMBER,
              defaultValue: 440
            },
            DURATION: {
              type: ArgumentType.NUMBER,
              defaultValue: 500
            }
          }
        }, {
          opcode: 'setVolume',
          text: formatMessage({
            id: 'spikeprime.setVolume',
            default: 'set volume to [VOLUME]%'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            VOLUME: {
              type: ArgumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'stopSound',
          text: formatMessage({
            id: 'spikeprime.stopSound',
            default: 'stop all sounds'
          }),
          blockType: BlockType.COMMAND
        }, '---',
        // ===== STATUS & TEMPERATURE =====
        {
          opcode: 'getBatteryLevel',
          text: formatMessage({
            id: 'spikeprime.getBatteryLevel',
            default: 'battery level %'
          }),
          blockType: BlockType.REPORTER
        }, {
          opcode: 'getBatteryTemperature',
          text: formatMessage({
            id: 'spikeprime.getBatteryTemperature',
            default: 'battery temperature'
          }),
          blockType: BlockType.REPORTER
        }, {
          opcode: 'getHubTemperature',
          text: formatMessage({
            id: 'spikeprime.getHubTemperature',
            default: 'hub temperature'
          }),
          blockType: BlockType.REPORTER
        }, '---',
        // ===== TIMER FUNCTIONALITY =====
        {
          opcode: 'getTimer',
          text: formatMessage({
            id: 'spikeprime.getTimer',
            default: 'timer'
          }),
          blockType: BlockType.REPORTER
        }, {
          opcode: 'resetTimer',
          text: formatMessage({
            id: 'spikeprime.resetTimer',
            default: 'reset timer'
          }),
          blockType: BlockType.COMMAND
        }, '---',
        // ===== SENSOR BLOCKS =====
        {
          opcode: 'getDistance',
          text: formatMessage({
            id: 'spikeprime.getDistance',
            default: '[PORT] distance'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'setDistanceLights',
          text: formatMessage({
            id: 'spikeprime.setDistanceLights',
            default: 'set [PORT] distance lights [TL] [TR] [BL] [BR]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            TL: {
              type: ArgumentType.NUMBER,
              defaultValue: 9
            },
            TR: {
              type: ArgumentType.NUMBER,
              defaultValue: 9
            },
            BL: {
              type: ArgumentType.NUMBER,
              defaultValue: 9
            },
            BR: {
              type: ArgumentType.NUMBER,
              defaultValue: 9
            }
          }
        }, {
          opcode: 'getColor',
          text: formatMessage({
            id: 'spikeprime.getColor',
            default: '[PORT] color'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getReflection',
          text: formatMessage({
            id: 'spikeprime.getReflection',
            default: '[PORT] reflection'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getAmbientLight',
          text: formatMessage({
            id: 'spikeprime.getAmbientLight',
            default: '[PORT] ambient light'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'getForce',
          text: formatMessage({
            id: 'spikeprime.getForce',
            default: '[PORT] force'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        }, {
          opcode: 'isForceSensorPressed',
          text: formatMessage({
            id: 'spikeprime.isForceSensorPressed',
            default: '[PORT] force sensor pressed?'
          }),
          blockType: BlockType.BOOLEAN,
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            }
          }
        },
        // ===== EVENT-BASED SENSOR BLOCKS =====
        {
          opcode: 'whenColor',
          blockType: BlockType.HAT,
          text: formatMessage({
            id: 'spikeprime.whenColor',
            default: 'when [PORT] sees [COLOR]'
          }),
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            COLOR: {
              type: ArgumentType.STRING,
              menu: 'COLOR',
              defaultValue: 'red'
            }
          }
        }, {
          opcode: 'isColor',
          blockType: BlockType.BOOLEAN,
          text: formatMessage({
            id: 'spikeprime.isColor',
            default: '[PORT] sees [COLOR]?'
          }),
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            COLOR: {
              type: ArgumentType.STRING,
              menu: 'COLOR',
              defaultValue: 'red'
            }
          }
        }, {
          opcode: 'whenForceSensor',
          blockType: BlockType.HAT,
          text: formatMessage({
            id: 'spikeprime.whenForceSensor',
            default: 'when [PORT] is [STATE]'
          }),
          arguments: {
            PORT: {
              type: ArgumentType.STRING,
              menu: 'PORT',
              defaultValue: 'A'
            },
            STATE: {
              type: ArgumentType.STRING,
              menu: 'FORCE_STATE',
              defaultValue: 'pressed'
            }
          }
        }, '---',
        // ===== BUTTON ENHANCEMENTS =====
        {
          opcode: 'isButtonPressed',
          text: formatMessage({
            id: 'spikeprime.isButtonPressed',
            default: '[BUTTON] button pressed?'
          }),
          blockType: BlockType.BOOLEAN,
          arguments: {
            BUTTON: {
              type: ArgumentType.STRING,
              menu: 'BUTTON',
              defaultValue: 'center'
            }
          }
        }, {
          opcode: 'whenButtonPressed',
          blockType: BlockType.HAT,
          text: formatMessage({
            id: 'spikeprime.whenButtonPressed',
            default: 'when [BUTTON] button pressed'
          }),
          arguments: {
            BUTTON: {
              type: ArgumentType.STRING,
              menu: 'BUTTON',
              defaultValue: 'center'
            }
          }
        }, '---',
        // ===== PYTHON REPL =====
        {
          opcode: 'runReplCommand',
          text: formatMessage({
            id: 'spikeprime.runReplCommand',
            default: 'run Python REPL: [CODE]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            CODE: {
              type: ArgumentType.STRING,
              defaultValue: 'print("Hello REPL!")'
            }
          }
        }, {
          opcode: 'getReplOutput',
          text: formatMessage({
            id: 'spikeprime.getReplOutput',
            default: 'REPL output'
          }),
          blockType: BlockType.REPORTER
        }, {
          opcode: 'clearReplOutput',
          text: formatMessage({
            id: 'spikeprime.clearReplOutput',
            default: 'clear REPL output'
          }),
          blockType: BlockType.COMMAND
        }, {
          opcode: 'getReplHistory',
          text: formatMessage({
            id: 'spikeprime.getReplHistory',
            default: 'REPL command [INDEX]'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            INDEX: {
              type: ArgumentType.NUMBER,
              defaultValue: -1
            }
          }
        }, '---',
        // ===== ADVANCED PYTHON COMMANDS =====
        {
          opcode: 'runPythonCommand',
          text: formatMessage({
            id: 'spikeprime.runPythonCommand',
            default: 'run Python: [CODE]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            CODE: {
              type: ArgumentType.STRING,
              defaultValue: 'print("Hello World")'
            }
          }
        }, {
          opcode: 'runHubCommand',
          text: formatMessage({
            id: 'spikeprime.runHubCommand',
            default: 'run hub command: [CODE]'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            CODE: {
              type: ArgumentType.STRING,
              defaultValue: 'hub.status()'
            }
          }
        }, {
          opcode: 'exitScript',
          text: formatMessage({
            id: 'spikeprime.exitScript',
            default: 'exit Python script'
          }),
          blockType: BlockType.COMMAND
        }],
        menus: {
          PORT: {
            acceptReporters: true,
            items: SpikePorts
          },
          MULTIPLE_PORT: {
            acceptReporters: true,
            items: ['A', 'B', 'C', 'D', 'E', 'F', 'A+B', 'C+D', 'E+F', 'A+B+C+D+E+F']
          },
          MOTOR_UNIT: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.rotations',
                default: 'rotations'
              }),
              value: 'rotations'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.degrees',
                default: 'degrees'
              }),
              value: 'degrees'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.seconds',
                default: 'seconds'
              }),
              value: 'seconds'
            }]
          },
          AXIS: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.axis.pitch',
                default: 'pitch'
              }),
              value: 'pitch'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.axis.roll',
                default: 'roll'
              }),
              value: 'roll'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.axis.yaw',
                default: 'yaw'
              }),
              value: 'yaw'
            }]
          },
          AXIS_XYZ: {
            acceptReporters: false,
            items: ['x', 'y', 'z']
          },
          DIRECTION: {
            acceptReporters: false,
            items: [{
              text: '⬆️',
              value: '1'
            }, {
              text: '⬇️',
              value: '-1'
            }]
          },
          DISPLAY_PATTERN: {
            acceptReporters: false,
            items: Object.keys(DisplayPatterns)
          },
          ROTATION_ANGLE: {
            acceptReporters: false,
            items: ['90', '-90', '180', '-180']
          },
          CENTER_LED_COLOR: {
            acceptReporters: false,
            items: Object.keys(CenterLEDColors)
          },
          GESTURE: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.gesture.tapped',
                default: 'tapped'
              }),
              value: 'tapped'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.gesture.doubletapped',
                default: 'doubletapped'
              }),
              value: 'doubletapped'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.gesture.shake',
                default: 'shake'
              }),
              value: 'shake'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.gesture.freefall',
                default: 'freefall'
              }),
              value: 'freefall'
            }]
          },
          HUB_SOUND: {
            acceptReporters: false,
            items: HubSoundFiles
          },
          WAVEFORM: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.waveform.sin',
                default: 'sin'
              }),
              value: 'sin'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.waveform.square',
                default: 'square'
              }),
              value: 'square'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.waveform.triangle',
                default: 'triangle'
              }),
              value: 'triangle'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.waveform.sawtooth',
                default: 'sawtooth'
              }),
              value: 'sawtooth'
            }]
          },
          BUTTON: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.button.left',
                default: 'left'
              }),
              value: 'left'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.button.center',
                default: 'center'
              }),
              value: 'center'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.button.right',
                default: 'right'
              }),
              value: 'right'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.button.connect',
                default: 'connect'
              }),
              value: 'connect'
            }]
          },
          MOVE_DIRECTION: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.direction.forward',
                default: 'forward'
              }),
              value: 'forward'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.direction.backward',
                default: 'backward'
              }),
              value: 'backward'
            }]
          },
          MOVE_UNIT: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.cm',
                default: 'cm'
              }),
              value: 'cm'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.in',
                default: 'in'
              }),
              value: 'in'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.rotations',
                default: 'rotations'
              }),
              value: 'rotations'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.degrees',
                default: 'degrees'
              }),
              value: 'degrees'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.moveUnit.seconds',
                default: 'seconds'
              }),
              value: 'seconds'
            }]
          },
          STOP_ACTION: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.stopAction.coast',
                default: 'coast'
              }),
              value: 'coast'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.stopAction.brake',
                default: 'brake'
              }),
              value: 'brake'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.stopAction.hold',
                default: 'hold'
              }),
              value: 'hold'
            }]
          },
          COLOR: {
            acceptReporters: true,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.color.red',
                default: 'red'
              }),
              value: 'red'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.green',
                default: 'green'
              }),
              value: 'green'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.blue',
                default: 'blue'
              }),
              value: 'blue'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.yellow',
                default: 'yellow'
              }),
              value: 'yellow'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.cyan',
                default: 'cyan'
              }),
              value: 'cyan'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.magenta',
                default: 'magenta'
              }),
              value: 'magenta'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.white',
                default: 'white'
              }),
              value: 'white'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.color.black',
                default: 'black'
              }),
              value: 'black'
            }]
          },
          FORCE_STATE: {
            acceptReporters: false,
            items: [{
              text: formatMessage({
                id: 'spikeprime.menu.forceState.pressed',
                default: 'pressed'
              }),
              value: 'pressed'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.forceState.hardPressed',
                default: 'hard pressed'
              }),
              value: 'hard pressed'
            }, {
              text: formatMessage({
                id: 'spikeprime.menu.forceState.released',
                default: 'released'
              }),
              value: 'released'
            }]
          },
          MATRIX_COLOR_EMOJI: {
            acceptReporters: false,
            items: [{
              text: '⚫ Off',
              value: '⚫'
            }, {
              text: '🟣 Magenta',
              value: '🟣'
            }, {
              text: '🟪 Violet',
              value: '🟪'
            }, {
              text: '🔵 Blue',
              value: '🔵'
            }, {
              text: '🔷 Turquoise',
              value: '🔷'
            }, {
              text: '🟢 Mint',
              value: '🟢'
            }, {
              text: '🟩 Green',
              value: '🟩'
            }, {
              text: '🟡 Yellow',
              value: '🟡'
            }, {
              text: '🟠 Orange',
              value: '🟠'
            }, {
              text: '🔴 Red',
              value: '🔴'
            }, {
              text: '⚪ White',
              value: '⚪'
            }]
          },
          BRIGHTNESS_1_TO_10: {
            acceptReporters: false,
            items: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
          },
          MATRIX_3X3_TRANSITION: {
            acceptReporters: false,
            items: ['none', 'fade', 'slide']
          }
        }
      };
    }
  }, {
    key: "moveForward",
    value: function moveForward(args) {
      var direction = Cast.toString(args.DIRECTION);
      var value = Cast.toNumber(args.VALUE);
      var unit = Cast.toString(args.UNIT);
      var _this$_peripheral$_mo = _slicedToArray(this._peripheral._movementMotors, 2),
        portA = _this$_peripheral$_mo[0];
        _this$_peripheral$_mo[1];
      var speed = this._peripheral.motorSettings[portA].speed;
      var dirMultiplier = direction === 'forward' ? 1 : -1;
      if (unit === 'cm') {
        // Approximate conversion: 1 rotation = 17.6 cm for standard SPIKE wheels
        var rotations = value / 17.6;
        return this._peripheral.sendPythonCommand("motors.move(".concat(rotations * dirMultiplier, ", 'rotations', speed=").concat(speed, ")"));
      } else if (unit === 'in') {
        var _rotations = value / 6.93; // 1 rotation â‰ˆ 6.93 inches
        return this._peripheral.sendPythonCommand("motors.move(".concat(_rotations * dirMultiplier, ", 'rotations', speed=").concat(speed, ")"));
      } else {
        return this._peripheral.sendPythonCommand("motors.move(".concat(value * dirMultiplier, ", '").concat(unit, "', speed=").concat(speed, ")"));
      }
    }
  }, {
    key: "steer",
    value: function steer(args) {
      var steering = Cast.toNumber(args.STEERING);
      var _this$_peripheral$_mo2 = _slicedToArray(this._peripheral._movementMotors, 1),
        portA = _this$_peripheral$_mo2[0];
      var speed = this._peripheral.motorSettings[portA].speed;
      return this._peripheral.sendPythonCommand("motors.start(".concat(steering, ", speed=").concat(speed, ")"));
    }
  }, {
    key: "startTank",
    value: function startTank(args) {
      var leftSpeed = Cast.toNumber(args.LEFT_SPEED);
      var rightSpeed = Cast.toNumber(args.RIGHT_SPEED);
      return this._peripheral.sendPythonCommand("motors.start_tank(".concat(leftSpeed, ", ").concat(rightSpeed, ")"));
    }
  }, {
    key: "setMovementSpeed",
    value: function setMovementSpeed(args) {
      var speed = Cast.toNumber(args.SPEED);
      var _this$_peripheral$_mo3 = _slicedToArray(this._peripheral._movementMotors, 2),
        portA = _this$_peripheral$_mo3[0],
        portB = _this$_peripheral$_mo3[1];
      this._peripheral.motorSettings[portA].speed = speed;
      this._peripheral.motorSettings[portB].speed = speed;
      return this._peripheral.sendPythonCommand("motors.set_default_speed(".concat(speed, ")"));
    }
  }, {
    key: "stopMovement",
    value: function stopMovement() {
      return this._peripheral.sendPythonCommand('motors.stop()');
    }
    // ===== MOTOR IMPLEMENTATIONS =====
    /**
     * Run motor(s) for specified amount in specified unit
     * @param {object} args - Block arguments
     * @returns {Promise} Command execution promise
     */
  }, {
    key: "motorRunFor",
    value: function motorRunFor(args) {
      var direction = args.DIRECTION;
      var value = Cast.toNumber(args.VALUE);
      var unit = args.UNIT;
      var ports = this._validatePorts(Cast.toString(args.PORT));
      switch (unit) {
        case 'rotations':
          return this._motorRunForDegrees(ports, direction, value * 360);
        case 'degrees':
          return this._motorRunForDegrees(ports, direction, value);
        case 'seconds':
          return this._motorRunTimed(ports, direction, value);
        default:
          return Promise.resolve();
      }
    }
  }, {
    key: "motorRunToPosition",
    value: function motorRunToPosition(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var position = Cast.toNumber(args.POSITION);
      var speed = this._peripheral.motorSettings[port].speed;
      return this._peripheral.sendPythonCommand("hub.port.".concat(port, ".motor.run_to_position(").concat(position, ", speed=").concat(speed, ")"));
    }
    /**
     * Run motors for specific number of degrees
     * @param {Array} ports - Array of port letters
     * @param {number} direction - Direction multiplier (1 or -1)
     * @param {number} degrees - Degrees to rotate
     * @returns {Promise} Command execution promise
     */
  }, {
    key: "_motorRunForDegrees",
    value: function _motorRunForDegrees(ports, direction, degrees) {
      var _this6 = this;
      var promises = ports.map(function (port) {
        var setting = _this6._peripheral.motorSettings[port];
        // Try both standard command and Python method
        var standardCommand = _this6._peripheral.sendCommand('scratch.motor_run_for_degrees', {
          port: port,
          speed: setting.speed * direction,
          degrees: Math.floor(degrees),
          stop: setting.stopMode,
          stall: setting.stallDetection
        });
        var altCommand = _this6._peripheral.sendPythonCommand("import hub; hub.port.".concat(port, ".motor.run_for_degrees(").concat(Math.floor(degrees), ", ").concat(setting.speed * direction, ")"));
        return standardCommand.catch(function () {
          return altCommand;
        });
      });
      return Promise.all(promises).then(function () {});
    }
    /**
     * Run motors for specific time duration
     * @param {Array} ports - Array of port letters
     * @param {number} direction - Direction multiplier (1 or -1)
     * @param {number} seconds - Time in seconds
     * @returns {Promise} Command execution promise
     */
  }, {
    key: "_motorRunTimed",
    value: function _motorRunTimed(ports, direction, seconds) {
      var _this7 = this;
      var promises = ports.map(function (port) {
        var setting = _this7._peripheral.motorSettings[port];
        var standardCommand = _this7._peripheral.sendCommand('scratch.motor_run_timed', {
          port: port,
          speed: setting.speed * direction,
          time: Math.floor(seconds * 1000),
          stop: setting.stopMode,
          stall: setting.stallDetection
        });
        var altCommand = _this7._peripheral.sendPythonCommand("import hub; hub.port.".concat(port, ".motor.run_for_time(").concat(Math.floor(seconds * 1000), ", ").concat(setting.speed * direction, ")"));
        return standardCommand.catch(function () {
          return altCommand;
        });
      });
      return Promise.all(promises).then(function () {});
    }
  }, {
    key: "motorStart",
    value: function motorStart(args) {
      var _this8 = this;
      var direction = args.DIRECTION;
      var ports = this._validatePorts(Cast.toString(args.PORT));
      var promises = ports.map(function (port) {
        var setting = _this8._peripheral.motorSettings[port];
        var standardCommand = _this8._peripheral.sendCommand('scratch.motor_start', {
          port: port,
          speed: setting.speed * direction,
          stall: setting.stallDetection
        });
        var altCommand = _this8._peripheral.sendPythonCommand("import hub; hub.port.".concat(port, ".motor.pwm(").concat(Math.round(setting.speed * direction), ")"));
        return standardCommand.catch(function () {
          return altCommand;
        });
      });
      return Promise.all(promises).then(function () {});
    }
  }, {
    key: "motorStop",
    value: function motorStop(args) {
      var _this9 = this;
      var ports = this._validatePorts(Cast.toString(args.PORT));
      var promises = ports.map(function (port) {
        var setting = _this9._peripheral.motorSettings[port];
        var standardCommand = _this9._peripheral.sendCommand('scratch.motor_stop', {
          port: port,
          stop: setting.stopMode
        });
        var altCommand = _this9._peripheral.sendPythonCommand("import hub; hub.port.".concat(port, ".motor.stop()"));
        return standardCommand.catch(function () {
          return altCommand;
        });
      });
      return Promise.all(promises).then(function () {});
    }
  }, {
    key: "motorSetSpeed",
    value: function motorSetSpeed(args) {
      var _this0 = this;
      var speed = Cast.toNumber(args.SPEED);
      var ports = this._validatePorts(Cast.toString(args.PORT));
      ports.forEach(function (port) {
        _this0._peripheral.motorSettings[port].speed = speed;
      });
    }
  }, {
    key: "motorSetStopAction",
    value: function motorSetStopAction(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var action = Cast.toString(args.ACTION);
      var stopModeMap = {
        coast: 0,
        brake: 1,
        hold: 2
      };
      this._peripheral.motorSettings[port].stopMode = stopModeMap[action] || 1;
      return this._peripheral.sendPythonCommand("hub.port.".concat(port, ".motor.set_stop_action('").concat(action, "')"));
    }
  }, {
    key: "getPosition",
    value: function getPosition(args) {
      var _this$_peripheral$por, _this$_peripheral$por2;
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      return (_this$_peripheral$por = (_this$_peripheral$por2 = this._peripheral.portValues[port]) === null || _this$_peripheral$por2 === void 0 ? void 0 : _this$_peripheral$por2.position) !== null && _this$_peripheral$por !== void 0 ? _this$_peripheral$por : 0;
    }
    // ===== MOTOR ENHANCEMENTS (FIXED - HIGH CONFIDENCE) =====
  }, {
    key: "getRelativePosition",
    value: function getRelativePosition(args) {
      var _this$_peripheral$por3, _this$_peripheral$por4;
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // FIXED: Return data from continuous sensor loop, not stale local variable
      var altData = this._peripheral._sensors.motorPositions[port];
      if (altData) {
        return altData.relativePosition;
      }
      // Fallback to standard data
      return (_this$_peripheral$por3 = (_this$_peripheral$por4 = this._peripheral.portValues[port]) === null || _this$_peripheral$por4 === void 0 ? void 0 : _this$_peripheral$por4.relativePosition) !== null && _this$_peripheral$por3 !== void 0 ? _this$_peripheral$por3 : 0;
    }
  }, {
    key: "getAbsolutePosition",
    value: function getAbsolutePosition(args) {
      var _this$_peripheral$por5, _this$_peripheral$por6;
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // FIXED: Return data from continuous sensor loop
      var altData = this._peripheral._sensors.motorPositions[port];
      if (altData) {
        return altData.absolutePosition;
      }
      // Fallback to standard data
      return (_this$_peripheral$por5 = (_this$_peripheral$por6 = this._peripheral.portValues[port]) === null || _this$_peripheral$por6 === void 0 ? void 0 : _this$_peripheral$por6.absolutePosition) !== null && _this$_peripheral$por5 !== void 0 ? _this$_peripheral$por5 : 0;
    }
  }, {
    key: "getSpeed",
    value: function getSpeed(args) {
      var _this$_peripheral$por7, _this$_peripheral$por8;
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // FIXED: Use speed data directly, not conversion
      var altData = this._peripheral._sensors.motorPositions[port];
      if (altData) {
        // alt data is already in the correct format
        return Math.round(altData.speed * 9.3); // Convert to deg/s using alt factor
      }
      // Fallback to standard data with conversion
      var speedPercent = (_this$_peripheral$por7 = (_this$_peripheral$por8 = this._peripheral.portValues[port]) === null || _this$_peripheral$por8 === void 0 ? void 0 : _this$_peripheral$por8.speed) !== null && _this$_peripheral$por7 !== void 0 ? _this$_peripheral$por7 : 0;
      return Math.round(speedPercent * 9.3);
    }
  }, {
    key: "resetMotorPosition",
    value: function resetMotorPosition(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var position = Cast.toNumber(args.POSITION);
      // Use alt preset method
      return this._peripheral.sendPythonCommand("import hub; hub.port.".concat(port, ".motor.preset(").concat(position, ")"));
    }
    // ===== DISPLAY IMPLEMENTATIONS =====
    /**
     * Display text on hub's 5x5 LED matrix
     * @param {object} args - Block arguments
     * @returns {Promise} Command execution promise
     */
  }, {
    key: "displayText",
    value: function displayText(args) {
      var text = Cast.toString(args.TEXT);
      var standardCommand = this._peripheral.sendCommand('scratch.display_text', {
        text: text
      });
      var altCommand = this._peripheral.sendPythonCommand("import hub; hub.display.show(\"".concat(text.replace(/"/g, '\\"'), "\")"));
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
    /**
     * Display custom 5x5 image pattern on hub
     * @param {object} args - Block arguments
     * @returns {Promise} Command execution promise
     */
  }, {
    key: "displayImage",
    value: function displayImage(args) {
      var matrix = Cast.toString(args.MATRIX);
      // Standard approach
      var brightness = Math.round(9 * this._peripheral.pixelBrightness / 100);
      var symbol = (matrix.replace(/\D/g, '') + '0'.repeat(25)).slice(0, 25);
      var image = symbol.replace(/1/g, brightness).match(/.{5}/g).join(':');
      var standardCommand = this._peripheral.sendCommand('scratch.display_image', {
        image: image
      });
      // alt extended approach
      var altImage = symbol.replace(/1/g, '9').replace(/0/g, '_').match(/.{5}/g).join(':');
      var altCommand = this._peripheral.sendPythonCommand("import hub; hub.display.show(hub.Image(\"".concat(altImage, "\"))"));
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
  }, {
    key: "displayPattern",
    value: function displayPattern(args) {
      var pattern = Cast.toString(args.PATTERN);
      var patternData = DisplayPatterns[pattern];
      if (patternData) {
        return this.displayImage({
          MATRIX: patternData
        });
      }
      return Promise.resolve();
    }
  }, {
    key: "displayClear",
    value: function displayClear() {
      var standardCommand = this._peripheral.sendCommand('scratch.display_clear', {});
      var altCommand = this._peripheral.sendPythonCommand('import hub; hub.display.show(" ")');
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
  }, {
    key: "setPixel",
    value: function setPixel(args) {
      var x = Cast.toNumber(args.X) - 1;
      var y = Cast.toNumber(args.Y) - 1;
      var brightness = Cast.toNumber(args.BRIGHTNESS);
      if (x < 0 || x > 4 || y < 0 || y > 4) return Promise.resolve();
      var standardCommand = this._peripheral.sendCommand('scratch.display_set_pixel', {
        x: x,
        y: y,
        brightness: Math.round(brightness * 9 / 100)
      });
      var altCommand = this._peripheral.sendPythonCommand("import hub; hub.display.pixel(".concat(x, ", ").concat(y, ", ").concat(Math.round(brightness * 9 / 100), ")"));
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
  }, {
    key: "rotateDisplay",
    value: function rotateDisplay(args) {
      var angle = Cast.toString(args.ANGLE);
      // alt rotation method
      return this._peripheral.sendPythonCommand("import hub; hub.display.rotation(".concat(angle, ")"));
    }
  }, {
    key: "setCenterButtonColor",
    value: function setCenterButtonColor(args) {
      var colorName = Cast.toString(args.COLOR);
      var colorValue = CenterLEDColors[colorName] || 0;
      var standardCommand = this._peripheral.sendCommand('scratch.center_button_lights', {
        color: colorValue
      });
      var altCommand = this._peripheral.sendPythonCommand("import hub; hub.led(".concat(colorValue, ")"));
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
    // ===== IMU & GYRO =====
  }, {
    key: "getAngle",
    value: function getAngle(args) {
      var axis = Cast.toString(args.AXIS);
      return this._peripheral.angle[axis] || 0;
    }
  }, {
    key: "getGyroRate",
    value: function getGyroRate(args) {
      var axis = Cast.toString(args.AXIS);
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.gyro[axis] || 0;
    }
  }, {
    key: "getFilteredGyroRate",
    value: function getFilteredGyroRate(args) {
      var axis = Cast.toString(args.AXIS);
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.gyroFiltered[axis] || 0;
    }
  }, {
    key: "getAcceleration",
    value: function getAcceleration(args) {
      var axis = Cast.toString(args.AXIS);
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.acceleration[axis] || 0;
    }
  }, {
    key: "getFilteredAcceleration",
    value: function getFilteredAcceleration(args) {
      var axis = Cast.toString(args.AXIS);
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.accelerationFiltered[axis] || 0;
    }
  }, {
    key: "resetYaw",
    value: function resetYaw() {
      this._peripheral._timer.start = Date.now(); // Also reset timer as convenience
      return this._peripheral.sendPythonCommand('import hub; hub.motion.reset_yaw()');
    }
  }, {
    key: "presetYaw",
    value: function presetYaw(args) {
      var angle = Cast.toNumber(args.ANGLE);
      return this._peripheral.sendPythonCommand("import hub; hub.motion.preset_yaw(".concat(angle, ")"));
    }
    // ===== 3X3 LED COLOR MATRIX IMPLEMENTATIONS =====
  }, {
    key: "setMatrix3x3ColorGrid",
    value: function setMatrix3x3ColorGrid(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // Collect all 9 color emojis
      var pixels = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9'].map(function (pixel) {
        var emoji = Cast.toString(args[pixel]);
        var colorId = ColorEmojiMap[emoji] || 0;
        // Default brightness of 5 for color-only grid
        return 5 * 16 + colorId;
      });
      // Convert to hex byte string
      var byteString = pixels.map(function (b) {
        return "\\x".concat(b.toString(16).padStart(2, '0'));
      }).join('');
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"").concat(byteString, "\")"));
    }
  }, {
    key: "setMatrix3x3BrightnessGrid",
    value: function setMatrix3x3BrightnessGrid(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // Get current color state or use default red
      var currentColorId = 9; // Default to red
      // Collect all 9 brightness values
      var pixels = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9'].map(function (brightness) {
        var brightnessValue = MathUtil.clamp(Cast.toNumber(args[brightness]), 1, 10);
        return brightnessValue * 16 + currentColorId;
      });
      // Convert to hex byte string
      var byteString = pixels.map(function (b) {
        return "\\x".concat(b.toString(16).padStart(2, '0'));
      }).join('');
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"").concat(byteString, "\")"));
    }
  }, {
    key: "setMatrix3x3PixelEmoji",
    value: function setMatrix3x3PixelEmoji(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var x = MathUtil.clamp(Cast.toNumber(args.X) - 1, 0, 2);
      var y = MathUtil.clamp(Cast.toNumber(args.Y) - 1, 0, 2);
      var colorEmoji = Cast.toString(args.COLOR);
      var brightness = MathUtil.clamp(Cast.toNumber(args.BRIGHTNESS), 1, 10);
      var colorId = ColorEmojiMap[colorEmoji] || 0;
      var value = brightness * 16 + colorId;
      var index = y * 3 + x;
      var pythonCode = "\nimport hub\nmatrix = hub.port.".concat(port, ".device\nmatrix.mode(2)\n# Create array with current values (or default to off)\ncurrent = [0x01] * 9  # Default: off with brightness 1\ncurrent[").concat(index, "] = 0x").concat(value.toString(16).padStart(2, '0'), "\n# Convert to byte string and send\nbyte_string = bytes(current)\nmatrix.mode(2, byte_string)\n");
      return this._peripheral.sendPythonCommand(pythonCode);
    }
  }, {
    key: "setMatrix3x3SolidColor",
    value: function setMatrix3x3SolidColor(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var colorEmoji = Cast.toString(args.COLOR);
      var brightness = MathUtil.clamp(Cast.toNumber(args.BRIGHTNESS), 1, 10);
      var colorId = ColorEmojiMap[colorEmoji] || 0;
      var value = brightness * 16 + colorId;
      // All 9 pixels same color and brightness
      var pixels = Array(9).fill(value);
      var byteString = pixels.map(function (b) {
        return "\\x".concat(b.toString(16).padStart(2, '0'));
      }).join('');
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"").concat(byteString, "\")"));
    }
  }, {
    key: "setMatrix3x3Visual",
    value: function setMatrix3x3Visual(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // Collect all 9 pixel values
      var pixelArgs = ['R1C1', 'R1C2', 'R1C3', 'R2C1', 'R2C2', 'R2C3', 'R3C1', 'R3C2', 'R3C3'];
      var pixelPattern = pixelArgs.map(function (arg) {
        return Cast.toString(args[arg]) || '.1';
      }).join(' ');
      // Use the same parsing logic as the custom pattern
      return this.setMatrix3x3Custom({
        PORT: port,
        PATTERN: pixelPattern
      });
    }
  }, {
    key: "generateMatrix3x3Code",
    value: function generateMatrix3x3Code(args) {
      var pattern = Cast.toString(args.PATTERN);
      // Parse the pattern to generate both Python code and Scratch code
      var colorCodes = {
        '.': 0,
        'm': 1,
        'v': 2,
        'b': 3,
        't': 4,
        'n': 5,
        'g': 6,
        'y': 7,
        'o': 8,
        'r': 9,
        'w': 10
      };
      try {
        var lines = pattern.split(/\n|\|/);
        var pixels = [];
        var _iterator3 = _createForOfIteratorHelper(lines),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var line = _step3.value;
            var pixelCodes = line.trim().split(/\s+/);
            var _iterator4 = _createForOfIteratorHelper(pixelCodes),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var code = _step4.value;
                if (code.length >= 2) {
                  var colorChar = code.charAt(0).toLowerCase();
                  var brightnessStr = code.substring(1);
                  var colorId = colorCodes[colorChar] !== undefined ? colorCodes[colorChar] : 0;
                  var brightness = Math.max(1, Math.min(10, parseInt(brightnessStr) || 1));
                  pixels.push(brightness * 16 + colorId);
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
          // Ensure we have exactly 9 pixels
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        while (pixels.length < 9) pixels.push(0x01);
        pixels.splice(9);
        // Generate hex byte string
        var hexString = pixels.map(function (b) {
          return "\\x".concat(b.toString(16).padStart(2, '0'));
        }).join('');
        // Return the code format
        return "hub.port.A.device.mode(2, b\"".concat(hexString, "\")");
      } catch (error) {
        return 'Error parsing pattern';
      }
    }
  }, {
    key: "setMatrix3x3Simple",
    value: function setMatrix3x3Simple(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // Collect all 9 pixel values
      var pixelArgs = ['R1C1', 'R1C2', 'R1C3', 'R2C1', 'R2C2', 'R2C3', 'R3C1', 'R3C2', 'R3C3'];
      var pixelPattern = pixelArgs.map(function (arg) {
        return Cast.toString(args[arg]) || '.1';
      }).join(' ');
      // Use the same parsing logic as the custom pattern
      return this.setMatrix3x3Custom({
        PORT: port,
        PATTERN: pixelPattern
      });
    }
  }, {
    key: "setMatrix3x3Custom",
    value: function setMatrix3x3Custom(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var pattern = Cast.toString(args.PATTERN);
      // Parse visual pattern format: "r8 g6 b4\ny7 w9 o5\nm3 v2 .1"
      // Color codes: .(off), m(magenta), v(violet), b(blue), t(turquoise), n(mint), g(green), y(yellow), o(orange), r(red), w(white)
      var colorCodes = {
        '.': 0,
        'm': 1,
        'v': 2,
        'b': 3,
        't': 4,
        'n': 5,
        'g': 6,
        'y': 7,
        'o': 8,
        'r': 9,
        'w': 10
      };
      try {
        // Split by lines and parse each pixel
        var lines = pattern.split(/\n|\|/); // Support both \n and | as separators
        var pixels = [];
        var _iterator5 = _createForOfIteratorHelper(lines),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var line = _step5.value;
            var pixelCodes = line.trim().split(/\s+/); // Split by spaces
            var _iterator6 = _createForOfIteratorHelper(pixelCodes),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var code = _step6.value;
                if (code.length >= 2) {
                  var colorChar = code.charAt(0).toLowerCase();
                  var brightnessStr = code.substring(1);
                  var colorId = colorCodes[colorChar] !== undefined ? colorCodes[colorChar] : 0;
                  var brightness = Math.max(1, Math.min(10, parseInt(brightnessStr) || 1));
                  pixels.push(brightness * 16 + colorId);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
          // Ensure we have exactly 9 pixels, pad or truncate as needed
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        while (pixels.length < 9) pixels.push(0x01); // Default: off with brightness 1
        pixels.splice(9); // Truncate to 9 pixels
        // Convert to hex byte string for Python
        var byteString = pixels.map(function (b) {
          return "\\x".concat(b.toString(16).padStart(2, '0'));
        }).join('');
        // Use documented method
        return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"").concat(byteString, "\")"));
      } catch (error) {
        console.warn('Error parsing 3x3 pattern:', error);
        // Fallback to off pattern
        return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\")"));
      }
    }
  }, {
    key: "setMatrix3x3Pattern",
    value: function setMatrix3x3Pattern(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var pattern = Cast.toString(args.PATTERN);
      // Define 3x3 patterns (using documented color IDs: 0=off, 1=magenta, 2=violet, 3=blue, 4=turquoise, 5=mint, 6=green, 7=yellow, 8=orange, 9=red, 10=white)
      var patterns = {
        heart: [{
          color: 9,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 8
        }, {
          color: 9,
          brightness: 6
        }, {
          color: 9,
          brightness: 10
        }, {
          color: 9,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }],
        smile: [{
          color: 7,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 6
        }],
        star: [{
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 6
        }, {
          color: 7,
          brightness: 10
        }, {
          color: 7,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 7,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }],
        arrow_up: [{
          color: 0,
          brightness: 1
        }, {
          color: 6,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 6,
          brightness: 6
        }, {
          color: 6,
          brightness: 8
        }, {
          color: 6,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 6,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }],
        arrow_down: [{
          color: 0,
          brightness: 1
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 8
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 3,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }],
        arrow_left: [{
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 8
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }],
        arrow_right: [{
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 8,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 8,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }],
        x: [{
          color: 9,
          brightness: 7
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 7
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 9
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 7
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 9,
          brightness: 7
        }],
        check: [{
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 6,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 6,
          brightness: 8
        }, {
          color: 6,
          brightness: 6
        }, {
          color: 6,
          brightness: 8
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }],
        dot: [{
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 10,
          brightness: 10
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 0,
          brightness: 1
        }],
        frame: [{
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 0,
          brightness: 1
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }, {
          color: 3,
          brightness: 6
        }]
      };
      var patternData = patterns[pattern] || patterns.dot;
      // Encode to bytes using documented method: brightness*16 + color
      var bytes = patternData.map(function (pixel) {
        var brightness = Math.max(1, Math.min(10, pixel.brightness));
        var color = Math.max(0, Math.min(10, pixel.color));
        return brightness * 16 + color;
      });
      // Convert to hex byte string for Python
      var byteString = bytes.map(function (b) {
        return "\\x".concat(b.toString(16).padStart(2, '0'));
      }).join('');
      // Use documented method from the research
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"").concat(byteString, "\")"));
    }
  }, {
    key: "setMatrix3x3Color",
    value: function setMatrix3x3Color(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var colorName = Cast.toString(args.COLOR);
      MathUtil.clamp(Cast.toNumber(args.BRIGHTNESS), 1, 10);
      // Map color names to IDs (from documentation)
      var colorMap = {
        'off': 0,
        'magenta': 1,
        'violet': 2,
        'blue': 3,
        'turquoise': 4,
        'mint': 5,
        'green': 6,
        'yellow': 7,
        'orange': 8,
        'red': 9,
        'white': 10
      };
      var colorId = colorMap[colorName] || 0;
      // Use mode 1 for solid color (from documentation)
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(1); matrix.mode(1, b\"\\x").concat(colorId.toString(16).padStart(2, '0'), "\")"));
    }
  }, {
    key: "setMatrix3x3Pixel",
    value: function setMatrix3x3Pixel(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var x = MathUtil.clamp(Cast.toNumber(args.X) - 1, 0, 2);
      var y = MathUtil.clamp(Cast.toNumber(args.Y) - 1, 0, 2);
      var colorName = Cast.toString(args.COLOR);
      var brightness = MathUtil.clamp(Cast.toNumber(args.BRIGHTNESS), 1, 10);
      var colorMap = {
        'off': 0,
        'magenta': 1,
        'violet': 2,
        'blue': 3,
        'turquoise': 4,
        'mint': 5,
        'green': 6,
        'yellow': 7,
        'orange': 8,
        'red': 9,
        'white': 10
      };
      var colorId = colorMap[colorName] || 0;
      var value = brightness * 16 + colorId;
      var index = y * 3 + x;
      // Get current matrix state or create new one
      var pythonCode = "\nimport hub\nmatrix = hub.port.".concat(port, ".device\nmatrix.mode(2)\n# Create array of current values (or default to off)\ncurrent = [0x01] * 9  # Default: off with brightness 1\ncurrent[").concat(index, "] = 0x").concat(value.toString(16).padStart(2, '0'), "\n# Convert to byte string\nbyte_string = bytes(current)\nmatrix.mode(2, byte_string)\n");
      return this._peripheral.sendPythonCommand(pythonCode);
    }
  }, {
    key: "setMatrix3x3Level",
    value: function setMatrix3x3Level(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var level = MathUtil.clamp(Cast.toNumber(args.LEVEL), 0, 9);
      // Use mode 0 for battery level display (from documentation)
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(0); matrix.mode(0, b\"\\x").concat(level.toString(16).padStart(2, '0'), "\")"));
    }
  }, {
    key: "setMatrix3x3Transition",
    value: function setMatrix3x3Transition(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var effect = Cast.toString(args.EFFECT);
      // Use mode 3 for transitions (from documentation)
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(3, b\"\\x").concat(effect.padStart(2, '0'), "\")"));
    }
  }, {
    key: "clearMatrix3x3",
    value: function clearMatrix3x3(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      // Set all pixels to off (brightness 1, color 0)
      return this._peripheral.sendPythonCommand("import hub; matrix = hub.port.".concat(port, ".device; matrix.mode(2); matrix.mode(2, b\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\")"));
    }
    // ===== GESTURE IMPLEMENTATIONS (HIGH CONFIDENCE) =====
  }, {
    key: "whenGesture",
    value: function whenGesture(args) {
      return this.isGesture(args);
    }
  }, {
    key: "isGesture",
    value: function isGesture(args) {
      var gesture = Cast.toString(args.GESTURE);
      return this._peripheral.gestures[gesture] || false;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      var orientationNames = ['up', 'front', 'right', 'down', 'back', 'left'];
      return orientationNames[this._peripheral.orientation] || 'unknown';
    }
    // ===== SOUND IMPLEMENTATIONS (HIGH CONFIDENCE) =====
  }, {
    key: "playHubSound",
    value: function playHubSound(args) {
      var sound = Cast.toString(args.SOUND);
      // Use sound file method
      return this._peripheral.sendPythonCommand("import hub; hub.sound.play(\"/sounds/".concat(sound, "\")"));
    }
  }, {
    key: "playBeep",
    value: function playBeep(args) {
      var frequency = Cast.toNumber(args.FREQUENCY);
      var duration = Cast.toNumber(args.DURATION);
      var standardCommand = this._peripheral.sendCommand('scratch.sound_beep', {
        frequency: frequency,
        duration: duration
      });
      var altCommand = this._peripheral.sendPythonCommand("import hub; hub.sound.beep(".concat(frequency, ", ").concat(duration, ", hub.sound.SOUND_SIN)"));
      return standardCommand.catch(function () {
        return altCommand;
      });
    }
  }, {
    key: "playNote",
    value: function playNote(args) {
      var note = Cast.toNumber(args.NOTE);
      var secs = Cast.toNumber(args.SECS);
      var freq = this._noteToFrequency(note);
      var volume = this._peripheral.volume / 100;
      return this._peripheral.sendPythonCommand("hub.sound.beep(".concat(Math.round(freq), ", ").concat(Math.round(secs * 1000), ", hub.sound.SOUND_SIN, ").concat(volume, ")"));
    }
  }, {
    key: "playWaveBeep",
    value: function playWaveBeep(args) {
      var waveform = Cast.toString(args.WAVEFORM);
      var frequency = Cast.toNumber(args.FREQUENCY);
      var duration = Cast.toNumber(args.DURATION);
      var waveformCode = SoundWaveforms[waveform] || SoundWaveforms.sin;
      // Use advanced beep method
      return this._peripheral.sendPythonCommand("import hub; hub.sound.beep(".concat(frequency, ", ").concat(duration, ", ").concat(waveformCode, ")"));
    }
  }, {
    key: "setVolume",
    value: function setVolume(args) {
      var volume = Cast.toNumber(args.VOLUME);
      this._peripheral._volume = MathUtil.clamp(volume, 0, 100);
      return this._peripheral.sendPythonCommand("hub.sound.volume(".concat(volume, ")"));
    }
  }, {
    key: "stopSound",
    value: function stopSound() {
      return this._peripheral.stopSound();
    }
    // ===== STATUS & TEMPERATURE (FIXED - HIGH CONFIDENCE) =====
  }, {
    key: "getBatteryLevel",
    value: function getBatteryLevel() {
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.battery || 100;
    }
  }, {
    key: "getBatteryTemperature",
    value: function getBatteryTemperature() {
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.temperature || 25;
    }
  }, {
    key: "getHubTemperature",
    value: function getHubTemperature() {
      // FIXED: Return data from continuous sensor loop
      return this._peripheral.hubTemp || 25;
    }
    // ===== TIMER FUNCTIONALITY (NEW) =====
  }, {
    key: "getTimer",
    value: function getTimer() {
      return this._peripheral.timer;
    }
  }, {
    key: "resetTimer",
    value: function resetTimer() {
      this._peripheral._timer.start = Date.now();
      this._peripheral._timer.current = 0;
    }
    // ===== SENSOR IMPLEMENTATIONS (HIGH CONFIDENCE) =====
  }, {
    key: "getDistance",
    value: function getDistance(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'distance') {
        return portData.distance;
      }
      return 0;
    }
  }, {
    key: "setDistanceLights",
    value: function setDistanceLights(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var tl = MathUtil.clamp(Cast.toNumber(args.TL), 0, 9);
      var tr = MathUtil.clamp(Cast.toNumber(args.TR), 0, 9);
      var bl = MathUtil.clamp(Cast.toNumber(args.BL), 0, 9);
      var br = MathUtil.clamp(Cast.toNumber(args.BR), 0, 9);
      // Use distance sensor LED control
      return this._peripheral.sendPythonCommand("import hub; dist_sensor = hub.port.".concat(port, ".device; dist_sensor.mode(5, bytes([").concat(tl, ", ").concat(tr, ", ").concat(bl, ", ").concat(br, "]))"));
    }
  }, {
    key: "getColor",
    value: function getColor(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'color') {
        var colorNames = ['black', 'magenta', 'purple', 'blue', 'azure', 'turquoise', 'green', 'yellow', 'orange', 'red', 'white'];
        return colorNames[portData.color] || 'none';
      }
      return 'none';
    }
  }, {
    key: "getReflection",
    value: function getReflection(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'color') {
        return portData.reflection || 0;
      }
      return 0;
    }
  }, {
    key: "getAmbientLight",
    value: function getAmbientLight(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'color') {
        return portData.ambient || 0;
      }
      return 0;
    }
  }, {
    key: "getForce",
    value: function getForce(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'force') {
        return portData.force || 0;
      }
      return 0;
    }
  }, {
    key: "isForceSensorPressed",
    value: function isForceSensorPressed(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'force') {
        return portData.pressed || false;
      }
      return false;
    }
    // ===== EVENT-BASED SENSOR BLOCKS (NEW) =====
  }, {
    key: "whenColor",
    value: function whenColor(args) {
      return this.isColor(args);
    }
  }, {
    key: "isColor",
    value: function isColor(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var color = Cast.toString(args.COLOR);
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'color') {
        var colorNames = ['black', 'magenta', 'purple', 'blue', 'azure', 'turquoise', 'green', 'yellow', 'orange', 'red', 'white'];
        return colorNames[portData.color] === color;
      }
      return false;
    }
  }, {
    key: "whenForceSensor",
    value: function whenForceSensor(args) {
      var port = Cast.toString(args.PORT).trim().toUpperCase();
      var state = Cast.toString(args.STATE);
      var portData = this._peripheral.portValues[port];
      if (portData && portData.type === 'force') {
        switch (state) {
          case 'pressed':
            return portData.pressed;
          case 'hard pressed':
            return portData.force > 8;
          // Force in Newtons for "hard pressed"
          case 'released':
            return !portData.pressed;
        }
      }
      return false;
    }
    // ===== BUTTON IMPLEMENTATIONS (HIGH CONFIDENCE) =====
  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(args) {
      var button = Cast.toString(args.BUTTON);
      var buttonIndex = {
        left: 0,
        center: 1,
        right: 2
      }[button];
      if (buttonIndex !== undefined) {
        return this._peripheral._sensors.buttons[buttonIndex] === 1;
      }
      return false;
    }
  }, {
    key: "whenButtonPressed",
    value: function whenButtonPressed(args) {
      return this.isButtonPressed(args);
    }
    // ===== PYTHON REPL FUNCTIONALITY (NEW) =====
  }, {
    key: "runReplCommand",
    value: function runReplCommand(args) {
      var code = Cast.toString(args.CODE);
      return this._peripheral.sendReplCommand(code);
    }
  }, {
    key: "getReplOutput",
    value: function getReplOutput() {
      return this._peripheral.replOutput || '';
    }
  }, {
    key: "clearReplOutput",
    value: function clearReplOutput() {
      this._peripheral._replOutput = '';
    }
  }, {
    key: "getReplHistory",
    value: function getReplHistory(args) {
      var index = Cast.toNumber(args.INDEX);
      var history = this._peripheral.replHistory;
      if (index === -1) {
        return history[history.length - 1] || '';
      } else if (index >= 0 && index < history.length) {
        return history[index] || '';
      }
      return '';
    }
    // ===== PYTHON COMMANDS (HIGH CONFIDENCE) =====
  }, {
    key: "runPythonCommand",
    value: function runPythonCommand(args) {
      var code = Cast.toString(args.CODE);
      return this._peripheral.sendPythonCommand(code);
    }
  }, {
    key: "runHubCommand",
    value: function runHubCommand(args) {
      var code = Cast.toString(args.CODE);
      var pythonCode = "import hub; ".concat(code);
      return this._peripheral.sendPythonCommand(pythonCode);
    }
  }, {
    key: "exitScript",
    value: function exitScript() {
      // Use exit method
      return this._peripheral.sendPythonCommand('raise SystemExit');
    }
    // ===== UTILITY METHODS =====
    /**
     * Handle note playing for sound picker integration
     * @param {object} note - Note data
     * @param {string} category - Extension category
     */
  }, {
    key: "_playNoteForPicker",
    value: function _playNoteForPicker(note, category) {
      if (category !== this.getInfo().name) return;
      this.playBeep({
        FREQUENCY: this._noteToFrequency(note),
        DURATION: 250
      });
    }
  }, {
    key: "_noteToFrequency",
    value: function _noteToFrequency(note) {
      return Math.pow(2, (note - 69 + 12) / 12) * 440;
    }
    /**
     * Validate and parse port specification string
     * @param {string} text - Port specification (e.g., "A", "A+B", "A+B+C+D+E+F")
     * @returns {Array} Array of valid port letters
     */
  }, {
    key: "_validatePorts",
    value: function _validatePorts(text) {
      return text.toUpperCase().replace(/[^ABCDEF]/g, '').split('').filter(function (x, i, self) {
        return self.indexOf(x) === i;
      }).sort();
    }
  }], [{
    key: "EXTENSION_ID",
    get: function get() {
      return 'spikeprime';
    }
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    },
    set: function set(url) {
      extensionURL = url;
    }
  }]);
}(); // Generated ES Module export
_defineProperty(Scratch3SpikePrimeBlocks, "fieldRegistered", false);
var blockClass = Scratch3SpikePrimeBlocks;
blockClass = Scratch3SpikePrimeBlocks;

export { blockClass, entry };
